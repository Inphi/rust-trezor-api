// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-eos.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct EosGetPublicKey {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosGetPublicKey {
    fn default() -> &'a EosGetPublicKey {
        <EosGetPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl EosGetPublicKey {
    pub fn new() -> EosGetPublicKey {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosGetPublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosGetPublicKey {
        EosGetPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &EosGetPublicKey| { &m.address_n },
                |m: &mut EosGetPublicKey| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_display",
                |m: &EosGetPublicKey| { &m.show_display },
                |m: &mut EosGetPublicKey| { &mut m.show_display },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosGetPublicKey>(
                "EosGetPublicKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosGetPublicKey {
        static instance: ::protobuf::rt::LazyV2<EosGetPublicKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosGetPublicKey::new)
    }
}

impl ::protobuf::Clear for EosGetPublicKey {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosGetPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosGetPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosPublicKey {
    // message fields
    wif_public_key: ::protobuf::SingularField<::std::string::String>,
    raw_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosPublicKey {
    fn default() -> &'a EosPublicKey {
        <EosPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl EosPublicKey {
    pub fn new() -> EosPublicKey {
        ::std::default::Default::default()
    }

    // required string wif_public_key = 1;


    pub fn get_wif_public_key(&self) -> &str {
        match self.wif_public_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_wif_public_key(&mut self) {
        self.wif_public_key.clear();
    }

    pub fn has_wif_public_key(&self) -> bool {
        self.wif_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wif_public_key(&mut self, v: ::std::string::String) {
        self.wif_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wif_public_key(&mut self) -> &mut ::std::string::String {
        if self.wif_public_key.is_none() {
            self.wif_public_key.set_default();
        }
        self.wif_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_wif_public_key(&mut self) -> ::std::string::String {
        self.wif_public_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes raw_public_key = 2;


    pub fn get_raw_public_key(&self) -> &[u8] {
        match self.raw_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_raw_public_key(&mut self) {
        self.raw_public_key.clear();
    }

    pub fn has_raw_public_key(&self) -> bool {
        self.raw_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_public_key.is_none() {
            self.raw_public_key.set_default();
        }
        self.raw_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EosPublicKey {
    fn is_initialized(&self) -> bool {
        if self.wif_public_key.is_none() {
            return false;
        }
        if self.raw_public_key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.wif_public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.raw_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.wif_public_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.raw_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.wif_public_key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.raw_public_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosPublicKey {
        EosPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wif_public_key",
                |m: &EosPublicKey| { &m.wif_public_key },
                |m: &mut EosPublicKey| { &mut m.wif_public_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "raw_public_key",
                |m: &EosPublicKey| { &m.raw_public_key },
                |m: &mut EosPublicKey| { &mut m.raw_public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosPublicKey>(
                "EosPublicKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosPublicKey {
        static instance: ::protobuf::rt::LazyV2<EosPublicKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosPublicKey::new)
    }
}

impl ::protobuf::Clear for EosPublicKey {
    fn clear(&mut self) {
        self.wif_public_key.clear();
        self.raw_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosSignTx {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    chain_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub header: ::protobuf::SingularPtrField<EosSignTx_EosTxHeader>,
    num_actions: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosSignTx {
    fn default() -> &'a EosSignTx {
        <EosSignTx as ::protobuf::Message>::default_instance()
    }
}

impl EosSignTx {
    pub fn new() -> EosSignTx {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bytes chain_id = 2;


    pub fn get_chain_id(&self) -> &[u8] {
        match self.chain_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_chain_id(&mut self) {
        self.chain_id.clear();
    }

    pub fn has_chain_id(&self) -> bool {
        self.chain_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chain_id.is_none() {
            self.chain_id.set_default();
        }
        self.chain_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain_id(&mut self) -> ::std::vec::Vec<u8> {
        self.chain_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.eos.EosSignTx.EosTxHeader header = 3;


    pub fn get_header(&self) -> &EosSignTx_EosTxHeader {
        self.header.as_ref().unwrap_or_else(|| <EosSignTx_EosTxHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: EosSignTx_EosTxHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut EosSignTx_EosTxHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> EosSignTx_EosTxHeader {
        self.header.take().unwrap_or_else(|| EosSignTx_EosTxHeader::new())
    }

    // optional uint32 num_actions = 4;


    pub fn get_num_actions(&self) -> u32 {
        self.num_actions.unwrap_or(0)
    }
    pub fn clear_num_actions(&mut self) {
        self.num_actions = ::std::option::Option::None;
    }

    pub fn has_num_actions(&self) -> bool {
        self.num_actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_actions(&mut self, v: u32) {
        self.num_actions = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosSignTx {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.chain_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_actions = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.chain_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.num_actions {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(ref v) = self.chain_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.num_actions {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosSignTx {
        EosSignTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &EosSignTx| { &m.address_n },
                |m: &mut EosSignTx| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "chain_id",
                |m: &EosSignTx| { &m.chain_id },
                |m: &mut EosSignTx| { &mut m.chain_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosSignTx_EosTxHeader>>(
                "header",
                |m: &EosSignTx| { &m.header },
                |m: &mut EosSignTx| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_actions",
                |m: &EosSignTx| { &m.num_actions },
                |m: &mut EosSignTx| { &mut m.num_actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosSignTx>(
                "EosSignTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosSignTx {
        static instance: ::protobuf::rt::LazyV2<EosSignTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosSignTx::new)
    }
}

impl ::protobuf::Clear for EosSignTx {
    fn clear(&mut self) {
        self.address_n.clear();
        self.chain_id.clear();
        self.header.clear();
        self.num_actions = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosSignTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosSignTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosSignTx_EosTxHeader {
    // message fields
    expiration: ::std::option::Option<u32>,
    ref_block_num: ::std::option::Option<u32>,
    ref_block_prefix: ::std::option::Option<u32>,
    max_net_usage_words: ::std::option::Option<u32>,
    max_cpu_usage_ms: ::std::option::Option<u32>,
    delay_sec: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosSignTx_EosTxHeader {
    fn default() -> &'a EosSignTx_EosTxHeader {
        <EosSignTx_EosTxHeader as ::protobuf::Message>::default_instance()
    }
}

impl EosSignTx_EosTxHeader {
    pub fn new() -> EosSignTx_EosTxHeader {
        ::std::default::Default::default()
    }

    // required uint32 expiration = 1;


    pub fn get_expiration(&self) -> u32 {
        self.expiration.unwrap_or(0)
    }
    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: u32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    // required uint32 ref_block_num = 2;


    pub fn get_ref_block_num(&self) -> u32 {
        self.ref_block_num.unwrap_or(0)
    }
    pub fn clear_ref_block_num(&mut self) {
        self.ref_block_num = ::std::option::Option::None;
    }

    pub fn has_ref_block_num(&self) -> bool {
        self.ref_block_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_block_num(&mut self, v: u32) {
        self.ref_block_num = ::std::option::Option::Some(v);
    }

    // required uint32 ref_block_prefix = 3;


    pub fn get_ref_block_prefix(&self) -> u32 {
        self.ref_block_prefix.unwrap_or(0)
    }
    pub fn clear_ref_block_prefix(&mut self) {
        self.ref_block_prefix = ::std::option::Option::None;
    }

    pub fn has_ref_block_prefix(&self) -> bool {
        self.ref_block_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_block_prefix(&mut self, v: u32) {
        self.ref_block_prefix = ::std::option::Option::Some(v);
    }

    // required uint32 max_net_usage_words = 4;


    pub fn get_max_net_usage_words(&self) -> u32 {
        self.max_net_usage_words.unwrap_or(0)
    }
    pub fn clear_max_net_usage_words(&mut self) {
        self.max_net_usage_words = ::std::option::Option::None;
    }

    pub fn has_max_net_usage_words(&self) -> bool {
        self.max_net_usage_words.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_net_usage_words(&mut self, v: u32) {
        self.max_net_usage_words = ::std::option::Option::Some(v);
    }

    // required uint32 max_cpu_usage_ms = 5;


    pub fn get_max_cpu_usage_ms(&self) -> u32 {
        self.max_cpu_usage_ms.unwrap_or(0)
    }
    pub fn clear_max_cpu_usage_ms(&mut self) {
        self.max_cpu_usage_ms = ::std::option::Option::None;
    }

    pub fn has_max_cpu_usage_ms(&self) -> bool {
        self.max_cpu_usage_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_cpu_usage_ms(&mut self, v: u32) {
        self.max_cpu_usage_ms = ::std::option::Option::Some(v);
    }

    // required uint32 delay_sec = 6;


    pub fn get_delay_sec(&self) -> u32 {
        self.delay_sec.unwrap_or(0)
    }
    pub fn clear_delay_sec(&mut self) {
        self.delay_sec = ::std::option::Option::None;
    }

    pub fn has_delay_sec(&self) -> bool {
        self.delay_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_sec(&mut self, v: u32) {
        self.delay_sec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosSignTx_EosTxHeader {
    fn is_initialized(&self) -> bool {
        if self.expiration.is_none() {
            return false;
        }
        if self.ref_block_num.is_none() {
            return false;
        }
        if self.ref_block_prefix.is_none() {
            return false;
        }
        if self.max_net_usage_words.is_none() {
            return false;
        }
        if self.max_cpu_usage_ms.is_none() {
            return false;
        }
        if self.delay_sec.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ref_block_num = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ref_block_prefix = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_net_usage_words = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_cpu_usage_ms = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delay_sec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ref_block_num {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ref_block_prefix {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_net_usage_words {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_cpu_usage_ms {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delay_sec {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.expiration {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ref_block_num {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ref_block_prefix {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_net_usage_words {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.max_cpu_usage_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.delay_sec {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosSignTx_EosTxHeader {
        EosSignTx_EosTxHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiration",
                |m: &EosSignTx_EosTxHeader| { &m.expiration },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ref_block_num",
                |m: &EosSignTx_EosTxHeader| { &m.ref_block_num },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.ref_block_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ref_block_prefix",
                |m: &EosSignTx_EosTxHeader| { &m.ref_block_prefix },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.ref_block_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_net_usage_words",
                |m: &EosSignTx_EosTxHeader| { &m.max_net_usage_words },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.max_net_usage_words },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_cpu_usage_ms",
                |m: &EosSignTx_EosTxHeader| { &m.max_cpu_usage_ms },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.max_cpu_usage_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delay_sec",
                |m: &EosSignTx_EosTxHeader| { &m.delay_sec },
                |m: &mut EosSignTx_EosTxHeader| { &mut m.delay_sec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosSignTx_EosTxHeader>(
                "EosSignTx.EosTxHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosSignTx_EosTxHeader {
        static instance: ::protobuf::rt::LazyV2<EosSignTx_EosTxHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosSignTx_EosTxHeader::new)
    }
}

impl ::protobuf::Clear for EosSignTx_EosTxHeader {
    fn clear(&mut self) {
        self.expiration = ::std::option::Option::None;
        self.ref_block_num = ::std::option::Option::None;
        self.ref_block_prefix = ::std::option::Option::None;
        self.max_net_usage_words = ::std::option::Option::None;
        self.max_cpu_usage_ms = ::std::option::Option::None;
        self.delay_sec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosSignTx_EosTxHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosSignTx_EosTxHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionRequest {
    // message fields
    data_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionRequest {
    fn default() -> &'a EosTxActionRequest {
        <EosTxActionRequest as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionRequest {
    pub fn new() -> EosTxActionRequest {
        ::std::default::Default::default()
    }

    // optional uint32 data_size = 1;


    pub fn get_data_size(&self) -> u32 {
        self.data_size.unwrap_or(0)
    }
    pub fn clear_data_size(&mut self) {
        self.data_size = ::std::option::Option::None;
    }

    pub fn has_data_size(&self) -> bool {
        self.data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_size(&mut self, v: u32) {
        self.data_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_size {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionRequest {
        EosTxActionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_size",
                |m: &EosTxActionRequest| { &m.data_size },
                |m: &mut EosTxActionRequest| { &mut m.data_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionRequest>(
                "EosTxActionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionRequest {
        static instance: ::protobuf::rt::LazyV2<EosTxActionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionRequest::new)
    }
}

impl ::protobuf::Clear for EosTxActionRequest {
    fn clear(&mut self) {
        self.data_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck {
    // message fields
    pub common: ::protobuf::SingularPtrField<EosTxActionAck_EosActionCommon>,
    pub transfer: ::protobuf::SingularPtrField<EosTxActionAck_EosActionTransfer>,
    pub delegate: ::protobuf::SingularPtrField<EosTxActionAck_EosActionDelegate>,
    pub undelegate: ::protobuf::SingularPtrField<EosTxActionAck_EosActionUndelegate>,
    pub refund: ::protobuf::SingularPtrField<EosTxActionAck_EosActionRefund>,
    pub buy_ram: ::protobuf::SingularPtrField<EosTxActionAck_EosActionBuyRam>,
    pub buy_ram_bytes: ::protobuf::SingularPtrField<EosTxActionAck_EosActionBuyRamBytes>,
    pub sell_ram: ::protobuf::SingularPtrField<EosTxActionAck_EosActionSellRam>,
    pub vote_producer: ::protobuf::SingularPtrField<EosTxActionAck_EosActionVoteProducer>,
    pub update_auth: ::protobuf::SingularPtrField<EosTxActionAck_EosActionUpdateAuth>,
    pub delete_auth: ::protobuf::SingularPtrField<EosTxActionAck_EosActionDeleteAuth>,
    pub link_auth: ::protobuf::SingularPtrField<EosTxActionAck_EosActionLinkAuth>,
    pub unlink_auth: ::protobuf::SingularPtrField<EosTxActionAck_EosActionUnlinkAuth>,
    pub new_account: ::protobuf::SingularPtrField<EosTxActionAck_EosActionNewAccount>,
    pub unknown: ::protobuf::SingularPtrField<EosTxActionAck_EosActionUnknown>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck {
    fn default() -> &'a EosTxActionAck {
        <EosTxActionAck as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck {
    pub fn new() -> EosTxActionAck {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionCommon common = 1;


    pub fn get_common(&self) -> &EosTxActionAck_EosActionCommon {
        self.common.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionCommon as ::protobuf::Message>::default_instance())
    }
    pub fn clear_common(&mut self) {
        self.common.clear();
    }

    pub fn has_common(&self) -> bool {
        self.common.is_some()
    }

    // Param is passed by value, moved
    pub fn set_common(&mut self, v: EosTxActionAck_EosActionCommon) {
        self.common = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_common(&mut self) -> &mut EosTxActionAck_EosActionCommon {
        if self.common.is_none() {
            self.common.set_default();
        }
        self.common.as_mut().unwrap()
    }

    // Take field
    pub fn take_common(&mut self) -> EosTxActionAck_EosActionCommon {
        self.common.take().unwrap_or_else(|| EosTxActionAck_EosActionCommon::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionTransfer transfer = 2;


    pub fn get_transfer(&self) -> &EosTxActionAck_EosActionTransfer {
        self.transfer.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionTransfer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transfer(&mut self) {
        self.transfer.clear();
    }

    pub fn has_transfer(&self) -> bool {
        self.transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer(&mut self, v: EosTxActionAck_EosActionTransfer) {
        self.transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer(&mut self) -> &mut EosTxActionAck_EosActionTransfer {
        if self.transfer.is_none() {
            self.transfer.set_default();
        }
        self.transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_transfer(&mut self) -> EosTxActionAck_EosActionTransfer {
        self.transfer.take().unwrap_or_else(|| EosTxActionAck_EosActionTransfer::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDelegate delegate = 3;


    pub fn get_delegate(&self) -> &EosTxActionAck_EosActionDelegate {
        self.delegate.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionDelegate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: EosTxActionAck_EosActionDelegate) {
        self.delegate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut EosTxActionAck_EosActionDelegate {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> EosTxActionAck_EosActionDelegate {
        self.delegate.take().unwrap_or_else(|| EosTxActionAck_EosActionDelegate::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUndelegate undelegate = 4;


    pub fn get_undelegate(&self) -> &EosTxActionAck_EosActionUndelegate {
        self.undelegate.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionUndelegate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_undelegate(&mut self) {
        self.undelegate.clear();
    }

    pub fn has_undelegate(&self) -> bool {
        self.undelegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undelegate(&mut self, v: EosTxActionAck_EosActionUndelegate) {
        self.undelegate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_undelegate(&mut self) -> &mut EosTxActionAck_EosActionUndelegate {
        if self.undelegate.is_none() {
            self.undelegate.set_default();
        }
        self.undelegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_undelegate(&mut self) -> EosTxActionAck_EosActionUndelegate {
        self.undelegate.take().unwrap_or_else(|| EosTxActionAck_EosActionUndelegate::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionRefund refund = 5;


    pub fn get_refund(&self) -> &EosTxActionAck_EosActionRefund {
        self.refund.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionRefund as ::protobuf::Message>::default_instance())
    }
    pub fn clear_refund(&mut self) {
        self.refund.clear();
    }

    pub fn has_refund(&self) -> bool {
        self.refund.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refund(&mut self, v: EosTxActionAck_EosActionRefund) {
        self.refund = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refund(&mut self) -> &mut EosTxActionAck_EosActionRefund {
        if self.refund.is_none() {
            self.refund.set_default();
        }
        self.refund.as_mut().unwrap()
    }

    // Take field
    pub fn take_refund(&mut self) -> EosTxActionAck_EosActionRefund {
        self.refund.take().unwrap_or_else(|| EosTxActionAck_EosActionRefund::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRam buy_ram = 6;


    pub fn get_buy_ram(&self) -> &EosTxActionAck_EosActionBuyRam {
        self.buy_ram.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionBuyRam as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buy_ram(&mut self) {
        self.buy_ram.clear();
    }

    pub fn has_buy_ram(&self) -> bool {
        self.buy_ram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buy_ram(&mut self, v: EosTxActionAck_EosActionBuyRam) {
        self.buy_ram = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buy_ram(&mut self) -> &mut EosTxActionAck_EosActionBuyRam {
        if self.buy_ram.is_none() {
            self.buy_ram.set_default();
        }
        self.buy_ram.as_mut().unwrap()
    }

    // Take field
    pub fn take_buy_ram(&mut self) -> EosTxActionAck_EosActionBuyRam {
        self.buy_ram.take().unwrap_or_else(|| EosTxActionAck_EosActionBuyRam::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionBuyRamBytes buy_ram_bytes = 7;


    pub fn get_buy_ram_bytes(&self) -> &EosTxActionAck_EosActionBuyRamBytes {
        self.buy_ram_bytes.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionBuyRamBytes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buy_ram_bytes(&mut self) {
        self.buy_ram_bytes.clear();
    }

    pub fn has_buy_ram_bytes(&self) -> bool {
        self.buy_ram_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buy_ram_bytes(&mut self, v: EosTxActionAck_EosActionBuyRamBytes) {
        self.buy_ram_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buy_ram_bytes(&mut self) -> &mut EosTxActionAck_EosActionBuyRamBytes {
        if self.buy_ram_bytes.is_none() {
            self.buy_ram_bytes.set_default();
        }
        self.buy_ram_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_buy_ram_bytes(&mut self) -> EosTxActionAck_EosActionBuyRamBytes {
        self.buy_ram_bytes.take().unwrap_or_else(|| EosTxActionAck_EosActionBuyRamBytes::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionSellRam sell_ram = 8;


    pub fn get_sell_ram(&self) -> &EosTxActionAck_EosActionSellRam {
        self.sell_ram.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionSellRam as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sell_ram(&mut self) {
        self.sell_ram.clear();
    }

    pub fn has_sell_ram(&self) -> bool {
        self.sell_ram.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sell_ram(&mut self, v: EosTxActionAck_EosActionSellRam) {
        self.sell_ram = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sell_ram(&mut self) -> &mut EosTxActionAck_EosActionSellRam {
        if self.sell_ram.is_none() {
            self.sell_ram.set_default();
        }
        self.sell_ram.as_mut().unwrap()
    }

    // Take field
    pub fn take_sell_ram(&mut self) -> EosTxActionAck_EosActionSellRam {
        self.sell_ram.take().unwrap_or_else(|| EosTxActionAck_EosActionSellRam::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionVoteProducer vote_producer = 9;


    pub fn get_vote_producer(&self) -> &EosTxActionAck_EosActionVoteProducer {
        self.vote_producer.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionVoteProducer as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vote_producer(&mut self) {
        self.vote_producer.clear();
    }

    pub fn has_vote_producer(&self) -> bool {
        self.vote_producer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_producer(&mut self, v: EosTxActionAck_EosActionVoteProducer) {
        self.vote_producer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote_producer(&mut self) -> &mut EosTxActionAck_EosActionVoteProducer {
        if self.vote_producer.is_none() {
            self.vote_producer.set_default();
        }
        self.vote_producer.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote_producer(&mut self) -> EosTxActionAck_EosActionVoteProducer {
        self.vote_producer.take().unwrap_or_else(|| EosTxActionAck_EosActionVoteProducer::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAuth update_auth = 10;


    pub fn get_update_auth(&self) -> &EosTxActionAck_EosActionUpdateAuth {
        self.update_auth.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionUpdateAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update_auth(&mut self) {
        self.update_auth.clear();
    }

    pub fn has_update_auth(&self) -> bool {
        self.update_auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_auth(&mut self, v: EosTxActionAck_EosActionUpdateAuth) {
        self.update_auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_auth(&mut self) -> &mut EosTxActionAck_EosActionUpdateAuth {
        if self.update_auth.is_none() {
            self.update_auth.set_default();
        }
        self.update_auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_auth(&mut self) -> EosTxActionAck_EosActionUpdateAuth {
        self.update_auth.take().unwrap_or_else(|| EosTxActionAck_EosActionUpdateAuth::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionDeleteAuth delete_auth = 11;


    pub fn get_delete_auth(&self) -> &EosTxActionAck_EosActionDeleteAuth {
        self.delete_auth.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionDeleteAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_delete_auth(&mut self) {
        self.delete_auth.clear();
    }

    pub fn has_delete_auth(&self) -> bool {
        self.delete_auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_auth(&mut self, v: EosTxActionAck_EosActionDeleteAuth) {
        self.delete_auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delete_auth(&mut self) -> &mut EosTxActionAck_EosActionDeleteAuth {
        if self.delete_auth.is_none() {
            self.delete_auth.set_default();
        }
        self.delete_auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_delete_auth(&mut self) -> EosTxActionAck_EosActionDeleteAuth {
        self.delete_auth.take().unwrap_or_else(|| EosTxActionAck_EosActionDeleteAuth::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionLinkAuth link_auth = 12;


    pub fn get_link_auth(&self) -> &EosTxActionAck_EosActionLinkAuth {
        self.link_auth.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionLinkAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_link_auth(&mut self) {
        self.link_auth.clear();
    }

    pub fn has_link_auth(&self) -> bool {
        self.link_auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_auth(&mut self, v: EosTxActionAck_EosActionLinkAuth) {
        self.link_auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_auth(&mut self) -> &mut EosTxActionAck_EosActionLinkAuth {
        if self.link_auth.is_none() {
            self.link_auth.set_default();
        }
        self.link_auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_link_auth(&mut self) -> EosTxActionAck_EosActionLinkAuth {
        self.link_auth.take().unwrap_or_else(|| EosTxActionAck_EosActionLinkAuth::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnlinkAuth unlink_auth = 13;


    pub fn get_unlink_auth(&self) -> &EosTxActionAck_EosActionUnlinkAuth {
        self.unlink_auth.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionUnlinkAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unlink_auth(&mut self) {
        self.unlink_auth.clear();
    }

    pub fn has_unlink_auth(&self) -> bool {
        self.unlink_auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlink_auth(&mut self, v: EosTxActionAck_EosActionUnlinkAuth) {
        self.unlink_auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlink_auth(&mut self) -> &mut EosTxActionAck_EosActionUnlinkAuth {
        if self.unlink_auth.is_none() {
            self.unlink_auth.set_default();
        }
        self.unlink_auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlink_auth(&mut self) -> EosTxActionAck_EosActionUnlinkAuth {
        self.unlink_auth.take().unwrap_or_else(|| EosTxActionAck_EosActionUnlinkAuth::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionNewAccount new_account = 14;


    pub fn get_new_account(&self) -> &EosTxActionAck_EosActionNewAccount {
        self.new_account.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionNewAccount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_new_account(&mut self) {
        self.new_account.clear();
    }

    pub fn has_new_account(&self) -> bool {
        self.new_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_account(&mut self, v: EosTxActionAck_EosActionNewAccount) {
        self.new_account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_account(&mut self) -> &mut EosTxActionAck_EosActionNewAccount {
        if self.new_account.is_none() {
            self.new_account.set_default();
        }
        self.new_account.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_account(&mut self) -> EosTxActionAck_EosActionNewAccount {
        self.new_account.take().unwrap_or_else(|| EosTxActionAck_EosActionNewAccount::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosActionUnknown unknown = 15;


    pub fn get_unknown(&self) -> &EosTxActionAck_EosActionUnknown {
        self.unknown.as_ref().unwrap_or_else(|| <EosTxActionAck_EosActionUnknown as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unknown(&mut self) {
        self.unknown.clear();
    }

    pub fn has_unknown(&self) -> bool {
        self.unknown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown(&mut self, v: EosTxActionAck_EosActionUnknown) {
        self.unknown = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unknown(&mut self) -> &mut EosTxActionAck_EosActionUnknown {
        if self.unknown.is_none() {
            self.unknown.set_default();
        }
        self.unknown.as_mut().unwrap()
    }

    // Take field
    pub fn take_unknown(&mut self) -> EosTxActionAck_EosActionUnknown {
        self.unknown.take().unwrap_or_else(|| EosTxActionAck_EosActionUnknown::new())
    }
}

impl ::protobuf::Message for EosTxActionAck {
    fn is_initialized(&self) -> bool {
        for v in &self.common {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delegate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.undelegate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refund {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buy_ram {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buy_ram_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sell_ram {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vote_producer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delete_auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.link_auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unlink_auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.new_account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unknown {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.common)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transfer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegate)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.undelegate)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.refund)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buy_ram)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buy_ram_bytes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sell_ram)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote_producer)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_auth)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delete_auth)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.link_auth)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unlink_auth)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.new_account)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unknown)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.common.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.undelegate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.refund.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buy_ram.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buy_ram_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sell_ram.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vote_producer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delete_auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.link_auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unlink_auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.new_account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unknown.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.common.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.undelegate.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.refund.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buy_ram.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buy_ram_bytes.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sell_ram.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vote_producer.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_auth.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delete_auth.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.link_auth.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unlink_auth.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.new_account.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unknown.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck {
        EosTxActionAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionCommon>>(
                "common",
                |m: &EosTxActionAck| { &m.common },
                |m: &mut EosTxActionAck| { &mut m.common },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionTransfer>>(
                "transfer",
                |m: &EosTxActionAck| { &m.transfer },
                |m: &mut EosTxActionAck| { &mut m.transfer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionDelegate>>(
                "delegate",
                |m: &EosTxActionAck| { &m.delegate },
                |m: &mut EosTxActionAck| { &mut m.delegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionUndelegate>>(
                "undelegate",
                |m: &EosTxActionAck| { &m.undelegate },
                |m: &mut EosTxActionAck| { &mut m.undelegate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionRefund>>(
                "refund",
                |m: &EosTxActionAck| { &m.refund },
                |m: &mut EosTxActionAck| { &mut m.refund },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionBuyRam>>(
                "buy_ram",
                |m: &EosTxActionAck| { &m.buy_ram },
                |m: &mut EosTxActionAck| { &mut m.buy_ram },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionBuyRamBytes>>(
                "buy_ram_bytes",
                |m: &EosTxActionAck| { &m.buy_ram_bytes },
                |m: &mut EosTxActionAck| { &mut m.buy_ram_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionSellRam>>(
                "sell_ram",
                |m: &EosTxActionAck| { &m.sell_ram },
                |m: &mut EosTxActionAck| { &mut m.sell_ram },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionVoteProducer>>(
                "vote_producer",
                |m: &EosTxActionAck| { &m.vote_producer },
                |m: &mut EosTxActionAck| { &mut m.vote_producer },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionUpdateAuth>>(
                "update_auth",
                |m: &EosTxActionAck| { &m.update_auth },
                |m: &mut EosTxActionAck| { &mut m.update_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionDeleteAuth>>(
                "delete_auth",
                |m: &EosTxActionAck| { &m.delete_auth },
                |m: &mut EosTxActionAck| { &mut m.delete_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionLinkAuth>>(
                "link_auth",
                |m: &EosTxActionAck| { &m.link_auth },
                |m: &mut EosTxActionAck| { &mut m.link_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionUnlinkAuth>>(
                "unlink_auth",
                |m: &EosTxActionAck| { &m.unlink_auth },
                |m: &mut EosTxActionAck| { &mut m.unlink_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionNewAccount>>(
                "new_account",
                |m: &EosTxActionAck| { &m.new_account },
                |m: &mut EosTxActionAck| { &mut m.new_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosActionUnknown>>(
                "unknown",
                |m: &EosTxActionAck| { &m.unknown },
                |m: &mut EosTxActionAck| { &mut m.unknown },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck>(
                "EosTxActionAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck {
    fn clear(&mut self) {
        self.common.clear();
        self.transfer.clear();
        self.delegate.clear();
        self.undelegate.clear();
        self.refund.clear();
        self.buy_ram.clear();
        self.buy_ram_bytes.clear();
        self.sell_ram.clear();
        self.vote_producer.clear();
        self.update_auth.clear();
        self.delete_auth.clear();
        self.link_auth.clear();
        self.unlink_auth.clear();
        self.new_account.clear();
        self.unknown.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosAsset {
    // message fields
    amount: ::std::option::Option<i64>,
    symbol: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosAsset {
    fn default() -> &'a EosTxActionAck_EosAsset {
        <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosAsset {
    pub fn new() -> EosTxActionAck_EosAsset {
        ::std::default::Default::default()
    }

    // optional sint64 amount = 1;


    pub fn get_amount(&self) -> i64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional uint64 symbol = 2;


    pub fn get_symbol(&self) -> u64 {
        self.symbol.unwrap_or(0)
    }
    pub fn clear_symbol(&mut self) {
        self.symbol = ::std::option::Option::None;
    }

    pub fn has_symbol(&self) -> bool {
        self.symbol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: u64) {
        self.symbol = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosAsset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.symbol = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        if let Some(v) = self.symbol {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_sint64(1, v)?;
        }
        if let Some(v) = self.symbol {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosAsset {
        EosTxActionAck_EosAsset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "amount",
                |m: &EosTxActionAck_EosAsset| { &m.amount },
                |m: &mut EosTxActionAck_EosAsset| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "symbol",
                |m: &EosTxActionAck_EosAsset| { &m.symbol },
                |m: &mut EosTxActionAck_EosAsset| { &mut m.symbol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosAsset>(
                "EosTxActionAck.EosAsset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosAsset {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosAsset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosAsset::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosAsset {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.symbol = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosAsset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosPermissionLevel {
    // message fields
    actor: ::std::option::Option<u64>,
    permission: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosPermissionLevel {
    fn default() -> &'a EosTxActionAck_EosPermissionLevel {
        <EosTxActionAck_EosPermissionLevel as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosPermissionLevel {
    pub fn new() -> EosTxActionAck_EosPermissionLevel {
        ::std::default::Default::default()
    }

    // optional uint64 actor = 1;


    pub fn get_actor(&self) -> u64 {
        self.actor.unwrap_or(0)
    }
    pub fn clear_actor(&mut self) {
        self.actor = ::std::option::Option::None;
    }

    pub fn has_actor(&self) -> bool {
        self.actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: u64) {
        self.actor = ::std::option::Option::Some(v);
    }

    // optional uint64 permission = 2;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosPermissionLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.actor = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.actor {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actor {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.permission {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosPermissionLevel {
        EosTxActionAck_EosPermissionLevel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "actor",
                |m: &EosTxActionAck_EosPermissionLevel| { &m.actor },
                |m: &mut EosTxActionAck_EosPermissionLevel| { &mut m.actor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "permission",
                |m: &EosTxActionAck_EosPermissionLevel| { &m.permission },
                |m: &mut EosTxActionAck_EosPermissionLevel| { &mut m.permission },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosPermissionLevel>(
                "EosTxActionAck.EosPermissionLevel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosPermissionLevel {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosPermissionLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosPermissionLevel::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosPermissionLevel {
    fn clear(&mut self) {
        self.actor = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosPermissionLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosPermissionLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosAuthorizationKey {
    // message fields
    field_type: ::std::option::Option<u32>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub address_n: ::std::vec::Vec<u32>,
    weight: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosAuthorizationKey {
    fn default() -> &'a EosTxActionAck_EosAuthorizationKey {
        <EosTxActionAck_EosAuthorizationKey as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosAuthorizationKey {
    pub fn new() -> EosTxActionAck_EosAuthorizationKey {
        ::std::default::Default::default()
    }

    // required uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated uint32 address_n = 3;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // required uint32 weight = 4;


    pub fn get_weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosAuthorizationKey {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.weight.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.address_n {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.weight {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosAuthorizationKey {
        EosTxActionAck_EosAuthorizationKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &EosTxActionAck_EosAuthorizationKey| { &m.field_type },
                |m: &mut EosTxActionAck_EosAuthorizationKey| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &EosTxActionAck_EosAuthorizationKey| { &m.key },
                |m: &mut EosTxActionAck_EosAuthorizationKey| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &EosTxActionAck_EosAuthorizationKey| { &m.address_n },
                |m: &mut EosTxActionAck_EosAuthorizationKey| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &EosTxActionAck_EosAuthorizationKey| { &m.weight },
                |m: &mut EosTxActionAck_EosAuthorizationKey| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosAuthorizationKey>(
                "EosTxActionAck.EosAuthorizationKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosAuthorizationKey {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosAuthorizationKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosAuthorizationKey::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosAuthorizationKey {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.key.clear();
        self.address_n.clear();
        self.weight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosAuthorizationKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosAuthorizationKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosAuthorizationAccount {
    // message fields
    pub account: ::protobuf::SingularPtrField<EosTxActionAck_EosPermissionLevel>,
    weight: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosAuthorizationAccount {
    fn default() -> &'a EosTxActionAck_EosAuthorizationAccount {
        <EosTxActionAck_EosAuthorizationAccount as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosAuthorizationAccount {
    pub fn new() -> EosTxActionAck_EosAuthorizationAccount {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel account = 1;


    pub fn get_account(&self) -> &EosTxActionAck_EosPermissionLevel {
        self.account.as_ref().unwrap_or_else(|| <EosTxActionAck_EosPermissionLevel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: EosTxActionAck_EosPermissionLevel) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut EosTxActionAck_EosPermissionLevel {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> EosTxActionAck_EosPermissionLevel {
        self.account.take().unwrap_or_else(|| EosTxActionAck_EosPermissionLevel::new())
    }

    // optional uint32 weight = 2;


    pub fn get_weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosAuthorizationAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.weight {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosAuthorizationAccount {
        EosTxActionAck_EosAuthorizationAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosPermissionLevel>>(
                "account",
                |m: &EosTxActionAck_EosAuthorizationAccount| { &m.account },
                |m: &mut EosTxActionAck_EosAuthorizationAccount| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &EosTxActionAck_EosAuthorizationAccount| { &m.weight },
                |m: &mut EosTxActionAck_EosAuthorizationAccount| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosAuthorizationAccount>(
                "EosTxActionAck.EosAuthorizationAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosAuthorizationAccount {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosAuthorizationAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosAuthorizationAccount::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosAuthorizationAccount {
    fn clear(&mut self) {
        self.account.clear();
        self.weight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosAuthorizationAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosAuthorizationAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosAuthorizationWait {
    // message fields
    wait_sec: ::std::option::Option<u32>,
    weight: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosAuthorizationWait {
    fn default() -> &'a EosTxActionAck_EosAuthorizationWait {
        <EosTxActionAck_EosAuthorizationWait as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosAuthorizationWait {
    pub fn new() -> EosTxActionAck_EosAuthorizationWait {
        ::std::default::Default::default()
    }

    // optional uint32 wait_sec = 1;


    pub fn get_wait_sec(&self) -> u32 {
        self.wait_sec.unwrap_or(0)
    }
    pub fn clear_wait_sec(&mut self) {
        self.wait_sec = ::std::option::Option::None;
    }

    pub fn has_wait_sec(&self) -> bool {
        self.wait_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_sec(&mut self, v: u32) {
        self.wait_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 weight = 2;


    pub fn get_weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosAuthorizationWait {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.wait_sec = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wait_sec {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wait_sec {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.weight {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosAuthorizationWait {
        EosTxActionAck_EosAuthorizationWait::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "wait_sec",
                |m: &EosTxActionAck_EosAuthorizationWait| { &m.wait_sec },
                |m: &mut EosTxActionAck_EosAuthorizationWait| { &mut m.wait_sec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &EosTxActionAck_EosAuthorizationWait| { &m.weight },
                |m: &mut EosTxActionAck_EosAuthorizationWait| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosAuthorizationWait>(
                "EosTxActionAck.EosAuthorizationWait",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosAuthorizationWait {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosAuthorizationWait> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosAuthorizationWait::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosAuthorizationWait {
    fn clear(&mut self) {
        self.wait_sec = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosAuthorizationWait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosAuthorizationWait {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosAuthorization {
    // message fields
    threshold: ::std::option::Option<u32>,
    pub keys: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationKey>,
    pub accounts: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationAccount>,
    pub waits: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationWait>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosAuthorization {
    fn default() -> &'a EosTxActionAck_EosAuthorization {
        <EosTxActionAck_EosAuthorization as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosAuthorization {
    pub fn new() -> EosTxActionAck_EosAuthorization {
        ::std::default::Default::default()
    }

    // optional uint32 threshold = 1;


    pub fn get_threshold(&self) -> u32 {
        self.threshold.unwrap_or(0)
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = ::std::option::Option::None;
    }

    pub fn has_threshold(&self) -> bool {
        self.threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: u32) {
        self.threshold = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationKey keys = 2;


    pub fn get_keys(&self) -> &[EosTxActionAck_EosAuthorizationKey] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationKey>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationKey> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationKey> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationAccount accounts = 3;


    pub fn get_accounts(&self) -> &[EosTxActionAck_EosAuthorizationAccount] {
        &self.accounts
    }
    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationAccount>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationAccount> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationAccount> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }

    // repeated .hw.trezor.messages.eos.EosTxActionAck.EosAuthorizationWait waits = 4;


    pub fn get_waits(&self) -> &[EosTxActionAck_EosAuthorizationWait] {
        &self.waits
    }
    pub fn clear_waits(&mut self) {
        self.waits.clear();
    }

    // Param is passed by value, moved
    pub fn set_waits(&mut self, v: ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationWait>) {
        self.waits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_waits(&mut self) -> &mut ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationWait> {
        &mut self.waits
    }

    // Take field
    pub fn take_waits(&mut self) -> ::protobuf::RepeatedField<EosTxActionAck_EosAuthorizationWait> {
        ::std::mem::replace(&mut self.waits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosAuthorization {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.waits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threshold = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accounts)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.waits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.threshold {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.waits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.threshold {
            os.write_uint32(1, v)?;
        }
        for v in &self.keys {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.accounts {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.waits {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosAuthorization {
        EosTxActionAck_EosAuthorization::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "threshold",
                |m: &EosTxActionAck_EosAuthorization| { &m.threshold },
                |m: &mut EosTxActionAck_EosAuthorization| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorizationKey>>(
                "keys",
                |m: &EosTxActionAck_EosAuthorization| { &m.keys },
                |m: &mut EosTxActionAck_EosAuthorization| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorizationAccount>>(
                "accounts",
                |m: &EosTxActionAck_EosAuthorization| { &m.accounts },
                |m: &mut EosTxActionAck_EosAuthorization| { &mut m.accounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorizationWait>>(
                "waits",
                |m: &EosTxActionAck_EosAuthorization| { &m.waits },
                |m: &mut EosTxActionAck_EosAuthorization| { &mut m.waits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosAuthorization>(
                "EosTxActionAck.EosAuthorization",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosAuthorization {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosAuthorization> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosAuthorization::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosAuthorization {
    fn clear(&mut self) {
        self.threshold = ::std::option::Option::None;
        self.keys.clear();
        self.accounts.clear();
        self.waits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosAuthorization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosAuthorization {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionCommon {
    // message fields
    account: ::std::option::Option<u64>,
    name: ::std::option::Option<u64>,
    pub authorization: ::protobuf::RepeatedField<EosTxActionAck_EosPermissionLevel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionCommon {
    fn default() -> &'a EosTxActionAck_EosActionCommon {
        <EosTxActionAck_EosActionCommon as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionCommon {
    pub fn new() -> EosTxActionAck_EosActionCommon {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 name = 2;


    pub fn get_name(&self) -> u64 {
        self.name.unwrap_or(0)
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: u64) {
        self.name = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevel authorization = 3;


    pub fn get_authorization(&self) -> &[EosTxActionAck_EosPermissionLevel] {
        &self.authorization
    }
    pub fn clear_authorization(&mut self) {
        self.authorization.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorization(&mut self, v: ::protobuf::RepeatedField<EosTxActionAck_EosPermissionLevel>) {
        self.authorization = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorization(&mut self) -> &mut ::protobuf::RepeatedField<EosTxActionAck_EosPermissionLevel> {
        &mut self.authorization
    }

    // Take field
    pub fn take_authorization(&mut self) -> ::protobuf::RepeatedField<EosTxActionAck_EosPermissionLevel> {
        ::std::mem::replace(&mut self.authorization, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionCommon {
    fn is_initialized(&self) -> bool {
        for v in &self.authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.name = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.authorization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.authorization {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name {
            os.write_uint64(2, v)?;
        }
        for v in &self.authorization {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionCommon {
        EosTxActionAck_EosActionCommon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionCommon| { &m.account },
                |m: &mut EosTxActionAck_EosActionCommon| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "name",
                |m: &EosTxActionAck_EosActionCommon| { &m.name },
                |m: &mut EosTxActionAck_EosActionCommon| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosPermissionLevel>>(
                "authorization",
                |m: &EosTxActionAck_EosActionCommon| { &m.authorization },
                |m: &mut EosTxActionAck_EosActionCommon| { &mut m.authorization },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionCommon>(
                "EosTxActionAck.EosActionCommon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionCommon {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionCommon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionCommon::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionCommon {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.authorization.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionCommon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionTransfer {
    // message fields
    sender: ::std::option::Option<u64>,
    receiver: ::std::option::Option<u64>,
    pub quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    memo: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionTransfer {
    fn default() -> &'a EosTxActionAck_EosActionTransfer {
        <EosTxActionAck_EosActionTransfer as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionTransfer {
    pub fn new() -> EosTxActionAck_EosActionTransfer {
        ::std::default::Default::default()
    }

    // optional uint64 sender = 1;


    pub fn get_sender(&self) -> u64 {
        self.sender.unwrap_or(0)
    }
    pub fn clear_sender(&mut self) {
        self.sender = ::std::option::Option::None;
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: u64) {
        self.sender = ::std::option::Option::Some(v);
    }

    // optional uint64 receiver = 2;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;


    pub fn get_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.quantity.is_none() {
            self.quantity.set_default();
        }
        self.quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }

    // optional string memo = 4;


    pub fn get_memo(&self) -> &str {
        match self.memo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    pub fn has_memo(&self) -> bool {
        self.memo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::string::String) {
        self.memo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::string::String {
        if self.memo.is_none() {
            self.memo.set_default();
        }
        self.memo.as_mut().unwrap()
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::string::String {
        self.memo.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sender = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quantity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.memo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.memo.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.quantity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.memo.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionTransfer {
        EosTxActionAck_EosActionTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sender",
                |m: &EosTxActionAck_EosActionTransfer| { &m.sender },
                |m: &mut EosTxActionAck_EosActionTransfer| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiver",
                |m: &EosTxActionAck_EosActionTransfer| { &m.receiver },
                |m: &mut EosTxActionAck_EosActionTransfer| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "quantity",
                |m: &EosTxActionAck_EosActionTransfer| { &m.quantity },
                |m: &mut EosTxActionAck_EosActionTransfer| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "memo",
                |m: &EosTxActionAck_EosActionTransfer| { &m.memo },
                |m: &mut EosTxActionAck_EosActionTransfer| { &mut m.memo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionTransfer>(
                "EosTxActionAck.EosActionTransfer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionTransfer {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionTransfer::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionTransfer {
    fn clear(&mut self) {
        self.sender = ::std::option::Option::None;
        self.receiver = ::std::option::Option::None;
        self.quantity.clear();
        self.memo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionDelegate {
    // message fields
    sender: ::std::option::Option<u64>,
    receiver: ::std::option::Option<u64>,
    pub net_quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    pub cpu_quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    transfer: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionDelegate {
    fn default() -> &'a EosTxActionAck_EosActionDelegate {
        <EosTxActionAck_EosActionDelegate as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionDelegate {
    pub fn new() -> EosTxActionAck_EosActionDelegate {
        ::std::default::Default::default()
    }

    // optional uint64 sender = 1;


    pub fn get_sender(&self) -> u64 {
        self.sender.unwrap_or(0)
    }
    pub fn clear_sender(&mut self) {
        self.sender = ::std::option::Option::None;
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: u64) {
        self.sender = ::std::option::Option::Some(v);
    }

    // optional uint64 receiver = 2;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;


    pub fn get_net_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.net_quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_net_quantity(&mut self) {
        self.net_quantity.clear();
    }

    pub fn has_net_quantity(&self) -> bool {
        self.net_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.net_quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.net_quantity.is_none() {
            self.net_quantity.set_default();
        }
        self.net_quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.net_quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;


    pub fn get_cpu_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.cpu_quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cpu_quantity(&mut self) {
        self.cpu_quantity.clear();
    }

    pub fn has_cpu_quantity(&self) -> bool {
        self.cpu_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.cpu_quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.cpu_quantity.is_none() {
            self.cpu_quantity.set_default();
        }
        self.cpu_quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.cpu_quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }

    // optional bool transfer = 5;


    pub fn get_transfer(&self) -> bool {
        self.transfer.unwrap_or(false)
    }
    pub fn clear_transfer(&mut self) {
        self.transfer = ::std::option::Option::None;
    }

    pub fn has_transfer(&self) -> bool {
        self.transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer(&mut self, v: bool) {
        self.transfer = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionDelegate {
    fn is_initialized(&self) -> bool {
        for v in &self.net_quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpu_quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sender = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_quantity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_quantity)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.transfer = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.net_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpu_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.transfer {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.net_quantity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpu_quantity.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.transfer {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionDelegate {
        EosTxActionAck_EosActionDelegate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sender",
                |m: &EosTxActionAck_EosActionDelegate| { &m.sender },
                |m: &mut EosTxActionAck_EosActionDelegate| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiver",
                |m: &EosTxActionAck_EosActionDelegate| { &m.receiver },
                |m: &mut EosTxActionAck_EosActionDelegate| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "net_quantity",
                |m: &EosTxActionAck_EosActionDelegate| { &m.net_quantity },
                |m: &mut EosTxActionAck_EosActionDelegate| { &mut m.net_quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "cpu_quantity",
                |m: &EosTxActionAck_EosActionDelegate| { &m.cpu_quantity },
                |m: &mut EosTxActionAck_EosActionDelegate| { &mut m.cpu_quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "transfer",
                |m: &EosTxActionAck_EosActionDelegate| { &m.transfer },
                |m: &mut EosTxActionAck_EosActionDelegate| { &mut m.transfer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionDelegate>(
                "EosTxActionAck.EosActionDelegate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionDelegate {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionDelegate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionDelegate::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionDelegate {
    fn clear(&mut self) {
        self.sender = ::std::option::Option::None;
        self.receiver = ::std::option::Option::None;
        self.net_quantity.clear();
        self.cpu_quantity.clear();
        self.transfer = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionDelegate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionDelegate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionUndelegate {
    // message fields
    sender: ::std::option::Option<u64>,
    receiver: ::std::option::Option<u64>,
    pub net_quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    pub cpu_quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionUndelegate {
    fn default() -> &'a EosTxActionAck_EosActionUndelegate {
        <EosTxActionAck_EosActionUndelegate as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionUndelegate {
    pub fn new() -> EosTxActionAck_EosActionUndelegate {
        ::std::default::Default::default()
    }

    // optional uint64 sender = 1;


    pub fn get_sender(&self) -> u64 {
        self.sender.unwrap_or(0)
    }
    pub fn clear_sender(&mut self) {
        self.sender = ::std::option::Option::None;
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: u64) {
        self.sender = ::std::option::Option::Some(v);
    }

    // optional uint64 receiver = 2;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset net_quantity = 3;


    pub fn get_net_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.net_quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_net_quantity(&mut self) {
        self.net_quantity.clear();
    }

    pub fn has_net_quantity(&self) -> bool {
        self.net_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.net_quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.net_quantity.is_none() {
            self.net_quantity.set_default();
        }
        self.net_quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.net_quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset cpu_quantity = 4;


    pub fn get_cpu_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.cpu_quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cpu_quantity(&mut self) {
        self.cpu_quantity.clear();
    }

    pub fn has_cpu_quantity(&self) -> bool {
        self.cpu_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.cpu_quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.cpu_quantity.is_none() {
            self.cpu_quantity.set_default();
        }
        self.cpu_quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.cpu_quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionUndelegate {
    fn is_initialized(&self) -> bool {
        for v in &self.net_quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cpu_quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.sender = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_quantity)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cpu_quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sender {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.net_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cpu_quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sender {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.net_quantity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cpu_quantity.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionUndelegate {
        EosTxActionAck_EosActionUndelegate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "sender",
                |m: &EosTxActionAck_EosActionUndelegate| { &m.sender },
                |m: &mut EosTxActionAck_EosActionUndelegate| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiver",
                |m: &EosTxActionAck_EosActionUndelegate| { &m.receiver },
                |m: &mut EosTxActionAck_EosActionUndelegate| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "net_quantity",
                |m: &EosTxActionAck_EosActionUndelegate| { &m.net_quantity },
                |m: &mut EosTxActionAck_EosActionUndelegate| { &mut m.net_quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "cpu_quantity",
                |m: &EosTxActionAck_EosActionUndelegate| { &m.cpu_quantity },
                |m: &mut EosTxActionAck_EosActionUndelegate| { &mut m.cpu_quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionUndelegate>(
                "EosTxActionAck.EosActionUndelegate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionUndelegate {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionUndelegate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionUndelegate::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionUndelegate {
    fn clear(&mut self) {
        self.sender = ::std::option::Option::None;
        self.receiver = ::std::option::Option::None;
        self.net_quantity.clear();
        self.cpu_quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionUndelegate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionUndelegate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionRefund {
    // message fields
    owner: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionRefund {
    fn default() -> &'a EosTxActionAck_EosActionRefund {
        <EosTxActionAck_EosActionRefund as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionRefund {
    pub fn new() -> EosTxActionAck_EosActionRefund {
        ::std::default::Default::default()
    }

    // optional uint64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionRefund {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionRefund {
        EosTxActionAck_EosActionRefund::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "owner",
                |m: &EosTxActionAck_EosActionRefund| { &m.owner },
                |m: &mut EosTxActionAck_EosActionRefund| { &mut m.owner },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionRefund>(
                "EosTxActionAck.EosActionRefund",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionRefund {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionRefund> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionRefund::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionRefund {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionRefund {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionRefund {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionBuyRam {
    // message fields
    payer: ::std::option::Option<u64>,
    receiver: ::std::option::Option<u64>,
    pub quantity: ::protobuf::SingularPtrField<EosTxActionAck_EosAsset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionBuyRam {
    fn default() -> &'a EosTxActionAck_EosActionBuyRam {
        <EosTxActionAck_EosActionBuyRam as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionBuyRam {
    pub fn new() -> EosTxActionAck_EosActionBuyRam {
        ::std::default::Default::default()
    }

    // optional uint64 payer = 1;


    pub fn get_payer(&self) -> u64 {
        self.payer.unwrap_or(0)
    }
    pub fn clear_payer(&mut self) {
        self.payer = ::std::option::Option::None;
    }

    pub fn has_payer(&self) -> bool {
        self.payer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payer(&mut self, v: u64) {
        self.payer = ::std::option::Option::Some(v);
    }

    // optional uint64 receiver = 2;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAsset quantity = 3;


    pub fn get_quantity(&self) -> &EosTxActionAck_EosAsset {
        self.quantity.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAsset as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quantity(&mut self) {
        self.quantity.clear();
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: EosTxActionAck_EosAsset) {
        self.quantity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quantity(&mut self) -> &mut EosTxActionAck_EosAsset {
        if self.quantity.is_none() {
            self.quantity.set_default();
        }
        self.quantity.as_mut().unwrap()
    }

    // Take field
    pub fn take_quantity(&mut self) -> EosTxActionAck_EosAsset {
        self.quantity.take().unwrap_or_else(|| EosTxActionAck_EosAsset::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionBuyRam {
    fn is_initialized(&self) -> bool {
        for v in &self.quantity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.payer = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quantity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.payer {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quantity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.payer {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.quantity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionBuyRam {
        EosTxActionAck_EosActionBuyRam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "payer",
                |m: &EosTxActionAck_EosActionBuyRam| { &m.payer },
                |m: &mut EosTxActionAck_EosActionBuyRam| { &mut m.payer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiver",
                |m: &EosTxActionAck_EosActionBuyRam| { &m.receiver },
                |m: &mut EosTxActionAck_EosActionBuyRam| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAsset>>(
                "quantity",
                |m: &EosTxActionAck_EosActionBuyRam| { &m.quantity },
                |m: &mut EosTxActionAck_EosActionBuyRam| { &mut m.quantity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionBuyRam>(
                "EosTxActionAck.EosActionBuyRam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionBuyRam {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionBuyRam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionBuyRam::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionBuyRam {
    fn clear(&mut self) {
        self.payer = ::std::option::Option::None;
        self.receiver = ::std::option::Option::None;
        self.quantity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionBuyRam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionBuyRam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionBuyRamBytes {
    // message fields
    payer: ::std::option::Option<u64>,
    receiver: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionBuyRamBytes {
    fn default() -> &'a EosTxActionAck_EosActionBuyRamBytes {
        <EosTxActionAck_EosActionBuyRamBytes as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionBuyRamBytes {
    pub fn new() -> EosTxActionAck_EosActionBuyRamBytes {
        ::std::default::Default::default()
    }

    // optional uint64 payer = 1;


    pub fn get_payer(&self) -> u64 {
        self.payer.unwrap_or(0)
    }
    pub fn clear_payer(&mut self) {
        self.payer = ::std::option::Option::None;
    }

    pub fn has_payer(&self) -> bool {
        self.payer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payer(&mut self, v: u64) {
        self.payer = ::std::option::Option::Some(v);
    }

    // optional uint64 receiver = 2;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional uint32 bytes = 3;


    pub fn get_bytes(&self) -> u32 {
        self.bytes.unwrap_or(0)
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u32) {
        self.bytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionBuyRamBytes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.payer = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.payer {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.receiver {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.payer {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.receiver {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.bytes {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionBuyRamBytes {
        EosTxActionAck_EosActionBuyRamBytes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "payer",
                |m: &EosTxActionAck_EosActionBuyRamBytes| { &m.payer },
                |m: &mut EosTxActionAck_EosActionBuyRamBytes| { &mut m.payer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "receiver",
                |m: &EosTxActionAck_EosActionBuyRamBytes| { &m.receiver },
                |m: &mut EosTxActionAck_EosActionBuyRamBytes| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bytes",
                |m: &EosTxActionAck_EosActionBuyRamBytes| { &m.bytes },
                |m: &mut EosTxActionAck_EosActionBuyRamBytes| { &mut m.bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionBuyRamBytes>(
                "EosTxActionAck.EosActionBuyRamBytes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionBuyRamBytes {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionBuyRamBytes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionBuyRamBytes::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionBuyRamBytes {
    fn clear(&mut self) {
        self.payer = ::std::option::Option::None;
        self.receiver = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionBuyRamBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionBuyRamBytes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionSellRam {
    // message fields
    account: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionSellRam {
    fn default() -> &'a EosTxActionAck_EosActionSellRam {
        <EosTxActionAck_EosActionSellRam as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionSellRam {
    pub fn new() -> EosTxActionAck_EosActionSellRam {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 bytes = 2;


    pub fn get_bytes(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionSellRam {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bytes {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionSellRam {
        EosTxActionAck_EosActionSellRam::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionSellRam| { &m.account },
                |m: &mut EosTxActionAck_EosActionSellRam| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "bytes",
                |m: &EosTxActionAck_EosActionSellRam| { &m.bytes },
                |m: &mut EosTxActionAck_EosActionSellRam| { &mut m.bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionSellRam>(
                "EosTxActionAck.EosActionSellRam",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionSellRam {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionSellRam> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionSellRam::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionSellRam {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.bytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionSellRam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionSellRam {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionVoteProducer {
    // message fields
    voter: ::std::option::Option<u64>,
    proxy: ::std::option::Option<u64>,
    pub producers: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionVoteProducer {
    fn default() -> &'a EosTxActionAck_EosActionVoteProducer {
        <EosTxActionAck_EosActionVoteProducer as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionVoteProducer {
    pub fn new() -> EosTxActionAck_EosActionVoteProducer {
        ::std::default::Default::default()
    }

    // optional uint64 voter = 1;


    pub fn get_voter(&self) -> u64 {
        self.voter.unwrap_or(0)
    }
    pub fn clear_voter(&mut self) {
        self.voter = ::std::option::Option::None;
    }

    pub fn has_voter(&self) -> bool {
        self.voter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter(&mut self, v: u64) {
        self.voter = ::std::option::Option::Some(v);
    }

    // optional uint64 proxy = 2;


    pub fn get_proxy(&self) -> u64 {
        self.proxy.unwrap_or(0)
    }
    pub fn clear_proxy(&mut self) {
        self.proxy = ::std::option::Option::None;
    }

    pub fn has_proxy(&self) -> bool {
        self.proxy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxy(&mut self, v: u64) {
        self.proxy = ::std::option::Option::Some(v);
    }

    // repeated uint64 producers = 3;


    pub fn get_producers(&self) -> &[u64] {
        &self.producers
    }
    pub fn clear_producers(&mut self) {
        self.producers.clear();
    }

    // Param is passed by value, moved
    pub fn set_producers(&mut self, v: ::std::vec::Vec<u64>) {
        self.producers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_producers(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.producers
    }

    // Take field
    pub fn take_producers(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.producers, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionVoteProducer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.voter = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.proxy = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.producers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.voter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.proxy {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.producers {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.voter {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.proxy {
            os.write_uint64(2, v)?;
        }
        for v in &self.producers {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionVoteProducer {
        EosTxActionAck_EosActionVoteProducer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "voter",
                |m: &EosTxActionAck_EosActionVoteProducer| { &m.voter },
                |m: &mut EosTxActionAck_EosActionVoteProducer| { &mut m.voter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "proxy",
                |m: &EosTxActionAck_EosActionVoteProducer| { &m.proxy },
                |m: &mut EosTxActionAck_EosActionVoteProducer| { &mut m.proxy },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "producers",
                |m: &EosTxActionAck_EosActionVoteProducer| { &m.producers },
                |m: &mut EosTxActionAck_EosActionVoteProducer| { &mut m.producers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionVoteProducer>(
                "EosTxActionAck.EosActionVoteProducer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionVoteProducer {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionVoteProducer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionVoteProducer::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionVoteProducer {
    fn clear(&mut self) {
        self.voter = ::std::option::Option::None;
        self.proxy = ::std::option::Option::None;
        self.producers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionVoteProducer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionVoteProducer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionUpdateAuth {
    // message fields
    account: ::std::option::Option<u64>,
    permission: ::std::option::Option<u64>,
    parent: ::std::option::Option<u64>,
    pub auth: ::protobuf::SingularPtrField<EosTxActionAck_EosAuthorization>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionUpdateAuth {
    fn default() -> &'a EosTxActionAck_EosActionUpdateAuth {
        <EosTxActionAck_EosActionUpdateAuth as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionUpdateAuth {
    pub fn new() -> EosTxActionAck_EosActionUpdateAuth {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 permission = 2;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }

    // optional uint64 parent = 3;


    pub fn get_parent(&self) -> u64 {
        self.parent.unwrap_or(0)
    }
    pub fn clear_parent(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: u64) {
        self.parent = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization auth = 4;


    pub fn get_auth(&self) -> &EosTxActionAck_EosAuthorization {
        self.auth.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAuthorization as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    pub fn has_auth(&self) -> bool {
        self.auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: EosTxActionAck_EosAuthorization) {
        self.auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut EosTxActionAck_EosAuthorization {
        if self.auth.is_none() {
            self.auth.set_default();
        }
        self.auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth(&mut self) -> EosTxActionAck_EosAuthorization {
        self.auth.take().unwrap_or_else(|| EosTxActionAck_EosAuthorization::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionUpdateAuth {
    fn is_initialized(&self) -> bool {
        for v in &self.auth {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parent = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parent {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.permission {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.parent {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.auth.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionUpdateAuth {
        EosTxActionAck_EosActionUpdateAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionUpdateAuth| { &m.account },
                |m: &mut EosTxActionAck_EosActionUpdateAuth| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "permission",
                |m: &EosTxActionAck_EosActionUpdateAuth| { &m.permission },
                |m: &mut EosTxActionAck_EosActionUpdateAuth| { &mut m.permission },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "parent",
                |m: &EosTxActionAck_EosActionUpdateAuth| { &m.parent },
                |m: &mut EosTxActionAck_EosActionUpdateAuth| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorization>>(
                "auth",
                |m: &EosTxActionAck_EosActionUpdateAuth| { &m.auth },
                |m: &mut EosTxActionAck_EosActionUpdateAuth| { &mut m.auth },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionUpdateAuth>(
                "EosTxActionAck.EosActionUpdateAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionUpdateAuth {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionUpdateAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionUpdateAuth::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionUpdateAuth {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.auth.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionUpdateAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionUpdateAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionDeleteAuth {
    // message fields
    account: ::std::option::Option<u64>,
    permission: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionDeleteAuth {
    fn default() -> &'a EosTxActionAck_EosActionDeleteAuth {
        <EosTxActionAck_EosActionDeleteAuth as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionDeleteAuth {
    pub fn new() -> EosTxActionAck_EosActionDeleteAuth {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 permission = 2;


    pub fn get_permission(&self) -> u64 {
        self.permission.unwrap_or(0)
    }
    pub fn clear_permission(&mut self) {
        self.permission = ::std::option::Option::None;
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: u64) {
        self.permission = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionDeleteAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.permission = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.permission {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.permission {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionDeleteAuth {
        EosTxActionAck_EosActionDeleteAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionDeleteAuth| { &m.account },
                |m: &mut EosTxActionAck_EosActionDeleteAuth| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "permission",
                |m: &EosTxActionAck_EosActionDeleteAuth| { &m.permission },
                |m: &mut EosTxActionAck_EosActionDeleteAuth| { &mut m.permission },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionDeleteAuth>(
                "EosTxActionAck.EosActionDeleteAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionDeleteAuth {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionDeleteAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionDeleteAuth::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionDeleteAuth {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.permission = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionDeleteAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionDeleteAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionLinkAuth {
    // message fields
    account: ::std::option::Option<u64>,
    code: ::std::option::Option<u64>,
    field_type: ::std::option::Option<u64>,
    requirement: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionLinkAuth {
    fn default() -> &'a EosTxActionAck_EosActionLinkAuth {
        <EosTxActionAck_EosActionLinkAuth as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionLinkAuth {
    pub fn new() -> EosTxActionAck_EosActionLinkAuth {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 code = 2;


    pub fn get_code(&self) -> u64 {
        self.code.unwrap_or(0)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u64) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional uint64 type = 3;


    pub fn get_field_type(&self) -> u64 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u64) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint64 requirement = 4;


    pub fn get_requirement(&self) -> u64 {
        self.requirement.unwrap_or(0)
    }
    pub fn clear_requirement(&mut self) {
        self.requirement = ::std::option::Option::None;
    }

    pub fn has_requirement(&self) -> bool {
        self.requirement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requirement(&mut self, v: u64) {
        self.requirement = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionLinkAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.requirement = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.requirement {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.code {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.requirement {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionLinkAuth {
        EosTxActionAck_EosActionLinkAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionLinkAuth| { &m.account },
                |m: &mut EosTxActionAck_EosActionLinkAuth| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "code",
                |m: &EosTxActionAck_EosActionLinkAuth| { &m.code },
                |m: &mut EosTxActionAck_EosActionLinkAuth| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "type",
                |m: &EosTxActionAck_EosActionLinkAuth| { &m.field_type },
                |m: &mut EosTxActionAck_EosActionLinkAuth| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "requirement",
                |m: &EosTxActionAck_EosActionLinkAuth| { &m.requirement },
                |m: &mut EosTxActionAck_EosActionLinkAuth| { &mut m.requirement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionLinkAuth>(
                "EosTxActionAck.EosActionLinkAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionLinkAuth {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionLinkAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionLinkAuth::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionLinkAuth {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.requirement = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionLinkAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionLinkAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionUnlinkAuth {
    // message fields
    account: ::std::option::Option<u64>,
    code: ::std::option::Option<u64>,
    field_type: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionUnlinkAuth {
    fn default() -> &'a EosTxActionAck_EosActionUnlinkAuth {
        <EosTxActionAck_EosActionUnlinkAuth as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionUnlinkAuth {
    pub fn new() -> EosTxActionAck_EosActionUnlinkAuth {
        ::std::default::Default::default()
    }

    // optional uint64 account = 1;


    pub fn get_account(&self) -> u64 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u64) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint64 code = 2;


    pub fn get_code(&self) -> u64 {
        self.code.unwrap_or(0)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u64) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional uint64 type = 3;


    pub fn get_field_type(&self) -> u64 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u64) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionUnlinkAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.code {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionUnlinkAuth {
        EosTxActionAck_EosActionUnlinkAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "account",
                |m: &EosTxActionAck_EosActionUnlinkAuth| { &m.account },
                |m: &mut EosTxActionAck_EosActionUnlinkAuth| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "code",
                |m: &EosTxActionAck_EosActionUnlinkAuth| { &m.code },
                |m: &mut EosTxActionAck_EosActionUnlinkAuth| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "type",
                |m: &EosTxActionAck_EosActionUnlinkAuth| { &m.field_type },
                |m: &mut EosTxActionAck_EosActionUnlinkAuth| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionUnlinkAuth>(
                "EosTxActionAck.EosActionUnlinkAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionUnlinkAuth {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionUnlinkAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionUnlinkAuth::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionUnlinkAuth {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionUnlinkAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionUnlinkAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionNewAccount {
    // message fields
    creator: ::std::option::Option<u64>,
    name: ::std::option::Option<u64>,
    pub owner: ::protobuf::SingularPtrField<EosTxActionAck_EosAuthorization>,
    pub active: ::protobuf::SingularPtrField<EosTxActionAck_EosAuthorization>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionNewAccount {
    fn default() -> &'a EosTxActionAck_EosActionNewAccount {
        <EosTxActionAck_EosActionNewAccount as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionNewAccount {
    pub fn new() -> EosTxActionAck_EosActionNewAccount {
        ::std::default::Default::default()
    }

    // optional uint64 creator = 1;


    pub fn get_creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }
    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }

    // optional uint64 name = 2;


    pub fn get_name(&self) -> u64 {
        self.name.unwrap_or(0)
    }
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: u64) {
        self.name = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization owner = 3;


    pub fn get_owner(&self) -> &EosTxActionAck_EosAuthorization {
        self.owner.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAuthorization as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: EosTxActionAck_EosAuthorization) {
        self.owner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut EosTxActionAck_EosAuthorization {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> EosTxActionAck_EosAuthorization {
        self.owner.take().unwrap_or_else(|| EosTxActionAck_EosAuthorization::new())
    }

    // optional .hw.trezor.messages.eos.EosTxActionAck.EosAuthorization active = 4;


    pub fn get_active(&self) -> &EosTxActionAck_EosAuthorization {
        self.active.as_ref().unwrap_or_else(|| <EosTxActionAck_EosAuthorization as ::protobuf::Message>::default_instance())
    }
    pub fn clear_active(&mut self) {
        self.active.clear();
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: EosTxActionAck_EosAuthorization) {
        self.active = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active(&mut self) -> &mut EosTxActionAck_EosAuthorization {
        if self.active.is_none() {
            self.active.set_default();
        }
        self.active.as_mut().unwrap()
    }

    // Take field
    pub fn take_active(&mut self) -> EosTxActionAck_EosAuthorization {
        self.active.take().unwrap_or_else(|| EosTxActionAck_EosAuthorization::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionNewAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.owner {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.creator = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.name = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.creator {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.name {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.owner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.active.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.creator {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.active.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionNewAccount {
        EosTxActionAck_EosActionNewAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "creator",
                |m: &EosTxActionAck_EosActionNewAccount| { &m.creator },
                |m: &mut EosTxActionAck_EosActionNewAccount| { &mut m.creator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "name",
                |m: &EosTxActionAck_EosActionNewAccount| { &m.name },
                |m: &mut EosTxActionAck_EosActionNewAccount| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorization>>(
                "owner",
                |m: &EosTxActionAck_EosActionNewAccount| { &m.owner },
                |m: &mut EosTxActionAck_EosActionNewAccount| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EosTxActionAck_EosAuthorization>>(
                "active",
                |m: &EosTxActionAck_EosActionNewAccount| { &m.active },
                |m: &mut EosTxActionAck_EosActionNewAccount| { &mut m.active },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionNewAccount>(
                "EosTxActionAck.EosActionNewAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionNewAccount {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionNewAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionNewAccount::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionNewAccount {
    fn clear(&mut self) {
        self.creator = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.owner.clear();
        self.active.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionNewAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionNewAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosTxActionAck_EosActionUnknown {
    // message fields
    data_size: ::std::option::Option<u32>,
    data_chunk: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosTxActionAck_EosActionUnknown {
    fn default() -> &'a EosTxActionAck_EosActionUnknown {
        <EosTxActionAck_EosActionUnknown as ::protobuf::Message>::default_instance()
    }
}

impl EosTxActionAck_EosActionUnknown {
    pub fn new() -> EosTxActionAck_EosActionUnknown {
        ::std::default::Default::default()
    }

    // required uint32 data_size = 1;


    pub fn get_data_size(&self) -> u32 {
        self.data_size.unwrap_or(0)
    }
    pub fn clear_data_size(&mut self) {
        self.data_size = ::std::option::Option::None;
    }

    pub fn has_data_size(&self) -> bool {
        self.data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_size(&mut self, v: u32) {
        self.data_size = ::std::option::Option::Some(v);
    }

    // optional bytes data_chunk = 2;


    pub fn get_data_chunk(&self) -> &[u8] {
        match self.data_chunk.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data_chunk(&mut self) {
        self.data_chunk.clear();
    }

    pub fn has_data_chunk(&self) -> bool {
        self.data_chunk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_chunk(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_chunk = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_chunk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data_chunk.is_none() {
            self.data_chunk.set_default();
        }
        self.data_chunk.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_chunk(&mut self) -> ::std::vec::Vec<u8> {
        self.data_chunk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EosTxActionAck_EosActionUnknown {
    fn is_initialized(&self) -> bool {
        if self.data_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_size = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data_chunk)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.data_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.data_chunk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.data_size {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.data_chunk.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosTxActionAck_EosActionUnknown {
        EosTxActionAck_EosActionUnknown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_size",
                |m: &EosTxActionAck_EosActionUnknown| { &m.data_size },
                |m: &mut EosTxActionAck_EosActionUnknown| { &mut m.data_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data_chunk",
                |m: &EosTxActionAck_EosActionUnknown| { &m.data_chunk },
                |m: &mut EosTxActionAck_EosActionUnknown| { &mut m.data_chunk },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosTxActionAck_EosActionUnknown>(
                "EosTxActionAck.EosActionUnknown",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosTxActionAck_EosActionUnknown {
        static instance: ::protobuf::rt::LazyV2<EosTxActionAck_EosActionUnknown> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosTxActionAck_EosActionUnknown::new)
    }
}

impl ::protobuf::Clear for EosTxActionAck_EosActionUnknown {
    fn clear(&mut self) {
        self.data_size = ::std::option::Option::None;
        self.data_chunk.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosTxActionAck_EosActionUnknown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosTxActionAck_EosActionUnknown {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EosSignedTx {
    // message fields
    signature: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EosSignedTx {
    fn default() -> &'a EosSignedTx {
        <EosSignedTx as ::protobuf::Message>::default_instance()
    }
}

impl EosSignedTx {
    pub fn new() -> EosSignedTx {
        ::std::default::Default::default()
    }

    // required string signature = 1;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        self.signature.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EosSignedTx {
    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EosSignedTx {
        EosSignedTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signature",
                |m: &EosSignedTx| { &m.signature },
                |m: &mut EosSignedTx| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EosSignedTx>(
                "EosSignedTx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EosSignedTx {
        static instance: ::protobuf::rt::LazyV2<EosSignedTx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EosSignedTx::new)
    }
}

impl ::protobuf::Clear for EosSignedTx {
    fn clear(&mut self) {
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EosSignedTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EosSignedTx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12messages-eos.proto\x12\x16hw.trezor.messages.eos\"Q\n\x0fEosGetPub\
    licKey\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0csh\
    ow_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\"Z\n\x0cEosPublicKey\x12\
    $\n\x0ewif_public_key\x18\x01\x20\x02(\tR\x0cwifPublicKey\x12$\n\x0eraw_\
    public_key\x18\x02\x20\x02(\x0cR\x0crawPublicKey\"\x9e\x03\n\tEosSignTx\
    \x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x19\n\x08chain\
    _id\x18\x02\x20\x01(\x0cR\x07chainId\x12E\n\x06header\x18\x03\x20\x01(\
    \x0b2-.hw.trezor.messages.eos.EosSignTx.EosTxHeaderR\x06header\x12\x1f\n\
    \x0bnum_actions\x18\x04\x20\x01(\rR\nnumActions\x1a\xf0\x01\n\x0bEosTxHe\
    ader\x12\x1e\n\nexpiration\x18\x01\x20\x02(\rR\nexpiration\x12\"\n\rref_\
    block_num\x18\x02\x20\x02(\rR\x0brefBlockNum\x12(\n\x10ref_block_prefix\
    \x18\x03\x20\x02(\rR\x0erefBlockPrefix\x12-\n\x13max_net_usage_words\x18\
    \x04\x20\x02(\rR\x10maxNetUsageWords\x12'\n\x10max_cpu_usage_ms\x18\x05\
    \x20\x02(\rR\rmaxCpuUsageMs\x12\x1b\n\tdelay_sec\x18\x06\x20\x02(\rR\x08\
    delaySec\"1\n\x12EosTxActionRequest\x12\x1b\n\tdata_size\x18\x01\x20\x01\
    (\rR\x08dataSize\"\xe2\x20\n\x0eEosTxActionAck\x12N\n\x06common\x18\x01\
    \x20\x01(\x0b26.hw.trezor.messages.eos.EosTxActionAck.EosActionCommonR\
    \x06common\x12T\n\x08transfer\x18\x02\x20\x01(\x0b28.hw.trezor.messages.\
    eos.EosTxActionAck.EosActionTransferR\x08transfer\x12T\n\x08delegate\x18\
    \x03\x20\x01(\x0b28.hw.trezor.messages.eos.EosTxActionAck.EosActionDeleg\
    ateR\x08delegate\x12Z\n\nundelegate\x18\x04\x20\x01(\x0b2:.hw.trezor.mes\
    sages.eos.EosTxActionAck.EosActionUndelegateR\nundelegate\x12N\n\x06refu\
    nd\x18\x05\x20\x01(\x0b26.hw.trezor.messages.eos.EosTxActionAck.EosActio\
    nRefundR\x06refund\x12O\n\x07buy_ram\x18\x06\x20\x01(\x0b26.hw.trezor.me\
    ssages.eos.EosTxActionAck.EosActionBuyRamR\x06buyRam\x12_\n\rbuy_ram_byt\
    es\x18\x07\x20\x01(\x0b2;.hw.trezor.messages.eos.EosTxActionAck.EosActio\
    nBuyRamBytesR\x0bbuyRamBytes\x12R\n\x08sell_ram\x18\x08\x20\x01(\x0b27.h\
    w.trezor.messages.eos.EosTxActionAck.EosActionSellRamR\x07sellRam\x12a\n\
    \rvote_producer\x18\t\x20\x01(\x0b2<.hw.trezor.messages.eos.EosTxActionA\
    ck.EosActionVoteProducerR\x0cvoteProducer\x12[\n\x0bupdate_auth\x18\n\
    \x20\x01(\x0b2:.hw.trezor.messages.eos.EosTxActionAck.EosActionUpdateAut\
    hR\nupdateAuth\x12[\n\x0bdelete_auth\x18\x0b\x20\x01(\x0b2:.hw.trezor.me\
    ssages.eos.EosTxActionAck.EosActionDeleteAuthR\ndeleteAuth\x12U\n\tlink_\
    auth\x18\x0c\x20\x01(\x0b28.hw.trezor.messages.eos.EosTxActionAck.EosAct\
    ionLinkAuthR\x08linkAuth\x12[\n\x0bunlink_auth\x18\r\x20\x01(\x0b2:.hw.t\
    rezor.messages.eos.EosTxActionAck.EosActionUnlinkAuthR\nunlinkAuth\x12[\
    \n\x0bnew_account\x18\x0e\x20\x01(\x0b2:.hw.trezor.messages.eos.EosTxAct\
    ionAck.EosActionNewAccountR\nnewAccount\x12Q\n\x07unknown\x18\x0f\x20\
    \x01(\x0b27.hw.trezor.messages.eos.EosTxActionAck.EosActionUnknownR\x07u\
    nknown\x1a:\n\x08EosAsset\x12\x16\n\x06amount\x18\x01\x20\x01(\x12R\x06a\
    mount\x12\x16\n\x06symbol\x18\x02\x20\x01(\x04R\x06symbol\x1aJ\n\x12EosP\
    ermissionLevel\x12\x14\n\x05actor\x18\x01\x20\x01(\x04R\x05actor\x12\x1e\
    \n\npermission\x18\x02\x20\x01(\x04R\npermission\x1ap\n\x13EosAuthorizat\
    ionKey\x12\x12\n\x04type\x18\x01\x20\x02(\rR\x04type\x12\x10\n\x03key\
    \x18\x02\x20\x01(\x0cR\x03key\x12\x1b\n\taddress_n\x18\x03\x20\x03(\rR\
    \x08addressN\x12\x16\n\x06weight\x18\x04\x20\x02(\rR\x06weight\x1a\x86\
    \x01\n\x17EosAuthorizationAccount\x12S\n\x07account\x18\x01\x20\x01(\x0b\
    29.hw.trezor.messages.eos.EosTxActionAck.EosPermissionLevelR\x07account\
    \x12\x16\n\x06weight\x18\x02\x20\x01(\rR\x06weight\x1aI\n\x14EosAuthoriz\
    ationWait\x12\x19\n\x08wait_sec\x18\x01\x20\x01(\rR\x07waitSec\x12\x16\n\
    \x06weight\x18\x02\x20\x01(\rR\x06weight\x1a\xaf\x02\n\x10EosAuthorizati\
    on\x12\x1c\n\tthreshold\x18\x01\x20\x01(\rR\tthreshold\x12N\n\x04keys\
    \x18\x02\x20\x03(\x0b2:.hw.trezor.messages.eos.EosTxActionAck.EosAuthori\
    zationKeyR\x04keys\x12Z\n\x08accounts\x18\x03\x20\x03(\x0b2>.hw.trezor.m\
    essages.eos.EosTxActionAck.EosAuthorizationAccountR\x08accounts\x12Q\n\
    \x05waits\x18\x04\x20\x03(\x0b2;.hw.trezor.messages.eos.EosTxActionAck.E\
    osAuthorizationWaitR\x05waits\x1a\xa0\x01\n\x0fEosActionCommon\x12\x18\n\
    \x07account\x18\x01\x20\x01(\x04R\x07account\x12\x12\n\x04name\x18\x02\
    \x20\x01(\x04R\x04name\x12_\n\rauthorization\x18\x03\x20\x03(\x0b29.hw.t\
    rezor.messages.eos.EosTxActionAck.EosPermissionLevelR\rauthorization\x1a\
    \xa8\x01\n\x11EosActionTransfer\x12\x16\n\x06sender\x18\x01\x20\x01(\x04\
    R\x06sender\x12\x1a\n\x08receiver\x18\x02\x20\x01(\x04R\x08receiver\x12K\
    \n\x08quantity\x18\x03\x20\x01(\x0b2/.hw.trezor.messages.eos.EosTxAction\
    Ack.EosAssetR\x08quantity\x12\x12\n\x04memo\x18\x04\x20\x01(\tR\x04memo\
    \x1a\x8b\x02\n\x11EosActionDelegate\x12\x16\n\x06sender\x18\x01\x20\x01(\
    \x04R\x06sender\x12\x1a\n\x08receiver\x18\x02\x20\x01(\x04R\x08receiver\
    \x12R\n\x0cnet_quantity\x18\x03\x20\x01(\x0b2/.hw.trezor.messages.eos.Eo\
    sTxActionAck.EosAssetR\x0bnetQuantity\x12R\n\x0ccpu_quantity\x18\x04\x20\
    \x01(\x0b2/.hw.trezor.messages.eos.EosTxActionAck.EosAssetR\x0bcpuQuanti\
    ty\x12\x1a\n\x08transfer\x18\x05\x20\x01(\x08R\x08transfer\x1a\xf1\x01\n\
    \x13EosActionUndelegate\x12\x16\n\x06sender\x18\x01\x20\x01(\x04R\x06sen\
    der\x12\x1a\n\x08receiver\x18\x02\x20\x01(\x04R\x08receiver\x12R\n\x0cne\
    t_quantity\x18\x03\x20\x01(\x0b2/.hw.trezor.messages.eos.EosTxActionAck.\
    EosAssetR\x0bnetQuantity\x12R\n\x0ccpu_quantity\x18\x04\x20\x01(\x0b2/.h\
    w.trezor.messages.eos.EosTxActionAck.EosAssetR\x0bcpuQuantity\x1a'\n\x0f\
    EosActionRefund\x12\x14\n\x05owner\x18\x01\x20\x01(\x04R\x05owner\x1a\
    \x90\x01\n\x0fEosActionBuyRam\x12\x14\n\x05payer\x18\x01\x20\x01(\x04R\
    \x05payer\x12\x1a\n\x08receiver\x18\x02\x20\x01(\x04R\x08receiver\x12K\n\
    \x08quantity\x18\x03\x20\x01(\x0b2/.hw.trezor.messages.eos.EosTxActionAc\
    k.EosAssetR\x08quantity\x1a^\n\x14EosActionBuyRamBytes\x12\x14\n\x05paye\
    r\x18\x01\x20\x01(\x04R\x05payer\x12\x1a\n\x08receiver\x18\x02\x20\x01(\
    \x04R\x08receiver\x12\x14\n\x05bytes\x18\x03\x20\x01(\rR\x05bytes\x1aB\n\
    \x10EosActionSellRam\x12\x18\n\x07account\x18\x01\x20\x01(\x04R\x07accou\
    nt\x12\x14\n\x05bytes\x18\x02\x20\x01(\x04R\x05bytes\x1aa\n\x15EosAction\
    VoteProducer\x12\x14\n\x05voter\x18\x01\x20\x01(\x04R\x05voter\x12\x14\n\
    \x05proxy\x18\x02\x20\x01(\x04R\x05proxy\x12\x1c\n\tproducers\x18\x03\
    \x20\x03(\x04R\tproducers\x1a\xb4\x01\n\x13EosActionUpdateAuth\x12\x18\n\
    \x07account\x18\x01\x20\x01(\x04R\x07account\x12\x1e\n\npermission\x18\
    \x02\x20\x01(\x04R\npermission\x12\x16\n\x06parent\x18\x03\x20\x01(\x04R\
    \x06parent\x12K\n\x04auth\x18\x04\x20\x01(\x0b27.hw.trezor.messages.eos.\
    EosTxActionAck.EosAuthorizationR\x04auth\x1aO\n\x13EosActionDeleteAuth\
    \x12\x18\n\x07account\x18\x01\x20\x01(\x04R\x07account\x12\x1e\n\npermis\
    sion\x18\x02\x20\x01(\x04R\npermission\x1aw\n\x11EosActionLinkAuth\x12\
    \x18\n\x07account\x18\x01\x20\x01(\x04R\x07account\x12\x12\n\x04code\x18\
    \x02\x20\x01(\x04R\x04code\x12\x12\n\x04type\x18\x03\x20\x01(\x04R\x04ty\
    pe\x12\x20\n\x0brequirement\x18\x04\x20\x01(\x04R\x0brequirement\x1aW\n\
    \x13EosActionUnlinkAuth\x12\x18\n\x07account\x18\x01\x20\x01(\x04R\x07ac\
    count\x12\x12\n\x04code\x18\x02\x20\x01(\x04R\x04code\x12\x12\n\x04type\
    \x18\x03\x20\x01(\x04R\x04type\x1a\xe3\x01\n\x13EosActionNewAccount\x12\
    \x18\n\x07creator\x18\x01\x20\x01(\x04R\x07creator\x12\x12\n\x04name\x18\
    \x02\x20\x01(\x04R\x04name\x12M\n\x05owner\x18\x03\x20\x01(\x0b27.hw.tre\
    zor.messages.eos.EosTxActionAck.EosAuthorizationR\x05owner\x12O\n\x06act\
    ive\x18\x04\x20\x01(\x0b27.hw.trezor.messages.eos.EosTxActionAck.EosAuth\
    orizationR\x06active\x1aN\n\x10EosActionUnknown\x12\x1b\n\tdata_size\x18\
    \x01\x20\x02(\rR\x08dataSize\x12\x1d\n\ndata_chunk\x18\x02\x20\x01(\x0cR\
    \tdataChunk\"+\n\x0bEosSignedTx\x12\x1c\n\tsignature\x18\x01\x20\x02(\tR\
    \tsignatureB7\n#com.satoshilabs.trezor.lib.protobufB\x10TrezorMessageEos\
    J\xb6Y\n\x07\x12\x05\0\0\x98\x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\
    \x08\n\x01\x02\x12\x03\x01\x08\x1e\n\x08\n\x01\x08\x12\x03\x04\0<\n.\n\
    \x02\x08\x01\x12\x03\x04\0<\x1a#\x20Sugar\x20for\x20easier\x20handling\
    \x20in\x20Java\n\n\x08\n\x01\x08\x12\x03\x05\01\n\t\n\x02\x08\x08\x12\
    \x03\x05\01\n\x81\x01\n\x02\x04\0\x12\x04\r\0\x10\x01\x1au*\n\x20Request\
    :\x20Ask\x20device\x20for\x20Eos\x20public\x20key\x20corresponding\x20to\
    \x20address_n\x20path\n\x20@start\n\x20@next\x20EosPublicKey\n\x20@next\
    \x20Failure\n\n\n\n\x03\x04\0\x01\x12\x03\r\x08\x17\nI\n\x04\x04\0\x02\0\
    \x12\x03\x0e\x04\"\"<\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\
    \x20from\x20master\x20node\x2044'/194'/0'\n\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x0e\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0e\r\x13\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x0e\x14\x1d\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x0e\x20!\nC\n\x04\x04\0\x02\x01\x12\x03\x0f\x04#\"6\x20optional\
    ly\x20show\x20on\x20display\x20before\x20sending\x20the\x20result\n\n\
    \x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0f\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \x01\x05\x12\x03\x0f\r\x11\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0f\x12\
    \x1e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0f!\"\n[\n\x02\x04\x01\x12\
    \x04\x16\0\x19\x01\x1aO*\n\x20Response:\x20Contains\x20an\x20Eos\x20publ\
    ic\x20key\x20derived\x20from\x20device\x20private\x20seed\n\x20@end\n\n\
    \n\n\x03\x04\x01\x01\x12\x03\x16\x08\x14\n-\n\x04\x04\x01\x02\0\x12\x03\
    \x17\x04'\"\x20\x20EOS\x20pub\x20key\x20in\x20Base58\x20encoding\n\n\x0c\
    \n\x05\x04\x01\x02\0\x04\x12\x03\x17\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03\x17\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x17\x14\"\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x17%&\n\x1d\n\x04\x04\x01\x02\x01\
    \x12\x03\x18\x04&\"\x10\x20Raw\x20public\x20key\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x04\x12\x03\x18\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\
    \x18\r\x12\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x18\x13!\n\x0c\n\x05\
    \x04\x01\x02\x01\x03\x12\x03\x18$%\nb\n\x02\x04\x02\x12\x04!\02\x01\x1aV\
    *\n\x20Request:\x20Ask\x20device\x20to\x20sign\x20transaction\n\x20@star\
    t\n\x20@next\x20EosTxRequest\n\x20@next\x20Failure\n\n\n\n\x03\x04\x02\
    \x01\x12\x03!\x08\x11\nI\n\x04\x04\x02\x02\0\x12\x03\"\x04\"\"<\x20BIP-3\
    2\x20path\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\x2044'\
    /194'/0'\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\"\x04\x0c\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03\"\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\
    \"\x14\x1d\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\"\x20!\n$\n\x04\x04\x02\
    \x02\x01\x12\x03#\x04\x20\"\x17\x20256-bit\x20long\x20chain\x20id\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03#\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x01\x05\x12\x03#\r\x12\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03#\x13\x1b\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03#\x1e\x1f\n%\n\x04\x04\x02\x02\
    \x02\x12\x03$\x04$\"\x18\x20EOS\x20transaction\x20header\n\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03$\x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\x06\
    \x12\x03$\r\x18\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03$\x19\x1f\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03$\"#\n\x20\n\x04\x04\x02\x02\x03\x12\x03\
    %\x04$\"\x13\x20number\x20of\x20actions\n\n\x0c\n\x05\x04\x02\x02\x03\
    \x04\x12\x03%\x04\x0c\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03%\r\x13\n\
    \x0c\n\x05\x04\x02\x02\x03\x01\x12\x03%\x14\x1f\n\x0c\n\x05\x04\x02\x02\
    \x03\x03\x12\x03%\"#\n?\n\x04\x04\x02\x03\0\x12\x04*\x041\x05\x1a1*\n\
    \x20Structure\x20representing\x20EOS\x20transaction\x20header\n\n\x0c\n\
    \x05\x04\x02\x03\0\x01\x12\x03*\x0c\x17\n2\n\x06\x04\x02\x03\0\x02\0\x12\
    \x03+\x08'\"#\x20time\x20at\x20which\x20transaction\x20expires\n\n\x0e\n\
    \x07\x04\x02\x03\0\x02\0\x04\x12\x03+\x08\x10\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x05\x12\x03+\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03+\
    \x18\"\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03+%&\nF\n\x06\x04\x02\
    \x03\0\x02\x01\x12\x03,\x08*\"7\x2016-bit\x20specifies\x20a\x20block\x20\
    num\x20in\x20the\x20last\x202^16\x20blocks.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x04\x12\x03,\x08\x10\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x03,\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03,\x18%\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x01\x03\x12\x03,()\nO\n\x06\x04\x02\x03\0\x02\
    \x02\x12\x03-\x08-\"@\x20specifies\x20the\x20lower\x2032\x20bits\x20of\
    \x20the\x20blockid\x20at\x20get_ref_blocknum\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x02\x04\x12\x03-\x08\x10\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x05\x12\
    \x03-\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x01\x12\x03-\x18(\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x02\x03\x12\x03-+,\ne\n\x06\x04\x02\x03\0\x02\
    \x03\x12\x03.\x080\"V\x20upper\x20limit\x20on\x20total\x20network\x20ban\
    dwidth\x20(in\x208\x20byte\x20words)\x20billed\x20for\x20this\x20transac\
    tion\n\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x04\x12\x03.\x08\x10\n\x0e\n\
    \x07\x04\x02\x03\0\x02\x03\x05\x12\x03.\x11\x17\n\x0e\n\x07\x04\x02\x03\
    \0\x02\x03\x01\x12\x03.\x18+\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x03\x12\
    \x03../\nT\n\x06\x04\x02\x03\0\x02\x04\x12\x03/\x08-\"E\x208-bit\x20uppe\
    r\x20limit\x20on\x20the\x20total\x20CPU\x20time\x20billed\x20for\x20this\
    \x20transaction\n\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x04\x12\x03/\x08\x10\
    \n\x0e\n\x07\x04\x02\x03\0\x02\x04\x05\x12\x03/\x11\x17\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x04\x01\x12\x03/\x18(\n\x0e\n\x07\x04\x02\x03\0\x02\x04\
    \x03\x12\x03/+,\na\n\x06\x04\x02\x03\0\x02\x05\x12\x030\x08&\"R\x20numbe\
    r\x20of\x20seconds\x20to\x20delay\x20this\x20transaction\x20for\x20durin\
    g\x20which\x20it\x20may\x20be\x20canceled.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x05\x04\x12\x030\x08\x10\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x05\x12\
    \x030\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x01\x12\x030\x18!\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x05\x03\x12\x030$%\nQ\n\x02\x04\x03\x12\x048\0:\
    \x01\x1aE*\n\x20Response:\x20Device\x20asks\x20to\x20upload\x20next\x20a\
    ction\n\x20@next\x20EosTxActionAck\n\n\n\n\x03\x04\x03\x01\x12\x038\x08\
    \x1a\n\x0b\n\x04\x04\x03\x02\0\x12\x039\x04\"\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x039\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x039\r\x13\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x039\x14\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x039\x20!\n\x80\x01\n\x02\x04\x04\x12\x05B\0\x8f\x02\x01\x1as*\n\
    \x20Request:\x20Next\x20action\x20data\x20that\x20needs\x20to\x20be\x20u\
    ploaded\n\x20@next\x20EosTxActionRequest\n\x20@next\x20EosSignedTx\n\x20\
    @next\x20Failure\n\n\n\n\x03\x04\x04\x01\x12\x03B\x08\x16\n\x0b\n\x04\
    \x04\x04\x02\0\x12\x03C\x04(\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03C\x04\
    \x0c\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03C\r\x1c\n\x0c\n\x05\x04\x04\
    \x02\0\x01\x12\x03C\x1d#\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03C&'\n\x0b\
    \n\x04\x04\x04\x02\x01\x12\x03D\x04,\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\
    \x03D\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03D\r\x1e\n\x0c\n\x05\
    \x04\x04\x02\x01\x01\x12\x03D\x1f'\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03D*+\n\x0b\n\x04\x04\x04\x02\x02\x12\x03E\x04,\n\x0c\n\x05\x04\x04\
    \x02\x02\x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x03E\r\
    \x1e\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03E\x1f'\n\x0c\n\x05\x04\x04\
    \x02\x02\x03\x12\x03E*+\n\x0b\n\x04\x04\x04\x02\x03\x12\x03F\x040\n\x0c\
    \n\x05\x04\x04\x02\x03\x04\x12\x03F\x04\x0c\n\x0c\n\x05\x04\x04\x02\x03\
    \x06\x12\x03F\r\x20\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03F!+\n\x0c\n\
    \x05\x04\x04\x02\x03\x03\x12\x03F./\n\x0b\n\x04\x04\x04\x02\x04\x12\x03G\
    \x04(\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03G\x04\x0c\n\x0c\n\x05\x04\
    \x04\x02\x04\x06\x12\x03G\r\x1c\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03G\
    \x1d#\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03G&'\n\x0b\n\x04\x04\x04\x02\
    \x05\x12\x03H\x04)\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03H\x04\x0c\n\
    \x0c\n\x05\x04\x04\x02\x05\x06\x12\x03H\r\x1c\n\x0c\n\x05\x04\x04\x02\
    \x05\x01\x12\x03H\x1d$\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03H'(\n\x0b\
    \n\x04\x04\x04\x02\x06\x12\x03I\x044\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\
    \x03I\x04\x0c\n\x0c\n\x05\x04\x04\x02\x06\x06\x12\x03I\r!\n\x0c\n\x05\
    \x04\x04\x02\x06\x01\x12\x03I\"/\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03\
    I23\n\x0b\n\x04\x04\x04\x02\x07\x12\x03J\x04+\n\x0c\n\x05\x04\x04\x02\
    \x07\x04\x12\x03J\x04\x0c\n\x0c\n\x05\x04\x04\x02\x07\x06\x12\x03J\r\x1d\
    \n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03J\x1e&\n\x0c\n\x05\x04\x04\x02\
    \x07\x03\x12\x03J)*\n\x0b\n\x04\x04\x04\x02\x08\x12\x03K\x045\n\x0c\n\
    \x05\x04\x04\x02\x08\x04\x12\x03K\x04\x0c\n\x0c\n\x05\x04\x04\x02\x08\
    \x06\x12\x03K\r\"\n\x0c\n\x05\x04\x04\x02\x08\x01\x12\x03K#0\n\x0c\n\x05\
    \x04\x04\x02\x08\x03\x12\x03K34\n\x0b\n\x04\x04\x04\x02\t\x12\x03L\x042\
    \n\x0c\n\x05\x04\x04\x02\t\x04\x12\x03L\x04\x0c\n\x0c\n\x05\x04\x04\x02\
    \t\x06\x12\x03L\r\x20\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03L!,\n\x0c\n\
    \x05\x04\x04\x02\t\x03\x12\x03L/1\n\x0b\n\x04\x04\x04\x02\n\x12\x03M\x04\
    2\n\x0c\n\x05\x04\x04\x02\n\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\x04\x02\
    \n\x06\x12\x03M\r\x20\n\x0c\n\x05\x04\x04\x02\n\x01\x12\x03M!,\n\x0c\n\
    \x05\x04\x04\x02\n\x03\x12\x03M/1\n\x0b\n\x04\x04\x04\x02\x0b\x12\x03N\
    \x04.\n\x0c\n\x05\x04\x04\x02\x0b\x04\x12\x03N\x04\x0c\n\x0c\n\x05\x04\
    \x04\x02\x0b\x06\x12\x03N\r\x1e\n\x0c\n\x05\x04\x04\x02\x0b\x01\x12\x03N\
    \x1f(\n\x0c\n\x05\x04\x04\x02\x0b\x03\x12\x03N+-\n\x0b\n\x04\x04\x04\x02\
    \x0c\x12\x03O\x042\n\x0c\n\x05\x04\x04\x02\x0c\x04\x12\x03O\x04\x0c\n\
    \x0c\n\x05\x04\x04\x02\x0c\x06\x12\x03O\r\x20\n\x0c\n\x05\x04\x04\x02\
    \x0c\x01\x12\x03O!,\n\x0c\n\x05\x04\x04\x02\x0c\x03\x12\x03O/1\n\x0b\n\
    \x04\x04\x04\x02\r\x12\x03P\x042\n\x0c\n\x05\x04\x04\x02\r\x04\x12\x03P\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\r\x06\x12\x03P\r\x20\n\x0c\n\x05\x04\
    \x04\x02\r\x01\x12\x03P!,\n\x0c\n\x05\x04\x04\x02\r\x03\x12\x03P/1\n\x0b\
    \n\x04\x04\x04\x02\x0e\x12\x03Q\x04+\n\x0c\n\x05\x04\x04\x02\x0e\x04\x12\
    \x03Q\x04\x0c\n\x0c\n\x05\x04\x04\x02\x0e\x06\x12\x03Q\r\x1d\n\x0c\n\x05\
    \x04\x04\x02\x0e\x01\x12\x03Q\x1e%\n\x0c\n\x05\x04\x04\x02\x0e\x03\x12\
    \x03Q(*\n3\n\x04\x04\x04\x03\0\x12\x04V\x04Y\x05\x1a%*\n\x20Structure\
    \x20representing\x20asset\x20type\n\n\x0c\n\x05\x04\x04\x03\0\x01\x12\
    \x03V\x0c\x14\n\r\n\x06\x04\x04\x03\0\x02\0\x12\x03W\x08#\n\x0e\n\x07\
    \x04\x04\x03\0\x02\0\x04\x12\x03W\x08\x10\n\x0e\n\x07\x04\x04\x03\0\x02\
    \0\x05\x12\x03W\x11\x17\n\x0e\n\x07\x04\x04\x03\0\x02\0\x01\x12\x03W\x18\
    \x1e\n\x0e\n\x07\x04\x04\x03\0\x02\0\x03\x12\x03W!\"\n2\n\x06\x04\x04\
    \x03\0\x02\x01\x12\x03X\x08#\"#\x20Lowest\x208\x20bits\x20used\x20for\
    \x20precision.\n\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x04\x12\x03X\x08\x10\
    \n\x0e\n\x07\x04\x04\x03\0\x02\x01\x05\x12\x03X\x11\x17\n\x0e\n\x07\x04\
    \x04\x03\0\x02\x01\x01\x12\x03X\x18\x1e\n\x0e\n\x07\x04\x04\x03\0\x02\
    \x01\x03\x12\x03X!\"\n@\n\x04\x04\x04\x03\x01\x12\x04^\x04a\x05\x1a2*\n\
    \x20Structure\x20representing\x20action\x20permission\x20level\n\n\x0c\n\
    \x05\x04\x04\x03\x01\x01\x12\x03^\x0c\x1e\n\r\n\x06\x04\x04\x03\x01\x02\
    \0\x12\x03_\x08\"\n\x0e\n\x07\x04\x04\x03\x01\x02\0\x04\x12\x03_\x08\x10\
    \n\x0e\n\x07\x04\x04\x03\x01\x02\0\x05\x12\x03_\x11\x17\n\x0e\n\x07\x04\
    \x04\x03\x01\x02\0\x01\x12\x03_\x18\x1d\n\x0e\n\x07\x04\x04\x03\x01\x02\
    \0\x03\x12\x03_\x20!\n\r\n\x06\x04\x04\x03\x01\x02\x01\x12\x03`\x08'\n\
    \x0e\n\x07\x04\x04\x03\x01\x02\x01\x04\x12\x03`\x08\x10\n\x0e\n\x07\x04\
    \x04\x03\x01\x02\x01\x05\x12\x03`\x11\x17\n\x0e\n\x07\x04\x04\x03\x01\
    \x02\x01\x01\x12\x03`\x18\"\n\x0e\n\x07\x04\x04\x03\x01\x02\x01\x03\x12\
    \x03`%&\n1\n\x04\x04\x04\x03\x02\x12\x04f\x04k\x05\x1a#*\n\x20Structure\
    \x20representing\x20auth\x20key\n\n\x0c\n\x05\x04\x04\x03\x02\x01\x12\
    \x03f\x0c\x1f\n\r\n\x06\x04\x04\x03\x02\x02\0\x12\x03g\x08!\n\x0e\n\x07\
    \x04\x04\x03\x02\x02\0\x04\x12\x03g\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\
    \x02\0\x05\x12\x03g\x11\x17\n\x0e\n\x07\x04\x04\x03\x02\x02\0\x01\x12\
    \x03g\x18\x1c\n\x0e\n\x07\x04\x04\x03\x02\x02\0\x03\x12\x03g\x1f\x20\nQ\
    \n\x06\x04\x04\x03\x02\x02\x01\x12\x03h\x08\x1f\"B\x20Explicit\x20public\
    \x20key\x20bytes;\x20when\x20present,\x20address_n\x20must\x20be\x20empt\
    y\n\n\x0e\n\x07\x04\x04\x03\x02\x02\x01\x04\x12\x03h\x08\x10\n\x0e\n\x07\
    \x04\x04\x03\x02\x02\x01\x05\x12\x03h\x11\x16\n\x0e\n\x07\x04\x04\x03\
    \x02\x02\x01\x01\x12\x03h\x17\x1a\n\x0e\n\x07\x04\x04\x03\x02\x02\x01\
    \x03\x12\x03h\x1d\x1e\nT\n\x06\x04\x04\x03\x02\x02\x02\x12\x03i\x08&\"E\
    \x20BIP-32\x20path\x20to\x20derive\x20key;\x20when\x20filled\x20out,\x20\
    key\x20must\x20not\x20be\x20present\n\n\x0e\n\x07\x04\x04\x03\x02\x02\
    \x02\x04\x12\x03i\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x02\x05\x12\
    \x03i\x11\x17\n\x0e\n\x07\x04\x04\x03\x02\x02\x02\x01\x12\x03i\x18!\n\
    \x0e\n\x07\x04\x04\x03\x02\x02\x02\x03\x12\x03i$%\n\r\n\x06\x04\x04\x03\
    \x02\x02\x03\x12\x03j\x08#\n\x0e\n\x07\x04\x04\x03\x02\x02\x03\x04\x12\
    \x03j\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x03\x05\x12\x03j\x11\x17\n\
    \x0e\n\x07\x04\x04\x03\x02\x02\x03\x01\x12\x03j\x18\x1e\n\x0e\n\x07\x04\
    \x04\x03\x02\x02\x03\x03\x12\x03j!\"\n5\n\x04\x04\x04\x03\x03\x12\x04p\
    \x04s\x05\x1a'*\n\x20Structure\x20representing\x20auth\x20account\n\n\
    \x0c\n\x05\x04\x04\x03\x03\x01\x12\x03p\x0c#\n\r\n\x06\x04\x04\x03\x03\
    \x02\0\x12\x03q\x080\n\x0e\n\x07\x04\x04\x03\x03\x02\0\x04\x12\x03q\x08\
    \x10\n\x0e\n\x07\x04\x04\x03\x03\x02\0\x06\x12\x03q\x11#\n\x0e\n\x07\x04\
    \x04\x03\x03\x02\0\x01\x12\x03q$+\n\x0e\n\x07\x04\x04\x03\x03\x02\0\x03\
    \x12\x03q./\n\r\n\x06\x04\x04\x03\x03\x02\x01\x12\x03r\x08#\n\x0e\n\x07\
    \x04\x04\x03\x03\x02\x01\x04\x12\x03r\x08\x10\n\x0e\n\x07\x04\x04\x03\
    \x03\x02\x01\x05\x12\x03r\x11\x17\n\x0e\n\x07\x04\x04\x03\x03\x02\x01\
    \x01\x12\x03r\x18\x1e\n\x0e\n\x07\x04\x04\x03\x03\x02\x01\x03\x12\x03r!\
    \"\n4\n\x04\x04\x04\x03\x04\x12\x04x\x04{\x05\x1a&*\n\x20Structure\x20re\
    presenting\x20auth\x20delays\n\n\x0c\n\x05\x04\x04\x03\x04\x01\x12\x03x\
    \x0c\x20\n\r\n\x06\x04\x04\x03\x04\x02\0\x12\x03y\x08%\n\x0e\n\x07\x04\
    \x04\x03\x04\x02\0\x04\x12\x03y\x08\x10\n\x0e\n\x07\x04\x04\x03\x04\x02\
    \0\x05\x12\x03y\x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\0\x01\x12\x03y\
    \x18\x20\n\x0e\n\x07\x04\x04\x03\x04\x02\0\x03\x12\x03y#$\n\r\n\x06\x04\
    \x04\x03\x04\x02\x01\x12\x03z\x08#\n\x0e\n\x07\x04\x04\x03\x04\x02\x01\
    \x04\x12\x03z\x08\x10\n\x0e\n\x07\x04\x04\x03\x04\x02\x01\x05\x12\x03z\
    \x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\x01\x01\x12\x03z\x18\x1e\n\x0e\
    \n\x07\x04\x04\x03\x04\x02\x01\x03\x12\x03z!\"\nA\n\x04\x04\x04\x03\x05\
    \x12\x06\x80\x01\x04\x85\x01\x05\x1a1*\n\x20Structure\x20representing\
    \x20authorization\x20settings\n\n\r\n\x05\x04\x04\x03\x05\x01\x12\x04\
    \x80\x01\x0c\x1c\n\x0e\n\x06\x04\x04\x03\x05\x02\0\x12\x04\x81\x01\x08&\
    \n\x0f\n\x07\x04\x04\x03\x05\x02\0\x04\x12\x04\x81\x01\x08\x10\n\x0f\n\
    \x07\x04\x04\x03\x05\x02\0\x05\x12\x04\x81\x01\x11\x17\n\x0f\n\x07\x04\
    \x04\x03\x05\x02\0\x01\x12\x04\x81\x01\x18!\n\x0f\n\x07\x04\x04\x03\x05\
    \x02\0\x03\x12\x04\x81\x01$%\n\x0e\n\x06\x04\x04\x03\x05\x02\x01\x12\x04\
    \x82\x01\x08.\n\x0f\n\x07\x04\x04\x03\x05\x02\x01\x04\x12\x04\x82\x01\
    \x08\x10\n\x0f\n\x07\x04\x04\x03\x05\x02\x01\x06\x12\x04\x82\x01\x11$\n\
    \x0f\n\x07\x04\x04\x03\x05\x02\x01\x01\x12\x04\x82\x01%)\n\x0f\n\x07\x04\
    \x04\x03\x05\x02\x01\x03\x12\x04\x82\x01,-\n\x0e\n\x06\x04\x04\x03\x05\
    \x02\x02\x12\x04\x83\x01\x086\n\x0f\n\x07\x04\x04\x03\x05\x02\x02\x04\
    \x12\x04\x83\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x05\x02\x02\x06\x12\x04\
    \x83\x01\x11(\n\x0f\n\x07\x04\x04\x03\x05\x02\x02\x01\x12\x04\x83\x01)1\
    \n\x0f\n\x07\x04\x04\x03\x05\x02\x02\x03\x12\x04\x83\x0145\n\x0e\n\x06\
    \x04\x04\x03\x05\x02\x03\x12\x04\x84\x01\x080\n\x0f\n\x07\x04\x04\x03\
    \x05\x02\x03\x04\x12\x04\x84\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x05\x02\
    \x03\x06\x12\x04\x84\x01\x11%\n\x0f\n\x07\x04\x04\x03\x05\x02\x03\x01\
    \x12\x04\x84\x01&+\n\x0f\n\x07\x04\x04\x03\x05\x02\x03\x03\x12\x04\x84\
    \x01./\nJ\n\x04\x04\x04\x03\x06\x12\x06\x8a\x01\x04\x8e\x01\x05\x1a:*\n\
    \x20Structure\x20representing\x20the\x20common\x20part\x20of\x20every\
    \x20action\n\n\r\n\x05\x04\x04\x03\x06\x01\x12\x04\x8a\x01\x0c\x1b\n\x1f\
    \n\x06\x04\x04\x03\x06\x02\0\x12\x04\x8b\x01\x08$\"\x0f\x20Contract\x20n\
    ame\n\n\x0f\n\x07\x04\x04\x03\x06\x02\0\x04\x12\x04\x8b\x01\x08\x10\n\
    \x0f\n\x07\x04\x04\x03\x06\x02\0\x05\x12\x04\x8b\x01\x11\x17\n\x0f\n\x07\
    \x04\x04\x03\x06\x02\0\x01\x12\x04\x8b\x01\x18\x1f\n\x0f\n\x07\x04\x04\
    \x03\x06\x02\0\x03\x12\x04\x8b\x01\"#\n\x1d\n\x06\x04\x04\x03\x06\x02\
    \x01\x12\x04\x8c\x01\x08!\"\r\x20Action\x20name\n\n\x0f\n\x07\x04\x04\
    \x03\x06\x02\x01\x04\x12\x04\x8c\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x06\
    \x02\x01\x05\x12\x04\x8c\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x06\x02\x01\
    \x01\x12\x04\x8c\x01\x18\x1c\n\x0f\n\x07\x04\x04\x03\x06\x02\x01\x03\x12\
    \x04\x8c\x01\x1f\x20\n\x0e\n\x06\x04\x04\x03\x06\x02\x02\x12\x04\x8d\x01\
    \x086\n\x0f\n\x07\x04\x04\x03\x06\x02\x02\x04\x12\x04\x8d\x01\x08\x10\n\
    \x0f\n\x07\x04\x04\x03\x06\x02\x02\x06\x12\x04\x8d\x01\x11#\n\x0f\n\x07\
    \x04\x04\x03\x06\x02\x02\x01\x12\x04\x8d\x01$1\n\x0f\n\x07\x04\x04\x03\
    \x06\x02\x02\x03\x12\x04\x8d\x0145\nB\n\x04\x04\x04\x03\x07\x12\x06\x93\
    \x01\x04\x98\x01\x05\x1a2*\n\x20Structure\x20representing\x20transfer\
    \x20data\x20structure\n\n\r\n\x05\x04\x04\x03\x07\x01\x12\x04\x93\x01\
    \x0c\x1d\n\x1e\n\x06\x04\x04\x03\x07\x02\0\x12\x04\x94\x01\x08#\"\x0e\
    \x20Asset\x20sender\n\n\x0f\n\x07\x04\x04\x03\x07\x02\0\x04\x12\x04\x94\
    \x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x07\x02\0\x05\x12\x04\x94\x01\x11\
    \x17\n\x0f\n\x07\x04\x04\x03\x07\x02\0\x01\x12\x04\x94\x01\x18\x1e\n\x0f\
    \n\x07\x04\x04\x03\x07\x02\0\x03\x12\x04\x94\x01!\"\n\x0e\n\x06\x04\x04\
    \x03\x07\x02\x01\x12\x04\x95\x01\x08%\n\x0f\n\x07\x04\x04\x03\x07\x02\
    \x01\x04\x12\x04\x95\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x07\x02\x01\x05\
    \x12\x04\x95\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x07\x02\x01\x01\x12\x04\
    \x95\x01\x18\x20\n\x0f\n\x07\x04\x04\x03\x07\x02\x01\x03\x12\x04\x95\x01\
    #$\n\x0e\n\x06\x04\x04\x03\x07\x02\x02\x12\x04\x96\x01\x08'\n\x0f\n\x07\
    \x04\x04\x03\x07\x02\x02\x04\x12\x04\x96\x01\x08\x10\n\x0f\n\x07\x04\x04\
    \x03\x07\x02\x02\x06\x12\x04\x96\x01\x11\x19\n\x0f\n\x07\x04\x04\x03\x07\
    \x02\x02\x01\x12\x04\x96\x01\x1a\"\n\x0f\n\x07\x04\x04\x03\x07\x02\x02\
    \x03\x12\x04\x96\x01%&\n\x0e\n\x06\x04\x04\x03\x07\x02\x03\x12\x04\x97\
    \x01\x08!\n\x0f\n\x07\x04\x04\x03\x07\x02\x03\x04\x12\x04\x97\x01\x08\
    \x10\n\x0f\n\x07\x04\x04\x03\x07\x02\x03\x05\x12\x04\x97\x01\x11\x17\n\
    \x0f\n\x07\x04\x04\x03\x07\x02\x03\x01\x12\x04\x97\x01\x18\x1c\n\x0f\n\
    \x07\x04\x04\x03\x07\x02\x03\x03\x12\x04\x97\x01\x1f\x20\nD\n\x04\x04\
    \x04\x03\x08\x12\x06\x9d\x01\x04\xa3\x01\x05\x1a4*\n\x20Structure\x20rep\
    resenting\x20delegation\x20data\x20structure\n\n\r\n\x05\x04\x04\x03\x08\
    \x01\x12\x04\x9d\x01\x0c\x1d\n\x0e\n\x06\x04\x04\x03\x08\x02\0\x12\x04\
    \x9e\x01\x08#\n\x0f\n\x07\x04\x04\x03\x08\x02\0\x04\x12\x04\x9e\x01\x08\
    \x10\n\x0f\n\x07\x04\x04\x03\x08\x02\0\x05\x12\x04\x9e\x01\x11\x17\n\x0f\
    \n\x07\x04\x04\x03\x08\x02\0\x01\x12\x04\x9e\x01\x18\x1e\n\x0f\n\x07\x04\
    \x04\x03\x08\x02\0\x03\x12\x04\x9e\x01!\"\n\x0e\n\x06\x04\x04\x03\x08\
    \x02\x01\x12\x04\x9f\x01\x08%\n\x0f\n\x07\x04\x04\x03\x08\x02\x01\x04\
    \x12\x04\x9f\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x08\x02\x01\x05\x12\x04\
    \x9f\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x08\x02\x01\x01\x12\x04\x9f\x01\
    \x18\x20\n\x0f\n\x07\x04\x04\x03\x08\x02\x01\x03\x12\x04\x9f\x01#$\n+\n\
    \x06\x04\x04\x03\x08\x02\x02\x12\x04\xa0\x01\x08+\"\x1b\x20Asset\x20form\
    at\x20'1.0000\x20EOS'\n\n\x0f\n\x07\x04\x04\x03\x08\x02\x02\x04\x12\x04\
    \xa0\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x08\x02\x02\x06\x12\x04\xa0\x01\
    \x11\x19\n\x0f\n\x07\x04\x04\x03\x08\x02\x02\x01\x12\x04\xa0\x01\x1a&\n\
    \x0f\n\x07\x04\x04\x03\x08\x02\x02\x03\x12\x04\xa0\x01)*\n+\n\x06\x04\
    \x04\x03\x08\x02\x03\x12\x04\xa1\x01\x08+\"\x1b\x20Asset\x20format\x20'1\
    .0000\x20EOS'\n\n\x0f\n\x07\x04\x04\x03\x08\x02\x03\x04\x12\x04\xa1\x01\
    \x08\x10\n\x0f\n\x07\x04\x04\x03\x08\x02\x03\x06\x12\x04\xa1\x01\x11\x19\
    \n\x0f\n\x07\x04\x04\x03\x08\x02\x03\x01\x12\x04\xa1\x01\x1a&\n\x0f\n\
    \x07\x04\x04\x03\x08\x02\x03\x03\x12\x04\xa1\x01)*\n3\n\x06\x04\x04\x03\
    \x08\x02\x04\x12\x04\xa2\x01\x08#\"#\x20Transfer\x20delegated\x20tokens\
    \x20or\x20not.\n\n\x0f\n\x07\x04\x04\x03\x08\x02\x04\x04\x12\x04\xa2\x01\
    \x08\x10\n\x0f\n\x07\x04\x04\x03\x08\x02\x04\x05\x12\x04\xa2\x01\x11\x15\
    \n\x0f\n\x07\x04\x04\x03\x08\x02\x04\x01\x12\x04\xa2\x01\x16\x1e\n\x0f\n\
    \x07\x04\x04\x03\x08\x02\x04\x03\x12\x04\xa2\x01!\"\n[\n\x04\x04\x04\x03\
    \t\x12\x06\xa8\x01\x04\xad\x01\x05\x1aK*\n\x20Structure\x20representing\
    \x20the\x20removal\x20of\x20delegated\x20resources\x20from\x20`sender`\n\
    \n\r\n\x05\x04\x04\x03\t\x01\x12\x04\xa8\x01\x0c\x1f\n\x0e\n\x06\x04\x04\
    \x03\t\x02\0\x12\x04\xa9\x01\x08#\n\x0f\n\x07\x04\x04\x03\t\x02\0\x04\
    \x12\x04\xa9\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\t\x02\0\x05\x12\x04\xa9\
    \x01\x11\x17\n\x0f\n\x07\x04\x04\x03\t\x02\0\x01\x12\x04\xa9\x01\x18\x1e\
    \n\x0f\n\x07\x04\x04\x03\t\x02\0\x03\x12\x04\xa9\x01!\"\n\x0e\n\x06\x04\
    \x04\x03\t\x02\x01\x12\x04\xaa\x01\x08%\n\x0f\n\x07\x04\x04\x03\t\x02\
    \x01\x04\x12\x04\xaa\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\t\x02\x01\x05\
    \x12\x04\xaa\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\t\x02\x01\x01\x12\x04\
    \xaa\x01\x18\x20\n\x0f\n\x07\x04\x04\x03\t\x02\x01\x03\x12\x04\xaa\x01#$\
    \n+\n\x06\x04\x04\x03\t\x02\x02\x12\x04\xab\x01\x08+\"\x1b\x20Asset\x20f\
    ormat\x20'1.0000\x20EOS'\n\n\x0f\n\x07\x04\x04\x03\t\x02\x02\x04\x12\x04\
    \xab\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\t\x02\x02\x06\x12\x04\xab\x01\
    \x11\x19\n\x0f\n\x07\x04\x04\x03\t\x02\x02\x01\x12\x04\xab\x01\x1a&\n\
    \x0f\n\x07\x04\x04\x03\t\x02\x02\x03\x12\x04\xab\x01)*\n+\n\x06\x04\x04\
    \x03\t\x02\x03\x12\x04\xac\x01\x08+\"\x1b\x20Asset\x20format\x20'1.0000\
    \x20EOS'\n\n\x0f\n\x07\x04\x04\x03\t\x02\x03\x04\x12\x04\xac\x01\x08\x10\
    \n\x0f\n\x07\x04\x04\x03\t\x02\x03\x06\x12\x04\xac\x01\x11\x19\n\x0f\n\
    \x07\x04\x04\x03\t\x02\x03\x01\x12\x04\xac\x01\x1a&\n\x0f\n\x07\x04\x04\
    \x03\t\x02\x03\x03\x12\x04\xac\x01)*\n^\n\x04\x04\x04\x03\n\x12\x06\xb2\
    \x01\x04\xb4\x01\x05\x1aN*\n\x20Structure\x20representing\x20fallback\
    \x20if\x20undelegate\x20wasnt\x20executed\x20automaticaly.\n\n\r\n\x05\
    \x04\x04\x03\n\x01\x12\x04\xb2\x01\x0c\x1b\n\x0e\n\x06\x04\x04\x03\n\x02\
    \0\x12\x04\xb3\x01\x08\"\n\x0f\n\x07\x04\x04\x03\n\x02\0\x04\x12\x04\xb3\
    \x01\x08\x10\n\x0f\n\x07\x04\x04\x03\n\x02\0\x05\x12\x04\xb3\x01\x11\x17\
    \n\x0f\n\x07\x04\x04\x03\n\x02\0\x01\x12\x04\xb3\x01\x18\x1d\n\x0f\n\x07\
    \x04\x04\x03\n\x02\0\x03\x12\x04\xb3\x01\x20!\nN\n\x04\x04\x04\x03\x0b\
    \x12\x06\xb9\x01\x04\xbd\x01\x05\x1a>*\n\x20Structure\x20representing\
    \x20buying\x20RAM\x20operation\x20for\x20EOS\x20tokens\n\n\r\n\x05\x04\
    \x04\x03\x0b\x01\x12\x04\xb9\x01\x0c\x1b\n\x0e\n\x06\x04\x04\x03\x0b\x02\
    \0\x12\x04\xba\x01\x08\"\n\x0f\n\x07\x04\x04\x03\x0b\x02\0\x04\x12\x04\
    \xba\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0b\x02\0\x05\x12\x04\xba\x01\
    \x11\x17\n\x0f\n\x07\x04\x04\x03\x0b\x02\0\x01\x12\x04\xba\x01\x18\x1d\n\
    \x0f\n\x07\x04\x04\x03\x0b\x02\0\x03\x12\x04\xba\x01\x20!\n\x0e\n\x06\
    \x04\x04\x03\x0b\x02\x01\x12\x04\xbb\x01\x08%\n\x0f\n\x07\x04\x04\x03\
    \x0b\x02\x01\x04\x12\x04\xbb\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0b\x02\
    \x01\x05\x12\x04\xbb\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0b\x02\x01\x01\
    \x12\x04\xbb\x01\x18\x20\n\x0f\n\x07\x04\x04\x03\x0b\x02\x01\x03\x12\x04\
    \xbb\x01#$\n+\n\x06\x04\x04\x03\x0b\x02\x02\x12\x04\xbc\x01\x08'\"\x1b\
    \x20Asset\x20format\x20'1.0000\x20EOS'\n\n\x0f\n\x07\x04\x04\x03\x0b\x02\
    \x02\x04\x12\x04\xbc\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0b\x02\x02\x06\
    \x12\x04\xbc\x01\x11\x19\n\x0f\n\x07\x04\x04\x03\x0b\x02\x02\x01\x12\x04\
    \xbc\x01\x1a\"\n\x0f\n\x07\x04\x04\x03\x0b\x02\x02\x03\x12\x04\xbc\x01%&\
    \nV\n\x04\x04\x04\x03\x0c\x12\x06\xc2\x01\x04\xc6\x01\x05\x1aF*\n\x20Str\
    ucture\x20representing\x20buying\x20bytes\x20according\x20to\x20RAM\x20m\
    arket\x20price.\n\n\r\n\x05\x04\x04\x03\x0c\x01\x12\x04\xc2\x01\x0c\x20\
    \n\x0e\n\x06\x04\x04\x03\x0c\x02\0\x12\x04\xc3\x01\x08\"\n\x0f\n\x07\x04\
    \x04\x03\x0c\x02\0\x04\x12\x04\xc3\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\
    \x0c\x02\0\x05\x12\x04\xc3\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0c\x02\0\
    \x01\x12\x04\xc3\x01\x18\x1d\n\x0f\n\x07\x04\x04\x03\x0c\x02\0\x03\x12\
    \x04\xc3\x01\x20!\n\x0e\n\x06\x04\x04\x03\x0c\x02\x01\x12\x04\xc4\x01\
    \x08%\n\x0f\n\x07\x04\x04\x03\x0c\x02\x01\x04\x12\x04\xc4\x01\x08\x10\n\
    \x0f\n\x07\x04\x04\x03\x0c\x02\x01\x05\x12\x04\xc4\x01\x11\x17\n\x0f\n\
    \x07\x04\x04\x03\x0c\x02\x01\x01\x12\x04\xc4\x01\x18\x20\n\x0f\n\x07\x04\
    \x04\x03\x0c\x02\x01\x03\x12\x04\xc4\x01#$\n!\n\x06\x04\x04\x03\x0c\x02\
    \x02\x12\x04\xc5\x01\x08\"\"\x11\x20Number\x20of\x20bytes\n\n\x0f\n\x07\
    \x04\x04\x03\x0c\x02\x02\x04\x12\x04\xc5\x01\x08\x10\n\x0f\n\x07\x04\x04\
    \x03\x0c\x02\x02\x05\x12\x04\xc5\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0c\
    \x02\x02\x01\x12\x04\xc5\x01\x18\x1d\n\x0f\n\x07\x04\x04\x03\x0c\x02\x02\
    \x03\x12\x04\xc5\x01\x20!\n3\n\x04\x04\x04\x03\r\x12\x06\xcb\x01\x04\xce\
    \x01\x05\x1a#*\n\x20Structure\x20representing\x20sell\x20RAM\n\n\r\n\x05\
    \x04\x04\x03\r\x01\x12\x04\xcb\x01\x0c\x1c\n\x0e\n\x06\x04\x04\x03\r\x02\
    \0\x12\x04\xcc\x01\x08$\n\x0f\n\x07\x04\x04\x03\r\x02\0\x04\x12\x04\xcc\
    \x01\x08\x10\n\x0f\n\x07\x04\x04\x03\r\x02\0\x05\x12\x04\xcc\x01\x11\x17\
    \n\x0f\n\x07\x04\x04\x03\r\x02\0\x01\x12\x04\xcc\x01\x18\x1f\n\x0f\n\x07\
    \x04\x04\x03\r\x02\0\x03\x12\x04\xcc\x01\"#\n!\n\x06\x04\x04\x03\r\x02\
    \x01\x12\x04\xcd\x01\x08\"\"\x11\x20Number\x20of\x20bytes\n\n\x0f\n\x07\
    \x04\x04\x03\r\x02\x01\x04\x12\x04\xcd\x01\x08\x10\n\x0f\n\x07\x04\x04\
    \x03\r\x02\x01\x05\x12\x04\xcd\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\r\x02\
    \x01\x01\x12\x04\xcd\x01\x18\x1d\n\x0f\n\x07\x04\x04\x03\r\x02\x01\x03\
    \x12\x04\xcd\x01\x20!\n`\n\x04\x04\x04\x03\x0e\x12\x06\xd3\x01\x04\xd7\
    \x01\x05\x1aP*\n\x20Structure\x20representing\x20voting.\x20Currently,\
    \x20there\x20could\x20be\x20up\x20to\x2030\x20producers.\n\n\r\n\x05\x04\
    \x04\x03\x0e\x01\x12\x04\xd3\x01\x0c!\n\x1f\n\x06\x04\x04\x03\x0e\x02\0\
    \x12\x04\xd4\x01\x08\"\"\x0f\x20Voter\x20account\n\n\x0f\n\x07\x04\x04\
    \x03\x0e\x02\0\x04\x12\x04\xd4\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0e\
    \x02\0\x05\x12\x04\xd4\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0e\x02\0\x01\
    \x12\x04\xd4\x01\x18\x1d\n\x0f\n\x07\x04\x04\x03\x0e\x02\0\x03\x12\x04\
    \xd4\x01\x20!\n%\n\x06\x04\x04\x03\x0e\x02\x01\x12\x04\xd5\x01\x08\"\"\
    \x15\x20Proxy\x20voter\x20account\n\n\x0f\n\x07\x04\x04\x03\x0e\x02\x01\
    \x04\x12\x04\xd5\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0e\x02\x01\x05\x12\
    \x04\xd5\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0e\x02\x01\x01\x12\x04\xd5\
    \x01\x18\x1d\n\x0f\n\x07\x04\x04\x03\x0e\x02\x01\x03\x12\x04\xd5\x01\x20\
    !\n#\n\x06\x04\x04\x03\x0e\x02\x02\x12\x04\xd6\x01\x08&\"\x13\x20List\
    \x20of\x20producers\n\n\x0f\n\x07\x04\x04\x03\x0e\x02\x02\x04\x12\x04\
    \xd6\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0e\x02\x02\x05\x12\x04\xd6\x01\
    \x11\x17\n\x0f\n\x07\x04\x04\x03\x0e\x02\x02\x01\x12\x04\xd6\x01\x18!\n\
    \x0f\n\x07\x04\x04\x03\x0e\x02\x02\x03\x12\x04\xd6\x01$%\n@\n\x04\x04\
    \x04\x03\x0f\x12\x06\xdc\x01\x04\xe1\x01\x05\x1a0*\n\x20Structure\x20rep\
    resenting\x20update\x20authorization.\n\n\r\n\x05\x04\x04\x03\x0f\x01\
    \x12\x04\xdc\x01\x0c\x1f\n\x0e\n\x06\x04\x04\x03\x0f\x02\0\x12\x04\xdd\
    \x01\x08$\n\x0f\n\x07\x04\x04\x03\x0f\x02\0\x04\x12\x04\xdd\x01\x08\x10\
    \n\x0f\n\x07\x04\x04\x03\x0f\x02\0\x05\x12\x04\xdd\x01\x11\x17\n\x0f\n\
    \x07\x04\x04\x03\x0f\x02\0\x01\x12\x04\xdd\x01\x18\x1f\n\x0f\n\x07\x04\
    \x04\x03\x0f\x02\0\x03\x12\x04\xdd\x01\"#\n\x0e\n\x06\x04\x04\x03\x0f\
    \x02\x01\x12\x04\xde\x01\x08'\n\x0f\n\x07\x04\x04\x03\x0f\x02\x01\x04\
    \x12\x04\xde\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0f\x02\x01\x05\x12\x04\
    \xde\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0f\x02\x01\x01\x12\x04\xde\x01\
    \x18\"\n\x0f\n\x07\x04\x04\x03\x0f\x02\x01\x03\x12\x04\xde\x01%&\n\x0e\n\
    \x06\x04\x04\x03\x0f\x02\x02\x12\x04\xdf\x01\x08#\n\x0f\n\x07\x04\x04\
    \x03\x0f\x02\x02\x04\x12\x04\xdf\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x0f\
    \x02\x02\x05\x12\x04\xdf\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x0f\x02\x02\
    \x01\x12\x04\xdf\x01\x18\x1e\n\x0f\n\x07\x04\x04\x03\x0f\x02\x02\x03\x12\
    \x04\xdf\x01!\"\n\x0e\n\x06\x04\x04\x03\x0f\x02\x03\x12\x04\xe0\x01\x08+\
    \n\x0f\n\x07\x04\x04\x03\x0f\x02\x03\x04\x12\x04\xe0\x01\x08\x10\n\x0f\n\
    \x07\x04\x04\x03\x0f\x02\x03\x06\x12\x04\xe0\x01\x11!\n\x0f\n\x07\x04\
    \x04\x03\x0f\x02\x03\x01\x12\x04\xe0\x01\"&\n\x0f\n\x07\x04\x04\x03\x0f\
    \x02\x03\x03\x12\x04\xe0\x01)*\n@\n\x04\x04\x04\x03\x10\x12\x06\xe6\x01\
    \x04\xe9\x01\x05\x1a0*\n\x20Structure\x20representing\x20delete\x20autho\
    rization.\n\n\r\n\x05\x04\x04\x03\x10\x01\x12\x04\xe6\x01\x0c\x1f\n\x0e\
    \n\x06\x04\x04\x03\x10\x02\0\x12\x04\xe7\x01\x08$\n\x0f\n\x07\x04\x04\
    \x03\x10\x02\0\x04\x12\x04\xe7\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x10\
    \x02\0\x05\x12\x04\xe7\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x10\x02\0\x01\
    \x12\x04\xe7\x01\x18\x1f\n\x0f\n\x07\x04\x04\x03\x10\x02\0\x03\x12\x04\
    \xe7\x01\"#\n\x0e\n\x06\x04\x04\x03\x10\x02\x01\x12\x04\xe8\x01\x08'\n\
    \x0f\n\x07\x04\x04\x03\x10\x02\x01\x04\x12\x04\xe8\x01\x08\x10\n\x0f\n\
    \x07\x04\x04\x03\x10\x02\x01\x05\x12\x04\xe8\x01\x11\x17\n\x0f\n\x07\x04\
    \x04\x03\x10\x02\x01\x01\x12\x04\xe8\x01\x18\"\n\x0f\n\x07\x04\x04\x03\
    \x10\x02\x01\x03\x12\x04\xe8\x01%&\nH\n\x04\x04\x04\x03\x11\x12\x06\xee\
    \x01\x04\xf3\x01\x05\x1a8*\n\x20Structure\x20representing\x20link\x20aut\
    horization\x20to\x20action.\n\n\r\n\x05\x04\x04\x03\x11\x01\x12\x04\xee\
    \x01\x0c\x1d\n\x0e\n\x06\x04\x04\x03\x11\x02\0\x12\x04\xef\x01\x08$\n\
    \x0f\n\x07\x04\x04\x03\x11\x02\0\x04\x12\x04\xef\x01\x08\x10\n\x0f\n\x07\
    \x04\x04\x03\x11\x02\0\x05\x12\x04\xef\x01\x11\x17\n\x0f\n\x07\x04\x04\
    \x03\x11\x02\0\x01\x12\x04\xef\x01\x18\x1f\n\x0f\n\x07\x04\x04\x03\x11\
    \x02\0\x03\x12\x04\xef\x01\"#\n\x0e\n\x06\x04\x04\x03\x11\x02\x01\x12\
    \x04\xf0\x01\x08!\n\x0f\n\x07\x04\x04\x03\x11\x02\x01\x04\x12\x04\xf0\
    \x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x11\x02\x01\x05\x12\x04\xf0\x01\x11\
    \x17\n\x0f\n\x07\x04\x04\x03\x11\x02\x01\x01\x12\x04\xf0\x01\x18\x1c\n\
    \x0f\n\x07\x04\x04\x03\x11\x02\x01\x03\x12\x04\xf0\x01\x1f\x20\n\x0e\n\
    \x06\x04\x04\x03\x11\x02\x02\x12\x04\xf1\x01\x08!\n\x0f\n\x07\x04\x04\
    \x03\x11\x02\x02\x04\x12\x04\xf1\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x11\
    \x02\x02\x05\x12\x04\xf1\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x11\x02\x02\
    \x01\x12\x04\xf1\x01\x18\x1c\n\x0f\n\x07\x04\x04\x03\x11\x02\x02\x03\x12\
    \x04\xf1\x01\x1f\x20\n\x0e\n\x06\x04\x04\x03\x11\x02\x03\x12\x04\xf2\x01\
    \x08(\n\x0f\n\x07\x04\x04\x03\x11\x02\x03\x04\x12\x04\xf2\x01\x08\x10\n\
    \x0f\n\x07\x04\x04\x03\x11\x02\x03\x05\x12\x04\xf2\x01\x11\x17\n\x0f\n\
    \x07\x04\x04\x03\x11\x02\x03\x01\x12\x04\xf2\x01\x18#\n\x0f\n\x07\x04\
    \x04\x03\x11\x02\x03\x03\x12\x04\xf2\x01&'\nL\n\x04\x04\x04\x03\x12\x12\
    \x06\xf8\x01\x04\xfc\x01\x05\x1a<*\n\x20Structure\x20representing\x20unl\
    ink\x20authorization\x20from\x20action.\n\n\r\n\x05\x04\x04\x03\x12\x01\
    \x12\x04\xf8\x01\x0c\x1f\n\x0e\n\x06\x04\x04\x03\x12\x02\0\x12\x04\xf9\
    \x01\x08$\n\x0f\n\x07\x04\x04\x03\x12\x02\0\x04\x12\x04\xf9\x01\x08\x10\
    \n\x0f\n\x07\x04\x04\x03\x12\x02\0\x05\x12\x04\xf9\x01\x11\x17\n\x0f\n\
    \x07\x04\x04\x03\x12\x02\0\x01\x12\x04\xf9\x01\x18\x1f\n\x0f\n\x07\x04\
    \x04\x03\x12\x02\0\x03\x12\x04\xf9\x01\"#\n\x0e\n\x06\x04\x04\x03\x12\
    \x02\x01\x12\x04\xfa\x01\x08!\n\x0f\n\x07\x04\x04\x03\x12\x02\x01\x04\
    \x12\x04\xfa\x01\x08\x10\n\x0f\n\x07\x04\x04\x03\x12\x02\x01\x05\x12\x04\
    \xfa\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x12\x02\x01\x01\x12\x04\xfa\x01\
    \x18\x1c\n\x0f\n\x07\x04\x04\x03\x12\x02\x01\x03\x12\x04\xfa\x01\x1f\x20\
    \n\x0e\n\x06\x04\x04\x03\x12\x02\x02\x12\x04\xfb\x01\x08!\n\x0f\n\x07\
    \x04\x04\x03\x12\x02\x02\x04\x12\x04\xfb\x01\x08\x10\n\x0f\n\x07\x04\x04\
    \x03\x12\x02\x02\x05\x12\x04\xfb\x01\x11\x17\n\x0f\n\x07\x04\x04\x03\x12\
    \x02\x02\x01\x12\x04\xfb\x01\x18\x1c\n\x0f\n\x07\x04\x04\x03\x12\x02\x02\
    \x03\x12\x04\xfb\x01\x1f\x20\nE\n\x04\x04\x04\x03\x13\x12\x06\x81\x02\
    \x04\x86\x02\x05\x1a5*\n\x20Structure\x20representing\x20creation\x20of\
    \x20a\x20new\x20account.\n\n\r\n\x05\x04\x04\x03\x13\x01\x12\x04\x81\x02\
    \x0c\x1f\n\x0e\n\x06\x04\x04\x03\x13\x02\0\x12\x04\x82\x02\x08$\n\x0f\n\
    \x07\x04\x04\x03\x13\x02\0\x04\x12\x04\x82\x02\x08\x10\n\x0f\n\x07\x04\
    \x04\x03\x13\x02\0\x05\x12\x04\x82\x02\x11\x17\n\x0f\n\x07\x04\x04\x03\
    \x13\x02\0\x01\x12\x04\x82\x02\x18\x1f\n\x0f\n\x07\x04\x04\x03\x13\x02\0\
    \x03\x12\x04\x82\x02\"#\n\x0e\n\x06\x04\x04\x03\x13\x02\x01\x12\x04\x83\
    \x02\x08!\n\x0f\n\x07\x04\x04\x03\x13\x02\x01\x04\x12\x04\x83\x02\x08\
    \x10\n\x0f\n\x07\x04\x04\x03\x13\x02\x01\x05\x12\x04\x83\x02\x11\x17\n\
    \x0f\n\x07\x04\x04\x03\x13\x02\x01\x01\x12\x04\x83\x02\x18\x1c\n\x0f\n\
    \x07\x04\x04\x03\x13\x02\x01\x03\x12\x04\x83\x02\x1f\x20\n\x0e\n\x06\x04\
    \x04\x03\x13\x02\x02\x12\x04\x84\x02\x08,\n\x0f\n\x07\x04\x04\x03\x13\
    \x02\x02\x04\x12\x04\x84\x02\x08\x10\n\x0f\n\x07\x04\x04\x03\x13\x02\x02\
    \x06\x12\x04\x84\x02\x11!\n\x0f\n\x07\x04\x04\x03\x13\x02\x02\x01\x12\
    \x04\x84\x02\"'\n\x0f\n\x07\x04\x04\x03\x13\x02\x02\x03\x12\x04\x84\x02*\
    +\n\x0e\n\x06\x04\x04\x03\x13\x02\x03\x12\x04\x85\x02\x08-\n\x0f\n\x07\
    \x04\x04\x03\x13\x02\x03\x04\x12\x04\x85\x02\x08\x10\n\x0f\n\x07\x04\x04\
    \x03\x13\x02\x03\x06\x12\x04\x85\x02\x11!\n\x0f\n\x07\x04\x04\x03\x13\
    \x02\x03\x01\x12\x04\x85\x02\"(\n\x0f\n\x07\x04\x04\x03\x13\x02\x03\x03\
    \x12\x04\x85\x02+,\nI\n\x04\x04\x04\x03\x14\x12\x06\x8b\x02\x04\x8e\x02\
    \x05\x1a9*\n\x20Structure\x20representing\x20actions\x20not\x20implement\
    ed\x20above.\n\n\r\n\x05\x04\x04\x03\x14\x01\x12\x04\x8b\x02\x0c\x1c\n\
    \x0e\n\x06\x04\x04\x03\x14\x02\0\x12\x04\x8c\x02\x08&\n\x0f\n\x07\x04\
    \x04\x03\x14\x02\0\x04\x12\x04\x8c\x02\x08\x10\n\x0f\n\x07\x04\x04\x03\
    \x14\x02\0\x05\x12\x04\x8c\x02\x11\x17\n\x0f\n\x07\x04\x04\x03\x14\x02\0\
    \x01\x12\x04\x8c\x02\x18!\n\x0f\n\x07\x04\x04\x03\x14\x02\0\x03\x12\x04\
    \x8c\x02$%\n\x0e\n\x06\x04\x04\x03\x14\x02\x01\x12\x04\x8d\x02\x08&\n\
    \x0f\n\x07\x04\x04\x03\x14\x02\x01\x04\x12\x04\x8d\x02\x08\x10\n\x0f\n\
    \x07\x04\x04\x03\x14\x02\x01\x05\x12\x04\x8d\x02\x11\x16\n\x0f\n\x07\x04\
    \x04\x03\x14\x02\x01\x01\x12\x04\x8d\x02\x17!\n\x0f\n\x07\x04\x04\x03\
    \x14\x02\x01\x03\x12\x04\x8d\x02$%\n\xa6\x01\n\x02\x04\x05\x12\x06\x96\
    \x02\0\x98\x02\x01\x1a\x97\x01*\n\x20Response:\x20Device\x20returns\x20t\
    he\x20signature.\n\x20The\x20signature_*\x20fields\x20contain\x20the\x20\
    computed\x20transaction\x20signature.\x20All\x20three\x20fields\x20will\
    \x20be\x20present.\n\x20@end\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x96\x02\
    \x08\x13\n\"\n\x04\x04\x05\x02\0\x12\x04\x97\x02\x04\"\"\x14\x20Computed\
    \x20signature\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x97\x02\x04\x0c\n\r\
    \n\x05\x04\x05\x02\0\x05\x12\x04\x97\x02\r\x13\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\x97\x02\x14\x1d\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x97\x02\
    \x20!\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
