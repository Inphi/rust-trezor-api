// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-monero.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry {
    // message fields
    pub outputs: ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry>,
    real_output: ::std::option::Option<u64>,
    real_out_tx_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub real_out_additional_tx_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    real_output_in_tx_index: ::std::option::Option<u64>,
    amount: ::std::option::Option<u64>,
    rct: ::std::option::Option<bool>,
    mask: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub multisig_kLRki: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry_MoneroMultisigKLRki>,
    subaddr_minor: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry {
    fn default() -> &'a MoneroTransactionSourceEntry {
        <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry {
    pub fn new() -> MoneroTransactionSourceEntry {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;


    pub fn get_outputs(&self) -> &[MoneroTransactionSourceEntry_MoneroOutputEntry] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // optional uint64 real_output = 2;


    pub fn get_real_output(&self) -> u64 {
        self.real_output.unwrap_or(0)
    }
    pub fn clear_real_output(&mut self) {
        self.real_output = ::std::option::Option::None;
    }

    pub fn has_real_output(&self) -> bool {
        self.real_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output(&mut self, v: u64) {
        self.real_output = ::std::option::Option::Some(v);
    }

    // optional bytes real_out_tx_key = 3;


    pub fn get_real_out_tx_key(&self) -> &[u8] {
        match self.real_out_tx_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_real_out_tx_key(&mut self) {
        self.real_out_tx_key.clear();
    }

    pub fn has_real_out_tx_key(&self) -> bool {
        self.real_out_tx_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_tx_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.real_out_tx_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_out_tx_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.real_out_tx_key.is_none() {
            self.real_out_tx_key.set_default();
        }
        self.real_out_tx_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_out_tx_key(&mut self) -> ::std::vec::Vec<u8> {
        self.real_out_tx_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes real_out_additional_tx_keys = 4;


    pub fn get_real_out_additional_tx_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.real_out_additional_tx_keys
    }
    pub fn clear_real_out_additional_tx_keys(&mut self) {
        self.real_out_additional_tx_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_real_out_additional_tx_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.real_out_additional_tx_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_real_out_additional_tx_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.real_out_additional_tx_keys
    }

    // Take field
    pub fn take_real_out_additional_tx_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.real_out_additional_tx_keys, ::protobuf::RepeatedField::new())
    }

    // optional uint64 real_output_in_tx_index = 5;


    pub fn get_real_output_in_tx_index(&self) -> u64 {
        self.real_output_in_tx_index.unwrap_or(0)
    }
    pub fn clear_real_output_in_tx_index(&mut self) {
        self.real_output_in_tx_index = ::std::option::Option::None;
    }

    pub fn has_real_output_in_tx_index(&self) -> bool {
        self.real_output_in_tx_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output_in_tx_index(&mut self, v: u64) {
        self.real_output_in_tx_index = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool rct = 7;


    pub fn get_rct(&self) -> bool {
        self.rct.unwrap_or(false)
    }
    pub fn clear_rct(&mut self) {
        self.rct = ::std::option::Option::None;
    }

    pub fn has_rct(&self) -> bool {
        self.rct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rct(&mut self, v: bool) {
        self.rct = ::std::option::Option::Some(v);
    }

    // optional bytes mask = 8;


    pub fn get_mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;


    pub fn get_multisig_kLRki(&self) -> &MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        self.multisig_kLRki.as_ref().unwrap_or_else(|| <MoneroTransactionSourceEntry_MoneroMultisigKLRki as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multisig_kLRki(&mut self) {
        self.multisig_kLRki.clear();
    }

    pub fn has_multisig_kLRki(&self) -> bool {
        self.multisig_kLRki.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multisig_kLRki(&mut self, v: MoneroTransactionSourceEntry_MoneroMultisigKLRki) {
        self.multisig_kLRki = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multisig_kLRki(&mut self) -> &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        if self.multisig_kLRki.is_none() {
            self.multisig_kLRki.set_default();
        }
        self.multisig_kLRki.as_mut().unwrap()
    }

    // Take field
    pub fn take_multisig_kLRki(&mut self) -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        self.multisig_kLRki.take().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroMultisigKLRki::new())
    }

    // optional uint32 subaddr_minor = 10;


    pub fn get_subaddr_minor(&self) -> u32 {
        self.subaddr_minor.unwrap_or(0)
    }
    pub fn clear_subaddr_minor(&mut self) {
        self.subaddr_minor = ::std::option::Option::None;
    }

    pub fn has_subaddr_minor(&self) -> bool {
        self.subaddr_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subaddr_minor(&mut self, v: u32) {
        self.subaddr_minor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multisig_kLRki {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.real_output = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.real_out_tx_key)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.real_out_additional_tx_keys)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.real_output_in_tx_index = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rct = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mask)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multisig_kLRki)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.subaddr_minor = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.real_output {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.real_out_tx_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.real_out_additional_tx_keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.real_output_in_tx_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rct {
            my_size += 2;
        }
        if let Some(ref v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.multisig_kLRki.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.subaddr_minor {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.real_output {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.real_out_tx_key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.real_out_additional_tx_keys {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.real_output_in_tx_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.rct {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.multisig_kLRki.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.subaddr_minor {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry {
        MoneroTransactionSourceEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry>>(
                "outputs",
                |m: &MoneroTransactionSourceEntry| { &m.outputs },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "real_output",
                |m: &MoneroTransactionSourceEntry| { &m.real_output },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "real_out_tx_key",
                |m: &MoneroTransactionSourceEntry| { &m.real_out_tx_key },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_tx_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "real_out_additional_tx_keys",
                |m: &MoneroTransactionSourceEntry| { &m.real_out_additional_tx_keys },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_additional_tx_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "real_output_in_tx_index",
                |m: &MoneroTransactionSourceEntry| { &m.real_output_in_tx_index },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output_in_tx_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount",
                |m: &MoneroTransactionSourceEntry| { &m.amount },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rct",
                |m: &MoneroTransactionSourceEntry| { &m.rct },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.rct },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "mask",
                |m: &MoneroTransactionSourceEntry| { &m.mask },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroMultisigKLRki>>(
                "multisig_kLRki",
                |m: &MoneroTransactionSourceEntry| { &m.multisig_kLRki },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.multisig_kLRki },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "subaddr_minor",
                |m: &MoneroTransactionSourceEntry| { &m.subaddr_minor },
                |m: &mut MoneroTransactionSourceEntry| { &mut m.subaddr_minor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSourceEntry>(
                "MoneroTransactionSourceEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSourceEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSourceEntry::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry {
    fn clear(&mut self) {
        self.outputs.clear();
        self.real_output = ::std::option::Option::None;
        self.real_out_tx_key.clear();
        self.real_out_additional_tx_keys.clear();
        self.real_output_in_tx_index = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rct = ::std::option::Option::None;
        self.mask.clear();
        self.multisig_kLRki.clear();
        self.subaddr_minor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroOutputEntry {
    // message fields
    idx: ::std::option::Option<u64>,
    pub key: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroOutputEntry {
        <MoneroTransactionSourceEntry_MoneroOutputEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroOutputEntry {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry {
        ::std::default::Default::default()
    }

    // optional uint64 idx = 1;


    pub fn get_idx(&self) -> u64 {
        self.idx.unwrap_or(0)
    }
    pub fn clear_idx(&mut self) {
        self.idx = ::std::option::Option::None;
    }

    pub fn has_idx(&self) -> bool {
        self.idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idx(&mut self, v: u64) {
        self.idx = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic key = 2;


    pub fn get_key(&self) -> &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        self.key.as_ref().unwrap_or_else(|| <MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        self.key.take().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idx {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry {
        MoneroTransactionSourceEntry_MoneroOutputEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "idx",
                |m: &MoneroTransactionSourceEntry_MoneroOutputEntry| { &m.idx },
                |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>>(
                "key",
                |m: &MoneroTransactionSourceEntry_MoneroOutputEntry| { &m.key },
                |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSourceEntry_MoneroOutputEntry>(
                "MoneroTransactionSourceEntry.MoneroOutputEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroOutputEntry {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSourceEntry_MoneroOutputEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSourceEntry_MoneroOutputEntry::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn clear(&mut self) {
        self.idx = ::std::option::Option::None;
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    // message fields
    dest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    commitment: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        <MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        ::std::default::Default::default()
    }

    // optional bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        match self.dest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dest.is_none() {
            self.dest.set_default();
        }
        self.dest.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        self.dest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes commitment = 2;


    pub fn get_commitment(&self) -> &[u8] {
        match self.commitment.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_commitment(&mut self) {
        self.commitment.clear();
    }

    pub fn has_commitment(&self) -> bool {
        self.commitment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.commitment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.commitment.is_none() {
            self.commitment.set_default();
        }
        self.commitment.as_mut().unwrap()
    }

    // Take field
    pub fn take_commitment(&mut self) -> ::std::vec::Vec<u8> {
        self.commitment.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.commitment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.commitment.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dest.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.commitment.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dest",
                |m: &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic| { &m.dest },
                |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic| { &mut m.dest },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "commitment",
                |m: &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic| { &m.commitment },
                |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic| { &mut m.commitment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic>(
                "MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    fn clear(&mut self) {
        self.dest.clear();
        self.commitment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKeyPublic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    // message fields
    K: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    L: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    R: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ki: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        <MoneroTransactionSourceEntry_MoneroMultisigKLRki as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        ::std::default::Default::default()
    }

    // optional bytes K = 1;


    pub fn get_K(&self) -> &[u8] {
        match self.K.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_K(&mut self) {
        self.K.clear();
    }

    pub fn has_K(&self) -> bool {
        self.K.is_some()
    }

    // Param is passed by value, moved
    pub fn set_K(&mut self, v: ::std::vec::Vec<u8>) {
        self.K = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_K(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.K.is_none() {
            self.K.set_default();
        }
        self.K.as_mut().unwrap()
    }

    // Take field
    pub fn take_K(&mut self) -> ::std::vec::Vec<u8> {
        self.K.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes L = 2;


    pub fn get_L(&self) -> &[u8] {
        match self.L.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_L(&mut self) {
        self.L.clear();
    }

    pub fn has_L(&self) -> bool {
        self.L.is_some()
    }

    // Param is passed by value, moved
    pub fn set_L(&mut self, v: ::std::vec::Vec<u8>) {
        self.L = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_L(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.L.is_none() {
            self.L.set_default();
        }
        self.L.as_mut().unwrap()
    }

    // Take field
    pub fn take_L(&mut self) -> ::std::vec::Vec<u8> {
        self.L.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes R = 3;


    pub fn get_R(&self) -> &[u8] {
        match self.R.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_R(&mut self) {
        self.R.clear();
    }

    pub fn has_R(&self) -> bool {
        self.R.is_some()
    }

    // Param is passed by value, moved
    pub fn set_R(&mut self, v: ::std::vec::Vec<u8>) {
        self.R = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_R(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.R.is_none() {
            self.R.set_default();
        }
        self.R.as_mut().unwrap()
    }

    // Take field
    pub fn take_R(&mut self) -> ::std::vec::Vec<u8> {
        self.R.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ki = 4;


    pub fn get_ki(&self) -> &[u8] {
        match self.ki.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ki(&mut self) {
        self.ki.clear();
    }

    pub fn has_ki(&self) -> bool {
        self.ki.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ki(&mut self, v: ::std::vec::Vec<u8>) {
        self.ki = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ki(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ki.is_none() {
            self.ki.set_default();
        }
        self.ki.as_mut().unwrap()
    }

    // Take field
    pub fn take_ki(&mut self) -> ::std::vec::Vec<u8> {
        self.ki.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.K)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.L)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.R)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ki)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.K.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.L.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.R.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.ki.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.K.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.L.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.R.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.ki.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        MoneroTransactionSourceEntry_MoneroMultisigKLRki::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "K",
                |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.K },
                |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.K },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "L",
                |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.L },
                |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.L },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "R",
                |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.R },
                |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.R },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ki",
                |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.ki },
                |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.ki },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSourceEntry_MoneroMultisigKLRki>(
                "MoneroTransactionSourceEntry.MoneroMultisigKLRki",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSourceEntry_MoneroMultisigKLRki> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSourceEntry_MoneroMultisigKLRki::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn clear(&mut self) {
        self.K.clear();
        self.L.clear();
        self.R.clear();
        self.ki.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionDestinationEntry {
    // message fields
    amount: ::std::option::Option<u64>,
    pub addr: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>,
    is_subaddress: ::std::option::Option<bool>,
    original: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    is_integrated: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry {
    fn default() -> &'a MoneroTransactionDestinationEntry {
        <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry {
    pub fn new() -> MoneroTransactionDestinationEntry {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;


    pub fn get_addr(&self) -> &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        self.addr.as_ref().unwrap_or_else(|| <MoneroTransactionDestinationEntry_MoneroAccountPublicAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: MoneroTransactionDestinationEntry_MoneroAccountPublicAddress) {
        self.addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        self.addr.take().unwrap_or_else(|| MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new())
    }

    // optional bool is_subaddress = 3;


    pub fn get_is_subaddress(&self) -> bool {
        self.is_subaddress.unwrap_or(false)
    }
    pub fn clear_is_subaddress(&mut self) {
        self.is_subaddress = ::std::option::Option::None;
    }

    pub fn has_is_subaddress(&self) -> bool {
        self.is_subaddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subaddress(&mut self, v: bool) {
        self.is_subaddress = ::std::option::Option::Some(v);
    }

    // optional bytes original = 4;


    pub fn get_original(&self) -> &[u8] {
        match self.original.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_original(&mut self) {
        self.original.clear();
    }

    pub fn has_original(&self) -> bool {
        self.original.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original(&mut self, v: ::std::vec::Vec<u8>) {
        self.original = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.original.is_none() {
            self.original.set_default();
        }
        self.original.as_mut().unwrap()
    }

    // Take field
    pub fn take_original(&mut self) -> ::std::vec::Vec<u8> {
        self.original.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool is_integrated = 5;


    pub fn get_is_integrated(&self) -> bool {
        self.is_integrated.unwrap_or(false)
    }
    pub fn clear_is_integrated(&mut self) {
        self.is_integrated = ::std::option::Option::None;
    }

    pub fn has_is_integrated(&self) -> bool {
        self.is_integrated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_integrated(&mut self, v: bool) {
        self.is_integrated = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addr)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_subaddress = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.original)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_integrated = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.is_subaddress {
            my_size += 2;
        }
        if let Some(ref v) = self.original.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.is_integrated {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.addr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.is_subaddress {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.original.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.is_integrated {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionDestinationEntry {
        MoneroTransactionDestinationEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "amount",
                |m: &MoneroTransactionDestinationEntry| { &m.amount },
                |m: &mut MoneroTransactionDestinationEntry| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>>(
                "addr",
                |m: &MoneroTransactionDestinationEntry| { &m.addr },
                |m: &mut MoneroTransactionDestinationEntry| { &mut m.addr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_subaddress",
                |m: &MoneroTransactionDestinationEntry| { &m.is_subaddress },
                |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_subaddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "original",
                |m: &MoneroTransactionDestinationEntry| { &m.original },
                |m: &mut MoneroTransactionDestinationEntry| { &mut m.original },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_integrated",
                |m: &MoneroTransactionDestinationEntry| { &m.is_integrated },
                |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_integrated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionDestinationEntry>(
                "MoneroTransactionDestinationEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionDestinationEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionDestinationEntry::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionDestinationEntry {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.addr.clear();
        self.is_subaddress = ::std::option::Option::None;
        self.original.clear();
        self.is_integrated = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionDestinationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    // message fields
    spend_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    view_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn default() -> &'a MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        <MoneroTransactionDestinationEntry_MoneroAccountPublicAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    pub fn new() -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        ::std::default::Default::default()
    }

    // optional bytes spend_public_key = 1;


    pub fn get_spend_public_key(&self) -> &[u8] {
        match self.spend_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_public_key(&mut self) {
        self.spend_public_key.clear();
    }

    pub fn has_spend_public_key(&self) -> bool {
        self.spend_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_public_key.is_none() {
            self.spend_public_key.set_default();
        }
        self.spend_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes view_public_key = 2;


    pub fn get_view_public_key(&self) -> &[u8] {
        match self.view_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_view_public_key(&mut self) {
        self.view_public_key.clear();
    }

    pub fn has_view_public_key(&self) -> bool {
        self.view_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.view_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.view_public_key.is_none() {
            self.view_public_key.set_default();
        }
        self.view_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.view_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.spend_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.spend_public_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spend_public_key",
                |m: &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &m.spend_public_key },
                |m: &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &mut m.spend_public_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "view_public_key",
                |m: &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &m.view_public_key },
                |m: &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &mut m.view_public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(
                "MoneroTransactionDestinationEntry.MoneroAccountPublicAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn clear(&mut self) {
        self.spend_public_key.clear();
        self.view_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionRsigData {
    // message fields
    rsig_type: ::std::option::Option<u32>,
    offload_type: ::std::option::Option<u32>,
    pub grouping: ::std::vec::Vec<u64>,
    mask: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub rsig_parts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    bp_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionRsigData {
    fn default() -> &'a MoneroTransactionRsigData {
        <MoneroTransactionRsigData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionRsigData {
    pub fn new() -> MoneroTransactionRsigData {
        ::std::default::Default::default()
    }

    // optional uint32 rsig_type = 1;


    pub fn get_rsig_type(&self) -> u32 {
        self.rsig_type.unwrap_or(0)
    }
    pub fn clear_rsig_type(&mut self) {
        self.rsig_type = ::std::option::Option::None;
    }

    pub fn has_rsig_type(&self) -> bool {
        self.rsig_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_type(&mut self, v: u32) {
        self.rsig_type = ::std::option::Option::Some(v);
    }

    // optional uint32 offload_type = 2;


    pub fn get_offload_type(&self) -> u32 {
        self.offload_type.unwrap_or(0)
    }
    pub fn clear_offload_type(&mut self) {
        self.offload_type = ::std::option::Option::None;
    }

    pub fn has_offload_type(&self) -> bool {
        self.offload_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offload_type(&mut self, v: u32) {
        self.offload_type = ::std::option::Option::Some(v);
    }

    // repeated uint64 grouping = 3;


    pub fn get_grouping(&self) -> &[u64] {
        &self.grouping
    }
    pub fn clear_grouping(&mut self) {
        self.grouping.clear();
    }

    // Param is passed by value, moved
    pub fn set_grouping(&mut self, v: ::std::vec::Vec<u64>) {
        self.grouping = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grouping(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.grouping
    }

    // Take field
    pub fn take_grouping(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.grouping, ::std::vec::Vec::new())
    }

    // optional bytes mask = 4;


    pub fn get_mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rsig = 5;


    pub fn get_rsig(&self) -> &[u8] {
        match self.rsig.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rsig(&mut self) {
        self.rsig.clear();
    }

    pub fn has_rsig(&self) -> bool {
        self.rsig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig(&mut self, v: ::std::vec::Vec<u8>) {
        self.rsig = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rsig.is_none() {
            self.rsig.set_default();
        }
        self.rsig.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig(&mut self) -> ::std::vec::Vec<u8> {
        self.rsig.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes rsig_parts = 6;


    pub fn get_rsig_parts(&self) -> &[::std::vec::Vec<u8>] {
        &self.rsig_parts
    }
    pub fn clear_rsig_parts(&mut self) {
        self.rsig_parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_rsig_parts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.rsig_parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rsig_parts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.rsig_parts
    }

    // Take field
    pub fn take_rsig_parts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.rsig_parts, ::protobuf::RepeatedField::new())
    }

    // optional uint32 bp_version = 7;


    pub fn get_bp_version(&self) -> u32 {
        self.bp_version.unwrap_or(0)
    }
    pub fn clear_bp_version(&mut self) {
        self.bp_version = ::std::option::Option::None;
    }

    pub fn has_bp_version(&self) -> bool {
        self.bp_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bp_version(&mut self, v: u32) {
        self.bp_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionRsigData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rsig_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offload_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.grouping)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mask)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rsig)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.rsig_parts)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bp_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rsig_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offload_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.grouping {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.rsig.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        for value in &self.rsig_parts {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if let Some(v) = self.bp_version {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rsig_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.offload_type {
            os.write_uint32(2, v)?;
        }
        for v in &self.grouping {
            os.write_uint64(3, *v)?;
        };
        if let Some(ref v) = self.mask.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.rsig.as_ref() {
            os.write_bytes(5, &v)?;
        }
        for v in &self.rsig_parts {
            os.write_bytes(6, &v)?;
        };
        if let Some(v) = self.bp_version {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionRsigData {
        MoneroTransactionRsigData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rsig_type",
                |m: &MoneroTransactionRsigData| { &m.rsig_type },
                |m: &mut MoneroTransactionRsigData| { &mut m.rsig_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "offload_type",
                |m: &MoneroTransactionRsigData| { &m.offload_type },
                |m: &mut MoneroTransactionRsigData| { &mut m.offload_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "grouping",
                |m: &MoneroTransactionRsigData| { &m.grouping },
                |m: &mut MoneroTransactionRsigData| { &mut m.grouping },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "mask",
                |m: &MoneroTransactionRsigData| { &m.mask },
                |m: &mut MoneroTransactionRsigData| { &mut m.mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rsig",
                |m: &MoneroTransactionRsigData| { &m.rsig },
                |m: &mut MoneroTransactionRsigData| { &mut m.rsig },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rsig_parts",
                |m: &MoneroTransactionRsigData| { &m.rsig_parts },
                |m: &mut MoneroTransactionRsigData| { &mut m.rsig_parts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bp_version",
                |m: &MoneroTransactionRsigData| { &m.bp_version },
                |m: &mut MoneroTransactionRsigData| { &mut m.bp_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionRsigData>(
                "MoneroTransactionRsigData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionRsigData {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionRsigData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionRsigData::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionRsigData {
    fn clear(&mut self) {
        self.rsig_type = ::std::option::Option::None;
        self.offload_type = ::std::option::Option::None;
        self.grouping.clear();
        self.mask.clear();
        self.rsig.clear();
        self.rsig_parts.clear();
        self.bp_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionRsigData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionRsigData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetAddress {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    network_type: ::std::option::Option<u32>,
    account: ::std::option::Option<u32>,
    minor: ::std::option::Option<u32>,
    payment_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetAddress {
    fn default() -> &'a MoneroGetAddress {
        <MoneroGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetAddress {
    pub fn new() -> MoneroGetAddress {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }

    // optional uint32 network_type = 3;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional uint32 account = 4;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint32 minor = 5;


    pub fn get_minor(&self) -> u32 {
        self.minor.unwrap_or(0)
    }
    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = ::std::option::Option::Some(v);
    }

    // optional bytes payment_id = 6;


    pub fn get_payment_id(&self) -> &[u8] {
        match self.payment_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payment_id(&mut self) {
        self.payment_id.clear();
    }

    pub fn has_payment_id(&self) -> bool {
        self.payment_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_id.is_none() {
            self.payment_id.set_default();
        }
        self.payment_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroGetAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minor = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payment_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.minor {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetAddress {
        MoneroGetAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroGetAddress| { &m.address_n },
                |m: &mut MoneroGetAddress| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_display",
                |m: &MoneroGetAddress| { &m.show_display },
                |m: &mut MoneroGetAddress| { &mut m.show_display },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroGetAddress| { &m.network_type },
                |m: &mut MoneroGetAddress| { &mut m.network_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account",
                |m: &MoneroGetAddress| { &m.account },
                |m: &mut MoneroGetAddress| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minor",
                |m: &MoneroGetAddress| { &m.minor },
                |m: &mut MoneroGetAddress| { &mut m.minor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_id",
                |m: &MoneroGetAddress| { &m.payment_id },
                |m: &mut MoneroGetAddress| { &mut m.payment_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroGetAddress>(
                "MoneroGetAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroGetAddress {
        static instance: ::protobuf::rt::LazyV2<MoneroGetAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroGetAddress::new)
    }
}

impl ::protobuf::Clear for MoneroGetAddress {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.payment_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroAddress {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroAddress {
    fn default() -> &'a MoneroAddress {
        <MoneroAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroAddress {
    pub fn new() -> MoneroAddress {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroAddress {
        MoneroAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &MoneroAddress| { &m.address },
                |m: &mut MoneroAddress| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroAddress>(
                "MoneroAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroAddress {
        static instance: ::protobuf::rt::LazyV2<MoneroAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroAddress::new)
    }
}

impl ::protobuf::Clear for MoneroAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetWatchKey {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetWatchKey {
    fn default() -> &'a MoneroGetWatchKey {
        <MoneroGetWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetWatchKey {
    pub fn new() -> MoneroGetWatchKey {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 2;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroGetWatchKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetWatchKey {
        MoneroGetWatchKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroGetWatchKey| { &m.address_n },
                |m: &mut MoneroGetWatchKey| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroGetWatchKey| { &m.network_type },
                |m: &mut MoneroGetWatchKey| { &mut m.network_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroGetWatchKey>(
                "MoneroGetWatchKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroGetWatchKey {
        static instance: ::protobuf::rt::LazyV2<MoneroGetWatchKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroGetWatchKey::new)
    }
}

impl ::protobuf::Clear for MoneroGetWatchKey {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetWatchKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroWatchKey {
    // message fields
    watch_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroWatchKey {
    fn default() -> &'a MoneroWatchKey {
        <MoneroWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroWatchKey {
    pub fn new() -> MoneroWatchKey {
        ::std::default::Default::default()
    }

    // optional bytes watch_key = 1;


    pub fn get_watch_key(&self) -> &[u8] {
        match self.watch_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_watch_key(&mut self) {
        self.watch_key.clear();
    }

    pub fn has_watch_key(&self) -> bool {
        self.watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watch_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.watch_key.is_none() {
            self.watch_key.set_default();
        }
        self.watch_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_watch_key(&mut self) -> ::std::vec::Vec<u8> {
        self.watch_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroWatchKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.watch_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.watch_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.watch_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroWatchKey {
        MoneroWatchKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "watch_key",
                |m: &MoneroWatchKey| { &m.watch_key },
                |m: &mut MoneroWatchKey| { &mut m.watch_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &MoneroWatchKey| { &m.address },
                |m: &mut MoneroWatchKey| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroWatchKey>(
                "MoneroWatchKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroWatchKey {
        static instance: ::protobuf::rt::LazyV2<MoneroWatchKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroWatchKey::new)
    }
}

impl ::protobuf::Clear for MoneroWatchKey {
    fn clear(&mut self) {
        self.watch_key.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroWatchKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitRequest {
    // message fields
    version: ::std::option::Option<u32>,
    pub address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    pub tsx_data: ::protobuf::SingularPtrField<MoneroTransactionInitRequest_MoneroTransactionData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest {
    fn default() -> &'a MoneroTransactionInitRequest {
        <MoneroTransactionInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest {
    pub fn new() -> MoneroTransactionInitRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // repeated uint32 address_n = 2;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 3;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;


    pub fn get_tsx_data(&self) -> &MoneroTransactionInitRequest_MoneroTransactionData {
        self.tsx_data.as_ref().unwrap_or_else(|| <MoneroTransactionInitRequest_MoneroTransactionData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tsx_data(&mut self) {
        self.tsx_data.clear();
    }

    pub fn has_tsx_data(&self) -> bool {
        self.tsx_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tsx_data(&mut self, v: MoneroTransactionInitRequest_MoneroTransactionData) {
        self.tsx_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tsx_data(&mut self) -> &mut MoneroTransactionInitRequest_MoneroTransactionData {
        if self.tsx_data.is_none() {
            self.tsx_data.set_default();
        }
        self.tsx_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_tsx_data(&mut self) -> MoneroTransactionInitRequest_MoneroTransactionData {
        self.tsx_data.take().unwrap_or_else(|| MoneroTransactionInitRequest_MoneroTransactionData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tsx_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tsx_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tsx_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.tsx_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitRequest {
        MoneroTransactionInitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &MoneroTransactionInitRequest| { &m.version },
                |m: &mut MoneroTransactionInitRequest| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroTransactionInitRequest| { &m.address_n },
                |m: &mut MoneroTransactionInitRequest| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroTransactionInitRequest| { &m.network_type },
                |m: &mut MoneroTransactionInitRequest| { &mut m.network_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionInitRequest_MoneroTransactionData>>(
                "tsx_data",
                |m: &MoneroTransactionInitRequest| { &m.tsx_data },
                |m: &mut MoneroTransactionInitRequest| { &mut m.tsx_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInitRequest>(
                "MoneroTransactionInitRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInitRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInitRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInitRequest {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.tsx_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitRequest_MoneroTransactionData {
    // message fields
    version: ::std::option::Option<u32>,
    payment_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unlock_time: ::std::option::Option<u64>,
    pub outputs: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>,
    pub change_dts: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry>,
    num_inputs: ::std::option::Option<u32>,
    mixin: ::std::option::Option<u32>,
    fee: ::std::option::Option<u64>,
    account: ::std::option::Option<u32>,
    pub minor_indices: ::std::vec::Vec<u32>,
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    pub integrated_indices: ::std::vec::Vec<u32>,
    client_version: ::std::option::Option<u32>,
    hard_fork: ::std::option::Option<u32>,
    monero_version: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest_MoneroTransactionData {
    fn default() -> &'a MoneroTransactionInitRequest_MoneroTransactionData {
        <MoneroTransactionInitRequest_MoneroTransactionData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest_MoneroTransactionData {
    pub fn new() -> MoneroTransactionInitRequest_MoneroTransactionData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes payment_id = 2;


    pub fn get_payment_id(&self) -> &[u8] {
        match self.payment_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payment_id(&mut self) {
        self.payment_id.clear();
    }

    pub fn has_payment_id(&self) -> bool {
        self.payment_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_id.is_none() {
            self.payment_id.set_default();
        }
        self.payment_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 unlock_time = 3;


    pub fn get_unlock_time(&self) -> u64 {
        self.unlock_time.unwrap_or(0)
    }
    pub fn clear_unlock_time(&mut self) {
        self.unlock_time = ::std::option::Option::None;
    }

    pub fn has_unlock_time(&self) -> bool {
        self.unlock_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_time(&mut self, v: u64) {
        self.unlock_time = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;


    pub fn get_outputs(&self) -> &[MoneroTransactionDestinationEntry] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;


    pub fn get_change_dts(&self) -> &MoneroTransactionDestinationEntry {
        self.change_dts.as_ref().unwrap_or_else(|| <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_change_dts(&mut self) {
        self.change_dts.clear();
    }

    pub fn has_change_dts(&self) -> bool {
        self.change_dts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_dts(&mut self, v: MoneroTransactionDestinationEntry) {
        self.change_dts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_dts(&mut self) -> &mut MoneroTransactionDestinationEntry {
        if self.change_dts.is_none() {
            self.change_dts.set_default();
        }
        self.change_dts.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_dts(&mut self) -> MoneroTransactionDestinationEntry {
        self.change_dts.take().unwrap_or_else(|| MoneroTransactionDestinationEntry::new())
    }

    // optional uint32 num_inputs = 6;


    pub fn get_num_inputs(&self) -> u32 {
        self.num_inputs.unwrap_or(0)
    }
    pub fn clear_num_inputs(&mut self) {
        self.num_inputs = ::std::option::Option::None;
    }

    pub fn has_num_inputs(&self) -> bool {
        self.num_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_inputs(&mut self, v: u32) {
        self.num_inputs = ::std::option::Option::Some(v);
    }

    // optional uint32 mixin = 7;


    pub fn get_mixin(&self) -> u32 {
        self.mixin.unwrap_or(0)
    }
    pub fn clear_mixin(&mut self) {
        self.mixin = ::std::option::Option::None;
    }

    pub fn has_mixin(&self) -> bool {
        self.mixin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mixin(&mut self, v: u32) {
        self.mixin = ::std::option::Option::Some(v);
    }

    // optional uint64 fee = 8;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint32 account = 9;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // repeated uint32 minor_indices = 10;


    pub fn get_minor_indices(&self) -> &[u32] {
        &self.minor_indices
    }
    pub fn clear_minor_indices(&mut self) {
        self.minor_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_minor_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.minor_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minor_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.minor_indices
    }

    // Take field
    pub fn take_minor_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.minor_indices, ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 11;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // repeated uint32 integrated_indices = 12;


    pub fn get_integrated_indices(&self) -> &[u32] {
        &self.integrated_indices
    }
    pub fn clear_integrated_indices(&mut self) {
        self.integrated_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_integrated_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.integrated_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_integrated_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.integrated_indices
    }

    // Take field
    pub fn take_integrated_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.integrated_indices, ::std::vec::Vec::new())
    }

    // optional uint32 client_version = 13;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 hard_fork = 14;


    pub fn get_hard_fork(&self) -> u32 {
        self.hard_fork.unwrap_or(0)
    }
    pub fn clear_hard_fork(&mut self) {
        self.hard_fork = ::std::option::Option::None;
    }

    pub fn has_hard_fork(&self) -> bool {
        self.hard_fork.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hard_fork(&mut self, v: u32) {
        self.hard_fork = ::std::option::Option::Some(v);
    }

    // optional bytes monero_version = 15;


    pub fn get_monero_version(&self) -> &[u8] {
        match self.monero_version.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_monero_version(&mut self) {
        self.monero_version.clear();
    }

    pub fn has_monero_version(&self) -> bool {
        self.monero_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_monero_version(&mut self, v: ::std::vec::Vec<u8>) {
        self.monero_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monero_version(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.monero_version.is_none() {
            self.monero_version.set_default();
        }
        self.monero_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_monero_version(&mut self) -> ::std::vec::Vec<u8> {
        self.monero_version.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest_MoneroTransactionData {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.change_dts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payment_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unlock_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.change_dts)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inputs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mixin = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.minor_indices)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.integrated_indices)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.hard_fork = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.monero_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.unlock_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.change_dts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.num_inputs {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mixin {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.minor_indices {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.integrated_indices {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hard_fork {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.monero_version.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.unlock_time {
            os.write_uint64(3, v)?;
        }
        for v in &self.outputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.change_dts.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.num_inputs {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.mixin {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.account {
            os.write_uint32(9, v)?;
        }
        for v in &self.minor_indices {
            os.write_uint32(10, *v)?;
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.integrated_indices {
            os.write_uint32(12, *v)?;
        };
        if let Some(v) = self.client_version {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.hard_fork {
            os.write_uint32(14, v)?;
        }
        if let Some(ref v) = self.monero_version.as_ref() {
            os.write_bytes(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitRequest_MoneroTransactionData {
        MoneroTransactionInitRequest_MoneroTransactionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.version },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payment_id",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.payment_id },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.payment_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "unlock_time",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.unlock_time },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.unlock_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                "outputs",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.outputs },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                "change_dts",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.change_dts },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.change_dts },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_inputs",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.num_inputs },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.num_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mixin",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.mixin },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.mixin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fee",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.fee },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.account },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minor_indices",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.minor_indices },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.minor_indices },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.rsig_data },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.rsig_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "integrated_indices",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.integrated_indices },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.integrated_indices },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.client_version },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.client_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "hard_fork",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.hard_fork },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.hard_fork },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "monero_version",
                |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.monero_version },
                |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.monero_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInitRequest_MoneroTransactionData>(
                "MoneroTransactionInitRequest.MoneroTransactionData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest_MoneroTransactionData {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInitRequest_MoneroTransactionData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInitRequest_MoneroTransactionData::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInitRequest_MoneroTransactionData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.payment_id.clear();
        self.unlock_time = ::std::option::Option::None;
        self.outputs.clear();
        self.change_dts.clear();
        self.num_inputs = ::std::option::Option::None;
        self.mixin = ::std::option::Option::None;
        self.fee = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor_indices.clear();
        self.rsig_data.clear();
        self.integrated_indices.clear();
        self.client_version = ::std::option::Option::None;
        self.hard_fork = ::std::option::Option::None;
        self.monero_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitRequest_MoneroTransactionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest_MoneroTransactionData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitAck {
    // message fields
    pub hmacs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitAck {
    fn default() -> &'a MoneroTransactionInitAck {
        <MoneroTransactionInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitAck {
    pub fn new() -> MoneroTransactionInitAck {
        ::std::default::Default::default()
    }

    // repeated bytes hmacs = 1;


    pub fn get_hmacs(&self) -> &[::std::vec::Vec<u8>] {
        &self.hmacs
    }
    pub fn clear_hmacs(&mut self) {
        self.hmacs.clear();
    }

    // Param is passed by value, moved
    pub fn set_hmacs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hmacs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hmacs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hmacs
    }

    // Take field
    pub fn take_hmacs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hmacs, ::protobuf::RepeatedField::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 2;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hmacs)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.hmacs {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.hmacs {
            os.write_bytes(1, &v)?;
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitAck {
        MoneroTransactionInitAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hmacs",
                |m: &MoneroTransactionInitAck| { &m.hmacs },
                |m: &mut MoneroTransactionInitAck| { &mut m.hmacs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionInitAck| { &m.rsig_data },
                |m: &mut MoneroTransactionInitAck| { &mut m.rsig_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInitAck>(
                "MoneroTransactionInitAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInitAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInitAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInitAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInitAck {
    fn clear(&mut self) {
        self.hmacs.clear();
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetInputRequest {
    // message fields
    pub src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputRequest {
    fn default() -> &'a MoneroTransactionSetInputRequest {
        <MoneroTransactionSetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputRequest {
    pub fn new() -> MoneroTransactionSetInputRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetInputRequest {
        MoneroTransactionSetInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                "src_entr",
                |m: &MoneroTransactionSetInputRequest| { &m.src_entr },
                |m: &mut MoneroTransactionSetInputRequest| { &mut m.src_entr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSetInputRequest>(
                "MoneroTransactionSetInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSetInputRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSetInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSetInputRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSetInputRequest {
    fn clear(&mut self) {
        self.src_entr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetInputAck {
    // message fields
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_alpha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    spend_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputAck {
    fn default() -> &'a MoneroTransactionSetInputAck {
        <MoneroTransactionSetInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputAck {
    pub fn new() -> MoneroTransactionSetInputAck {
        ::std::default::Default::default()
    }

    // optional bytes vini = 1;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 2;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 3;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 4;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_alpha = 5;


    pub fn get_pseudo_out_alpha(&self) -> &[u8] {
        match self.pseudo_out_alpha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_alpha(&mut self) {
        self.pseudo_out_alpha.clear();
    }

    pub fn has_pseudo_out_alpha(&self) -> bool {
        self.pseudo_out_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_alpha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_alpha.is_none() {
            self.pseudo_out_alpha.set_default();
        }
        self.pseudo_out_alpha.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_alpha(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_alpha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_key = 6;


    pub fn get_spend_key(&self) -> &[u8] {
        match self.spend_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_key(&mut self) {
        self.spend_key.clear();
    }

    pub fn has_spend_key(&self) -> bool {
        self.spend_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_key.is_none() {
            self.spend_key.set_default();
        }
        self.spend_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_alpha)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.pseudo_out_alpha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.spend_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_alpha.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.spend_key.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetInputAck {
        MoneroTransactionSetInputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini",
                |m: &MoneroTransactionSetInputAck| { &m.vini },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.vini },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini_hmac",
                |m: &MoneroTransactionSetInputAck| { &m.vini_hmac },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.vini_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out",
                |m: &MoneroTransactionSetInputAck| { &m.pseudo_out },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out_hmac",
                |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_hmac },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out_alpha",
                |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_alpha },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spend_key",
                |m: &MoneroTransactionSetInputAck| { &m.spend_key },
                |m: &mut MoneroTransactionSetInputAck| { &mut m.spend_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSetInputAck>(
                "MoneroTransactionSetInputAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSetInputAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSetInputAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSetInputAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSetInputAck {
    fn clear(&mut self) {
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.pseudo_out_alpha.clear();
        self.spend_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputsPermutationRequest {
    // message fields
    pub perm: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationRequest {
    fn default() -> &'a MoneroTransactionInputsPermutationRequest {
        <MoneroTransactionInputsPermutationRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationRequest {
    pub fn new() -> MoneroTransactionInputsPermutationRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 perm = 1;


    pub fn get_perm(&self) -> &[u32] {
        &self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: ::std::vec::Vec<u32>) {
        self.perm = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perm(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.perm
    }

    // Take field
    pub fn take_perm(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.perm, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.perm {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.perm {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputsPermutationRequest {
        MoneroTransactionInputsPermutationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "perm",
                |m: &MoneroTransactionInputsPermutationRequest| { &m.perm },
                |m: &mut MoneroTransactionInputsPermutationRequest| { &mut m.perm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInputsPermutationRequest>(
                "MoneroTransactionInputsPermutationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInputsPermutationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInputsPermutationRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInputsPermutationRequest {
    fn clear(&mut self) {
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputsPermutationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputsPermutationAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationAck {
    fn default() -> &'a MoneroTransactionInputsPermutationAck {
        <MoneroTransactionInputsPermutationAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationAck {
    pub fn new() -> MoneroTransactionInputsPermutationAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputsPermutationAck {
        MoneroTransactionInputsPermutationAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInputsPermutationAck>(
                "MoneroTransactionInputsPermutationAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInputsPermutationAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInputsPermutationAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInputsPermutationAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputsPermutationAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputViniRequest {
    // message fields
    pub src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    orig_idx: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniRequest {
    fn default() -> &'a MoneroTransactionInputViniRequest {
        <MoneroTransactionInputViniRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniRequest {
    pub fn new() -> MoneroTransactionInputViniRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }

    // optional bytes vini = 2;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 orig_idx = 6;


    pub fn get_orig_idx(&self) -> u32 {
        self.orig_idx.unwrap_or(0)
    }
    pub fn clear_orig_idx(&mut self) {
        self.orig_idx = ::std::option::Option::None;
    }

    pub fn has_orig_idx(&self) -> bool {
        self.orig_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orig_idx(&mut self, v: u32) {
        self.orig_idx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.orig_idx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.orig_idx {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.orig_idx {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputViniRequest {
        MoneroTransactionInputViniRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                "src_entr",
                |m: &MoneroTransactionInputViniRequest| { &m.src_entr },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.src_entr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini",
                |m: &MoneroTransactionInputViniRequest| { &m.vini },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini_hmac",
                |m: &MoneroTransactionInputViniRequest| { &m.vini_hmac },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out",
                |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out_hmac",
                |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out_hmac },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "orig_idx",
                |m: &MoneroTransactionInputViniRequest| { &m.orig_idx },
                |m: &mut MoneroTransactionInputViniRequest| { &mut m.orig_idx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInputViniRequest>(
                "MoneroTransactionInputViniRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInputViniRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInputViniRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInputViniRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInputViniRequest {
    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.orig_idx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputViniRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputViniAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniAck {
    fn default() -> &'a MoneroTransactionInputViniAck {
        <MoneroTransactionInputViniAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniAck {
    pub fn new() -> MoneroTransactionInputViniAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputViniAck {
        MoneroTransactionInputViniAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionInputViniAck>(
                "MoneroTransactionInputViniAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionInputViniAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionInputViniAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionInputViniAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionInputViniAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputViniAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllInputsSetRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetRequest {
    fn default() -> &'a MoneroTransactionAllInputsSetRequest {
        <MoneroTransactionAllInputsSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetRequest {
    pub fn new() -> MoneroTransactionAllInputsSetRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllInputsSetRequest {
        MoneroTransactionAllInputsSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionAllInputsSetRequest>(
                "MoneroTransactionAllInputsSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionAllInputsSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionAllInputsSetRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionAllInputsSetRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllInputsSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllInputsSetAck {
    // message fields
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetAck {
    fn default() -> &'a MoneroTransactionAllInputsSetAck {
        <MoneroTransactionAllInputsSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetAck {
    pub fn new() -> MoneroTransactionAllInputsSetAck {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllInputsSetAck {
        MoneroTransactionAllInputsSetAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionAllInputsSetAck| { &m.rsig_data },
                |m: &mut MoneroTransactionAllInputsSetAck| { &mut m.rsig_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionAllInputsSetAck>(
                "MoneroTransactionAllInputsSetAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionAllInputsSetAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionAllInputsSetAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionAllInputsSetAck {
    fn clear(&mut self) {
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllInputsSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetOutputRequest {
    // message fields
    pub dst_entr: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry>,
    dst_entr_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    is_offloaded_bp: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputRequest {
    fn default() -> &'a MoneroTransactionSetOutputRequest {
        <MoneroTransactionSetOutputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputRequest {
    pub fn new() -> MoneroTransactionSetOutputRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;


    pub fn get_dst_entr(&self) -> &MoneroTransactionDestinationEntry {
        self.dst_entr.as_ref().unwrap_or_else(|| <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dst_entr(&mut self) {
        self.dst_entr.clear();
    }

    pub fn has_dst_entr(&self) -> bool {
        self.dst_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr(&mut self, v: MoneroTransactionDestinationEntry) {
        self.dst_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr(&mut self) -> &mut MoneroTransactionDestinationEntry {
        if self.dst_entr.is_none() {
            self.dst_entr.set_default();
        }
        self.dst_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr(&mut self) -> MoneroTransactionDestinationEntry {
        self.dst_entr.take().unwrap_or_else(|| MoneroTransactionDestinationEntry::new())
    }

    // optional bytes dst_entr_hmac = 2;


    pub fn get_dst_entr_hmac(&self) -> &[u8] {
        match self.dst_entr_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_dst_entr_hmac(&mut self) {
        self.dst_entr_hmac.clear();
    }

    pub fn has_dst_entr_hmac(&self) -> bool {
        self.dst_entr_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.dst_entr_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dst_entr_hmac.is_none() {
            self.dst_entr_hmac.set_default();
        }
        self.dst_entr_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.dst_entr_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // optional bool is_offloaded_bp = 4;


    pub fn get_is_offloaded_bp(&self) -> bool {
        self.is_offloaded_bp.unwrap_or(false)
    }
    pub fn clear_is_offloaded_bp(&mut self) {
        self.is_offloaded_bp = ::std::option::Option::None;
    }

    pub fn has_is_offloaded_bp(&self) -> bool {
        self.is_offloaded_bp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_offloaded_bp(&mut self, v: bool) {
        self.is_offloaded_bp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.dst_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dst_entr_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_offloaded_bp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dst_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_entr_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.is_offloaded_bp {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dst_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_entr_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.is_offloaded_bp {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetOutputRequest {
        MoneroTransactionSetOutputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                "dst_entr",
                |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr },
                |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "dst_entr_hmac",
                |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr_hmac },
                |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionSetOutputRequest| { &m.rsig_data },
                |m: &mut MoneroTransactionSetOutputRequest| { &mut m.rsig_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_offloaded_bp",
                |m: &MoneroTransactionSetOutputRequest| { &m.is_offloaded_bp },
                |m: &mut MoneroTransactionSetOutputRequest| { &mut m.is_offloaded_bp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSetOutputRequest>(
                "MoneroTransactionSetOutputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSetOutputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSetOutputRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSetOutputRequest {
    fn clear(&mut self) {
        self.dst_entr.clear();
        self.dst_entr_hmac.clear();
        self.rsig_data.clear();
        self.is_offloaded_bp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetOutputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetOutputAck {
    // message fields
    tx_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vouti_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    out_pk: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ecdh_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputAck {
    fn default() -> &'a MoneroTransactionSetOutputAck {
        <MoneroTransactionSetOutputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputAck {
    pub fn new() -> MoneroTransactionSetOutputAck {
        ::std::default::Default::default()
    }

    // optional bytes tx_out = 1;


    pub fn get_tx_out(&self) -> &[u8] {
        match self.tx_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_out(&mut self) {
        self.tx_out.clear();
    }

    pub fn has_tx_out(&self) -> bool {
        self.tx_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_out.is_none() {
            self.tx_out.set_default();
        }
        self.tx_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_out(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vouti_hmac = 2;


    pub fn get_vouti_hmac(&self) -> &[u8] {
        match self.vouti_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vouti_hmac(&mut self) {
        self.vouti_hmac.clear();
    }

    pub fn has_vouti_hmac(&self) -> bool {
        self.vouti_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vouti_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vouti_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vouti_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vouti_hmac.is_none() {
            self.vouti_hmac.set_default();
        }
        self.vouti_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vouti_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vouti_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // optional bytes out_pk = 4;


    pub fn get_out_pk(&self) -> &[u8] {
        match self.out_pk.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_out_pk(&mut self) {
        self.out_pk.clear();
    }

    pub fn has_out_pk(&self) -> bool {
        self.out_pk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_pk(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_pk = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_pk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_pk.is_none() {
            self.out_pk.set_default();
        }
        self.out_pk.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_pk(&mut self) -> ::std::vec::Vec<u8> {
        self.out_pk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ecdh_info = 5;


    pub fn get_ecdh_info(&self) -> &[u8] {
        match self.ecdh_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ecdh_info(&mut self) {
        self.ecdh_info.clear();
    }

    pub fn has_ecdh_info(&self) -> bool {
        self.ecdh_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdh_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.ecdh_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdh_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ecdh_info.is_none() {
            self.ecdh_info.set_default();
        }
        self.ecdh_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdh_info(&mut self) -> ::std::vec::Vec<u8> {
        self.ecdh_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_out)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vouti_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.out_pk)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ecdh_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tx_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.vouti_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.out_pk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.ecdh_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tx_out.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.vouti_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.out_pk.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.ecdh_info.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetOutputAck {
        MoneroTransactionSetOutputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_out",
                |m: &MoneroTransactionSetOutputAck| { &m.tx_out },
                |m: &mut MoneroTransactionSetOutputAck| { &mut m.tx_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vouti_hmac",
                |m: &MoneroTransactionSetOutputAck| { &m.vouti_hmac },
                |m: &mut MoneroTransactionSetOutputAck| { &mut m.vouti_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionSetOutputAck| { &m.rsig_data },
                |m: &mut MoneroTransactionSetOutputAck| { &mut m.rsig_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "out_pk",
                |m: &MoneroTransactionSetOutputAck| { &m.out_pk },
                |m: &mut MoneroTransactionSetOutputAck| { &mut m.out_pk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "ecdh_info",
                |m: &MoneroTransactionSetOutputAck| { &m.ecdh_info },
                |m: &mut MoneroTransactionSetOutputAck| { &mut m.ecdh_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSetOutputAck>(
                "MoneroTransactionSetOutputAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSetOutputAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSetOutputAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSetOutputAck {
    fn clear(&mut self) {
        self.tx_out.clear();
        self.vouti_hmac.clear();
        self.rsig_data.clear();
        self.out_pk.clear();
        self.ecdh_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetOutputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetRequest {
    // message fields
    pub rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetRequest {
    fn default() -> &'a MoneroTransactionAllOutSetRequest {
        <MoneroTransactionAllOutSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetRequest {
    pub fn new() -> MoneroTransactionAllOutSetRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| <MoneroTransactionRsigData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetRequest {
        MoneroTransactionAllOutSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                "rsig_data",
                |m: &MoneroTransactionAllOutSetRequest| { &m.rsig_data },
                |m: &mut MoneroTransactionAllOutSetRequest| { &mut m.rsig_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionAllOutSetRequest>(
                "MoneroTransactionAllOutSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionAllOutSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionAllOutSetRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetRequest {
    fn clear(&mut self) {
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetAck {
    // message fields
    extra: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_prefix_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub rv: ::protobuf::SingularPtrField<MoneroTransactionAllOutSetAck_MoneroRingCtSig>,
    full_message_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck {
    fn default() -> &'a MoneroTransactionAllOutSetAck {
        <MoneroTransactionAllOutSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck {
    pub fn new() -> MoneroTransactionAllOutSetAck {
        ::std::default::Default::default()
    }

    // optional bytes extra = 1;


    pub fn get_extra(&self) -> &[u8] {
        match self.extra.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_extra(&mut self) {
        self.extra.clear();
    }

    pub fn has_extra(&self) -> bool {
        self.extra.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra.is_none() {
            self.extra.set_default();
        }
        self.extra.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra(&mut self) -> ::std::vec::Vec<u8> {
        self.extra.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_prefix_hash = 2;


    pub fn get_tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash.clear();
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash.set_default();
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;


    pub fn get_rv(&self) -> &MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        self.rv.as_ref().unwrap_or_else(|| <MoneroTransactionAllOutSetAck_MoneroRingCtSig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rv(&mut self) {
        self.rv.clear();
    }

    pub fn has_rv(&self) -> bool {
        self.rv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rv(&mut self, v: MoneroTransactionAllOutSetAck_MoneroRingCtSig) {
        self.rv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rv(&mut self) -> &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        if self.rv.is_none() {
            self.rv.set_default();
        }
        self.rv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rv(&mut self) -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        self.rv.take().unwrap_or_else(|| MoneroTransactionAllOutSetAck_MoneroRingCtSig::new())
    }

    // optional bytes full_message_hash = 5;


    pub fn get_full_message_hash(&self) -> &[u8] {
        match self.full_message_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_full_message_hash(&mut self) {
        self.full_message_hash.clear();
    }

    pub fn has_full_message_hash(&self) -> bool {
        self.full_message_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_message_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_message_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_message_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_message_hash.is_none() {
            self.full_message_hash.set_default();
        }
        self.full_message_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_message_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.full_message_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_prefix_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rv)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.full_message_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.extra.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.full_message_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.extra.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rv.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.full_message_hash.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetAck {
        MoneroTransactionAllOutSetAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "extra",
                |m: &MoneroTransactionAllOutSetAck| { &m.extra },
                |m: &mut MoneroTransactionAllOutSetAck| { &mut m.extra },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_prefix_hash",
                |m: &MoneroTransactionAllOutSetAck| { &m.tx_prefix_hash },
                |m: &mut MoneroTransactionAllOutSetAck| { &mut m.tx_prefix_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionAllOutSetAck_MoneroRingCtSig>>(
                "rv",
                |m: &MoneroTransactionAllOutSetAck| { &m.rv },
                |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "full_message_hash",
                |m: &MoneroTransactionAllOutSetAck| { &m.full_message_hash },
                |m: &mut MoneroTransactionAllOutSetAck| { &mut m.full_message_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionAllOutSetAck>(
                "MoneroTransactionAllOutSetAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionAllOutSetAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionAllOutSetAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetAck {
    fn clear(&mut self) {
        self.extra.clear();
        self.tx_prefix_hash.clear();
        self.rv.clear();
        self.full_message_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    // message fields
    txn_fee: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rv_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn default() -> &'a MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        <MoneroTransactionAllOutSetAck_MoneroRingCtSig as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    pub fn new() -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        ::std::default::Default::default()
    }

    // optional uint64 txn_fee = 1;


    pub fn get_txn_fee(&self) -> u64 {
        self.txn_fee.unwrap_or(0)
    }
    pub fn clear_txn_fee(&mut self) {
        self.txn_fee = ::std::option::Option::None;
    }

    pub fn has_txn_fee(&self) -> bool {
        self.txn_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_fee(&mut self, v: u64) {
        self.txn_fee = ::std::option::Option::Some(v);
    }

    // optional bytes message = 2;


    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rv_type = 3;


    pub fn get_rv_type(&self) -> u32 {
        self.rv_type.unwrap_or(0)
    }
    pub fn clear_rv_type(&mut self) {
        self.rv_type = ::std::option::Option::None;
    }

    pub fn has_rv_type(&self) -> bool {
        self.rv_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rv_type(&mut self, v: u32) {
        self.rv_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_fee = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rv_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_fee {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rv_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_fee {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.rv_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        MoneroTransactionAllOutSetAck_MoneroRingCtSig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_fee",
                |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.txn_fee },
                |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.txn_fee },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.message },
                |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rv_type",
                |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.rv_type },
                |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.rv_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionAllOutSetAck_MoneroRingCtSig>(
                "MoneroTransactionAllOutSetAck.MoneroRingCtSig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionAllOutSetAck_MoneroRingCtSig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionAllOutSetAck_MoneroRingCtSig::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn clear(&mut self) {
        self.txn_fee = ::std::option::Option::None;
        self.message.clear();
        self.rv_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSignInputRequest {
    // message fields
    pub src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_alpha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    spend_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    orig_idx: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputRequest {
    fn default() -> &'a MoneroTransactionSignInputRequest {
        <MoneroTransactionSignInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputRequest {
    pub fn new() -> MoneroTransactionSignInputRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }

    // optional bytes vini = 2;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_alpha = 6;


    pub fn get_pseudo_out_alpha(&self) -> &[u8] {
        match self.pseudo_out_alpha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_alpha(&mut self) {
        self.pseudo_out_alpha.clear();
    }

    pub fn has_pseudo_out_alpha(&self) -> bool {
        self.pseudo_out_alpha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_alpha(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_alpha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_alpha(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_alpha.is_none() {
            self.pseudo_out_alpha.set_default();
        }
        self.pseudo_out_alpha.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_alpha(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_alpha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_key = 7;


    pub fn get_spend_key(&self) -> &[u8] {
        match self.spend_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_key(&mut self) {
        self.spend_key.clear();
    }

    pub fn has_spend_key(&self) -> bool {
        self.spend_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_key.is_none() {
            self.spend_key.set_default();
        }
        self.spend_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 orig_idx = 8;


    pub fn get_orig_idx(&self) -> u32 {
        self.orig_idx.unwrap_or(0)
    }
    pub fn clear_orig_idx(&mut self) {
        self.orig_idx = ::std::option::Option::None;
    }

    pub fn has_orig_idx(&self) -> bool {
        self.orig_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orig_idx(&mut self, v: u32) {
        self.orig_idx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_alpha)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_key)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.orig_idx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.pseudo_out_alpha.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.spend_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.orig_idx {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_alpha.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.spend_key.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(v) = self.orig_idx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSignInputRequest {
        MoneroTransactionSignInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                "src_entr",
                |m: &MoneroTransactionSignInputRequest| { &m.src_entr },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.src_entr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini",
                |m: &MoneroTransactionSignInputRequest| { &m.vini },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "vini_hmac",
                |m: &MoneroTransactionSignInputRequest| { &m.vini_hmac },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out",
                |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out_hmac",
                |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_hmac },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_hmac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out_alpha",
                |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_alpha },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "spend_key",
                |m: &MoneroTransactionSignInputRequest| { &m.spend_key },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.spend_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "orig_idx",
                |m: &MoneroTransactionSignInputRequest| { &m.orig_idx },
                |m: &mut MoneroTransactionSignInputRequest| { &mut m.orig_idx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSignInputRequest>(
                "MoneroTransactionSignInputRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSignInputRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSignInputRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSignInputRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSignInputRequest {
    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.pseudo_out_alpha.clear();
        self.spend_key.clear();
        self.orig_idx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSignInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSignInputAck {
    // message fields
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputAck {
    fn default() -> &'a MoneroTransactionSignInputAck {
        <MoneroTransactionSignInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputAck {
    pub fn new() -> MoneroTransactionSignInputAck {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 2;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSignInputAck {
        MoneroTransactionSignInputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &MoneroTransactionSignInputAck| { &m.signature },
                |m: &mut MoneroTransactionSignInputAck| { &mut m.signature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "pseudo_out",
                |m: &MoneroTransactionSignInputAck| { &m.pseudo_out },
                |m: &mut MoneroTransactionSignInputAck| { &mut m.pseudo_out },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionSignInputAck>(
                "MoneroTransactionSignInputAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionSignInputAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionSignInputAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionSignInputAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionSignInputAck {
    fn clear(&mut self) {
        self.signature.clear();
        self.pseudo_out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSignInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionFinalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalRequest {
    fn default() -> &'a MoneroTransactionFinalRequest {
        <MoneroTransactionFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalRequest {
    pub fn new() -> MoneroTransactionFinalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionFinalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionFinalRequest {
        MoneroTransactionFinalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionFinalRequest>(
                "MoneroTransactionFinalRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionFinalRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionFinalRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionFinalRequest::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionFinalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionFinalAck {
    // message fields
    cout_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    salt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rand_mult: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_enc_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    opening_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalAck {
    fn default() -> &'a MoneroTransactionFinalAck {
        <MoneroTransactionFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalAck {
    pub fn new() -> MoneroTransactionFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes cout_key = 1;


    pub fn get_cout_key(&self) -> &[u8] {
        match self.cout_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_cout_key(&mut self) {
        self.cout_key.clear();
    }

    pub fn has_cout_key(&self) -> bool {
        self.cout_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout_key.is_none() {
            self.cout_key.set_default();
        }
        self.cout_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout_key(&mut self) -> ::std::vec::Vec<u8> {
        self.cout_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt = 2;


    pub fn get_salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt.set_default();
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rand_mult = 3;


    pub fn get_rand_mult(&self) -> &[u8] {
        match self.rand_mult.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rand_mult(&mut self) {
        self.rand_mult.clear();
    }

    pub fn has_rand_mult(&self) -> bool {
        self.rand_mult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rand_mult(&mut self, v: ::std::vec::Vec<u8>) {
        self.rand_mult = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rand_mult(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rand_mult.is_none() {
            self.rand_mult.set_default();
        }
        self.rand_mult.as_mut().unwrap()
    }

    // Take field
    pub fn take_rand_mult(&mut self) -> ::std::vec::Vec<u8> {
        self.rand_mult.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_enc_keys = 4;


    pub fn get_tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys.clear();
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys.set_default();
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes opening_key = 5;


    pub fn get_opening_key(&self) -> &[u8] {
        match self.opening_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_opening_key(&mut self) {
        self.opening_key.clear();
    }

    pub fn has_opening_key(&self) -> bool {
        self.opening_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opening_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.opening_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opening_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.opening_key.is_none() {
            self.opening_key.set_default();
        }
        self.opening_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_opening_key(&mut self) -> ::std::vec::Vec<u8> {
        self.opening_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionFinalAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.cout_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rand_mult)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_enc_keys)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.opening_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cout_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rand_mult.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.opening_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cout_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.salt.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rand_mult.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.opening_key.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionFinalAck {
        MoneroTransactionFinalAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "cout_key",
                |m: &MoneroTransactionFinalAck| { &m.cout_key },
                |m: &mut MoneroTransactionFinalAck| { &mut m.cout_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "salt",
                |m: &MoneroTransactionFinalAck| { &m.salt },
                |m: &mut MoneroTransactionFinalAck| { &mut m.salt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rand_mult",
                |m: &MoneroTransactionFinalAck| { &m.rand_mult },
                |m: &mut MoneroTransactionFinalAck| { &mut m.rand_mult },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_enc_keys",
                |m: &MoneroTransactionFinalAck| { &m.tx_enc_keys },
                |m: &mut MoneroTransactionFinalAck| { &mut m.tx_enc_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "opening_key",
                |m: &MoneroTransactionFinalAck| { &m.opening_key },
                |m: &mut MoneroTransactionFinalAck| { &mut m.opening_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroTransactionFinalAck>(
                "MoneroTransactionFinalAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroTransactionFinalAck {
        static instance: ::protobuf::rt::LazyV2<MoneroTransactionFinalAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroTransactionFinalAck::new)
    }
}

impl ::protobuf::Clear for MoneroTransactionFinalAck {
    fn clear(&mut self) {
        self.cout_key.clear();
        self.salt.clear();
        self.rand_mult.clear();
        self.tx_enc_keys.clear();
        self.opening_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitRequest {
    // message fields
    num: ::std::option::Option<u64>,
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    pub subs: ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest {
    fn default() -> &'a MoneroKeyImageExportInitRequest {
        <MoneroKeyImageExportInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest {
    pub fn new() -> MoneroKeyImageExportInitRequest {
        ::std::default::Default::default()
    }

    // optional uint64 num = 1;


    pub fn get_num(&self) -> u64 {
        self.num.unwrap_or(0)
    }
    pub fn clear_num(&mut self) {
        self.num = ::std::option::Option::None;
    }

    pub fn has_num(&self) -> bool {
        self.num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: u64) {
        self.num = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated uint32 address_n = 3;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 4;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;


    pub fn get_subs(&self) -> &[MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList] {
        &self.subs
    }
    pub fn clear_subs(&mut self) {
        self.subs.clear();
    }

    // Param is passed by value, moved
    pub fn set_subs(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>) {
        self.subs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> {
        &mut self.subs
    }

    // Take field
    pub fn take_subs(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> {
        ::std::mem::replace(&mut self.subs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.subs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.address_n {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(4, v)?;
        }
        for v in &self.subs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitRequest {
        MoneroKeyImageExportInitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num",
                |m: &MoneroKeyImageExportInitRequest| { &m.num },
                |m: &mut MoneroKeyImageExportInitRequest| { &mut m.num },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hash",
                |m: &MoneroKeyImageExportInitRequest| { &m.hash },
                |m: &mut MoneroKeyImageExportInitRequest| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroKeyImageExportInitRequest| { &m.address_n },
                |m: &mut MoneroKeyImageExportInitRequest| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroKeyImageExportInitRequest| { &m.network_type },
                |m: &mut MoneroKeyImageExportInitRequest| { &mut m.network_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>>(
                "subs",
                |m: &MoneroKeyImageExportInitRequest| { &m.subs },
                |m: &mut MoneroKeyImageExportInitRequest| { &mut m.subs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageExportInitRequest>(
                "MoneroKeyImageExportInitRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageExportInitRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageExportInitRequest::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitRequest {
    fn clear(&mut self) {
        self.num = ::std::option::Option::None;
        self.hash.clear();
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.subs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    // message fields
    account: ::std::option::Option<u32>,
    pub minor_indices: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn default() -> &'a MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        <MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    pub fn new() -> MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        ::std::default::Default::default()
    }

    // optional uint32 account = 1;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // repeated uint32 minor_indices = 2;


    pub fn get_minor_indices(&self) -> &[u32] {
        &self.minor_indices
    }
    pub fn clear_minor_indices(&mut self) {
        self.minor_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_minor_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.minor_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minor_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.minor_indices
    }

    // Take field
    pub fn take_minor_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.minor_indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.minor_indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.minor_indices {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint32(1, v)?;
        }
        for v in &self.minor_indices {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account",
                |m: &MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &m.account },
                |m: &mut MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &mut m.account },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "minor_indices",
                |m: &MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &m.minor_indices },
                |m: &mut MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &mut m.minor_indices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(
                "MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.minor_indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitAck {
    fn default() -> &'a MoneroKeyImageExportInitAck {
        <MoneroKeyImageExportInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitAck {
    pub fn new() -> MoneroKeyImageExportInitAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitAck {
        MoneroKeyImageExportInitAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageExportInitAck>(
                "MoneroKeyImageExportInitAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitAck {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageExportInitAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageExportInitAck::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepRequest {
    // message fields
    pub tdis: ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest {
    fn default() -> &'a MoneroKeyImageSyncStepRequest {
        <MoneroKeyImageSyncStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest {
    pub fn new() -> MoneroKeyImageSyncStepRequest {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;


    pub fn get_tdis(&self) -> &[MoneroKeyImageSyncStepRequest_MoneroTransferDetails] {
        &self.tdis
    }
    pub fn clear_tdis(&mut self) {
        self.tdis.clear();
    }

    // Param is passed by value, moved
    pub fn set_tdis(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>) {
        self.tdis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tdis(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> {
        &mut self.tdis
    }

    // Take field
    pub fn take_tdis(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> {
        ::std::mem::replace(&mut self.tdis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tdis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tdis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tdis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tdis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepRequest {
        MoneroKeyImageSyncStepRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>>(
                "tdis",
                |m: &MoneroKeyImageSyncStepRequest| { &m.tdis },
                |m: &mut MoneroKeyImageSyncStepRequest| { &mut m.tdis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncStepRequest>(
                "MoneroKeyImageSyncStepRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncStepRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncStepRequest::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepRequest {
    fn clear(&mut self) {
        self.tdis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    // message fields
    out_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_pub_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub additional_tx_pub_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    internal_output_index: ::std::option::Option<u64>,
    sub_addr_major: ::std::option::Option<u32>,
    sub_addr_minor: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn default() -> &'a MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        <MoneroKeyImageSyncStepRequest_MoneroTransferDetails as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    pub fn new() -> MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        ::std::default::Default::default()
    }

    // optional bytes out_key = 1;


    pub fn get_out_key(&self) -> &[u8] {
        match self.out_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_out_key(&mut self) {
        self.out_key.clear();
    }

    pub fn has_out_key(&self) -> bool {
        self.out_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_key.is_none() {
            self.out_key.set_default();
        }
        self.out_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
        self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_pub_key = 2;


    pub fn get_tx_pub_key(&self) -> &[u8] {
        match self.tx_pub_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_pub_key(&mut self) {
        self.tx_pub_key.clear();
    }

    pub fn has_tx_pub_key(&self) -> bool {
        self.tx_pub_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_pub_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_pub_key.is_none() {
            self.tx_pub_key.set_default();
        }
        self.tx_pub_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_pub_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes additional_tx_pub_keys = 3;


    pub fn get_additional_tx_pub_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.additional_tx_pub_keys
    }
    pub fn clear_additional_tx_pub_keys(&mut self) {
        self.additional_tx_pub_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_tx_pub_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.additional_tx_pub_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_tx_pub_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.additional_tx_pub_keys
    }

    // Take field
    pub fn take_additional_tx_pub_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.additional_tx_pub_keys, ::protobuf::RepeatedField::new())
    }

    // optional uint64 internal_output_index = 4;


    pub fn get_internal_output_index(&self) -> u64 {
        self.internal_output_index.unwrap_or(0)
    }
    pub fn clear_internal_output_index(&mut self) {
        self.internal_output_index = ::std::option::Option::None;
    }

    pub fn has_internal_output_index(&self) -> bool {
        self.internal_output_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_output_index(&mut self, v: u64) {
        self.internal_output_index = ::std::option::Option::Some(v);
    }

    // optional uint32 sub_addr_major = 5;


    pub fn get_sub_addr_major(&self) -> u32 {
        self.sub_addr_major.unwrap_or(0)
    }
    pub fn clear_sub_addr_major(&mut self) {
        self.sub_addr_major = ::std::option::Option::None;
    }

    pub fn has_sub_addr_major(&self) -> bool {
        self.sub_addr_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_major(&mut self, v: u32) {
        self.sub_addr_major = ::std::option::Option::Some(v);
    }

    // optional uint32 sub_addr_minor = 6;


    pub fn get_sub_addr_minor(&self) -> u32 {
        self.sub_addr_minor.unwrap_or(0)
    }
    pub fn clear_sub_addr_minor(&mut self) {
        self.sub_addr_minor = ::std::option::Option::None;
    }

    pub fn has_sub_addr_minor(&self) -> bool {
        self.sub_addr_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_minor(&mut self, v: u32) {
        self.sub_addr_minor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.out_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.additional_tx_pub_keys)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.internal_output_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_addr_major = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_addr_minor = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.out_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tx_pub_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.additional_tx_pub_keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(v) = self.internal_output_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sub_addr_major {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sub_addr_minor {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.out_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tx_pub_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.additional_tx_pub_keys {
            os.write_bytes(3, &v)?;
        };
        if let Some(v) = self.internal_output_index {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.sub_addr_major {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sub_addr_minor {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        MoneroKeyImageSyncStepRequest_MoneroTransferDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "out_key",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.out_key },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.out_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_pub_key",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.tx_pub_key },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.tx_pub_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "additional_tx_pub_keys",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.additional_tx_pub_keys },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.additional_tx_pub_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "internal_output_index",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.internal_output_index },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.internal_output_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sub_addr_major",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.sub_addr_major },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.sub_addr_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sub_addr_minor",
                |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.sub_addr_minor },
                |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.sub_addr_minor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(
                "MoneroKeyImageSyncStepRequest.MoneroTransferDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncStepRequest_MoneroTransferDetails::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn clear(&mut self) {
        self.out_key.clear();
        self.tx_pub_key.clear();
        self.additional_tx_pub_keys.clear();
        self.internal_output_index = ::std::option::Option::None;
        self.sub_addr_major = ::std::option::Option::None;
        self.sub_addr_minor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepAck {
    // message fields
    pub kis: ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck {
    fn default() -> &'a MoneroKeyImageSyncStepAck {
        <MoneroKeyImageSyncStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck {
    pub fn new() -> MoneroKeyImageSyncStepAck {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;


    pub fn get_kis(&self) -> &[MoneroKeyImageSyncStepAck_MoneroExportedKeyImage] {
        &self.kis
    }
    pub fn clear_kis(&mut self) {
        self.kis.clear();
    }

    // Param is passed by value, moved
    pub fn set_kis(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>) {
        self.kis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kis(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> {
        &mut self.kis
    }

    // Take field
    pub fn take_kis(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> {
        ::std::mem::replace(&mut self.kis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck {
    fn is_initialized(&self) -> bool {
        for v in &self.kis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepAck {
        MoneroKeyImageSyncStepAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>>(
                "kis",
                |m: &MoneroKeyImageSyncStepAck| { &m.kis },
                |m: &mut MoneroKeyImageSyncStepAck| { &mut m.kis },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncStepAck>(
                "MoneroKeyImageSyncStepAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncStepAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncStepAck::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepAck {
    fn clear(&mut self) {
        self.kis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    // message fields
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn default() -> &'a MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        <MoneroKeyImageSyncStepAck_MoneroExportedKeyImage as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    pub fn new() -> MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        ::std::default::Default::default()
    }

    // optional bytes iv = 1;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes blob = 3;


    pub fn get_blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.blob.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "iv",
                |m: &MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &m.iv },
                |m: &mut MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &mut m.iv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "blob",
                |m: &MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &m.blob },
                |m: &mut MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &mut m.blob },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(
                "MoneroKeyImageSyncStepAck.MoneroExportedKeyImage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn clear(&mut self) {
        self.iv.clear();
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncFinalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalRequest {
    fn default() -> &'a MoneroKeyImageSyncFinalRequest {
        <MoneroKeyImageSyncFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalRequest {
    pub fn new() -> MoneroKeyImageSyncFinalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncFinalRequest {
        MoneroKeyImageSyncFinalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncFinalRequest>(
                "MoneroKeyImageSyncFinalRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncFinalRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncFinalRequest::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncFinalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncFinalAck {
    // message fields
    enc_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalAck {
    fn default() -> &'a MoneroKeyImageSyncFinalAck {
        <MoneroKeyImageSyncFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalAck {
    pub fn new() -> MoneroKeyImageSyncFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes enc_key = 1;


    pub fn get_enc_key(&self) -> &[u8] {
        match self.enc_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_enc_key(&mut self) {
        self.enc_key.clear();
    }

    pub fn has_enc_key(&self) -> bool {
        self.enc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enc_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.enc_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enc_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enc_key.is_none() {
            self.enc_key.set_default();
        }
        self.enc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_enc_key(&mut self) -> ::std::vec::Vec<u8> {
        self.enc_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.enc_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.enc_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.enc_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncFinalAck {
        MoneroKeyImageSyncFinalAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "enc_key",
                |m: &MoneroKeyImageSyncFinalAck| { &m.enc_key },
                |m: &mut MoneroKeyImageSyncFinalAck| { &mut m.enc_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroKeyImageSyncFinalAck>(
                "MoneroKeyImageSyncFinalAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalAck {
        static instance: ::protobuf::rt::LazyV2<MoneroKeyImageSyncFinalAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroKeyImageSyncFinalAck::new)
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncFinalAck {
    fn clear(&mut self) {
        self.enc_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetTxKeyRequest {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    salt1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    salt2: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_enc_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_prefix_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    reason: ::std::option::Option<u32>,
    view_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetTxKeyRequest {
    fn default() -> &'a MoneroGetTxKeyRequest {
        <MoneroGetTxKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetTxKeyRequest {
    pub fn new() -> MoneroGetTxKeyRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 2;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional bytes salt1 = 3;


    pub fn get_salt1(&self) -> &[u8] {
        match self.salt1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt1(&mut self) {
        self.salt1.clear();
    }

    pub fn has_salt1(&self) -> bool {
        self.salt1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt1(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt1.is_none() {
            self.salt1.set_default();
        }
        self.salt1.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt1(&mut self) -> ::std::vec::Vec<u8> {
        self.salt1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt2 = 4;


    pub fn get_salt2(&self) -> &[u8] {
        match self.salt2.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt2(&mut self) {
        self.salt2.clear();
    }

    pub fn has_salt2(&self) -> bool {
        self.salt2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt2(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt2.is_none() {
            self.salt2.set_default();
        }
        self.salt2.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt2(&mut self) -> ::std::vec::Vec<u8> {
        self.salt2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_enc_keys = 5;


    pub fn get_tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys.clear();
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys.set_default();
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_prefix_hash = 6;


    pub fn get_tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash.clear();
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash.set_default();
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 reason = 7;


    pub fn get_reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional bytes view_public_key = 8;


    pub fn get_view_public_key(&self) -> &[u8] {
        match self.view_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_view_public_key(&mut self) {
        self.view_public_key.clear();
    }

    pub fn has_view_public_key(&self) -> bool {
        self.view_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.view_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.view_public_key.is_none() {
            self.view_public_key.set_default();
        }
        self.view_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroGetTxKeyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt1)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt2)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_enc_keys)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_prefix_hash)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reason = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.view_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.salt1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.salt2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.salt1.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.salt2.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetTxKeyRequest {
        MoneroGetTxKeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroGetTxKeyRequest| { &m.address_n },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroGetTxKeyRequest| { &m.network_type },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.network_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "salt1",
                |m: &MoneroGetTxKeyRequest| { &m.salt1 },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.salt1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "salt2",
                |m: &MoneroGetTxKeyRequest| { &m.salt2 },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.salt2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_enc_keys",
                |m: &MoneroGetTxKeyRequest| { &m.tx_enc_keys },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.tx_enc_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_prefix_hash",
                |m: &MoneroGetTxKeyRequest| { &m.tx_prefix_hash },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.tx_prefix_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reason",
                |m: &MoneroGetTxKeyRequest| { &m.reason },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "view_public_key",
                |m: &MoneroGetTxKeyRequest| { &m.view_public_key },
                |m: &mut MoneroGetTxKeyRequest| { &mut m.view_public_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroGetTxKeyRequest>(
                "MoneroGetTxKeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroGetTxKeyRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroGetTxKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroGetTxKeyRequest::new)
    }
}

impl ::protobuf::Clear for MoneroGetTxKeyRequest {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.salt1.clear();
        self.salt2.clear();
        self.tx_enc_keys.clear();
        self.tx_prefix_hash.clear();
        self.reason = ::std::option::Option::None;
        self.view_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetTxKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetTxKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetTxKeyAck {
    // message fields
    salt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_derivations: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetTxKeyAck {
    fn default() -> &'a MoneroGetTxKeyAck {
        <MoneroGetTxKeyAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetTxKeyAck {
    pub fn new() -> MoneroGetTxKeyAck {
        ::std::default::Default::default()
    }

    // optional bytes salt = 1;


    pub fn get_salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt.set_default();
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_keys = 2;


    pub fn get_tx_keys(&self) -> &[u8] {
        match self.tx_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_keys(&mut self) {
        self.tx_keys.clear();
    }

    pub fn has_tx_keys(&self) -> bool {
        self.tx_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_keys.is_none() {
            self.tx_keys.set_default();
        }
        self.tx_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_derivations = 3;


    pub fn get_tx_derivations(&self) -> &[u8] {
        match self.tx_derivations.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_derivations(&mut self) {
        self.tx_derivations.clear();
    }

    pub fn has_tx_derivations(&self) -> bool {
        self.tx_derivations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_derivations(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_derivations = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_derivations(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_derivations.is_none() {
            self.tx_derivations.set_default();
        }
        self.tx_derivations.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_derivations(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_derivations.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroGetTxKeyAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_keys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_derivations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tx_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.tx_derivations.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.salt.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tx_keys.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.tx_derivations.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetTxKeyAck {
        MoneroGetTxKeyAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "salt",
                |m: &MoneroGetTxKeyAck| { &m.salt },
                |m: &mut MoneroGetTxKeyAck| { &mut m.salt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_keys",
                |m: &MoneroGetTxKeyAck| { &m.tx_keys },
                |m: &mut MoneroGetTxKeyAck| { &mut m.tx_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "tx_derivations",
                |m: &MoneroGetTxKeyAck| { &m.tx_derivations },
                |m: &mut MoneroGetTxKeyAck| { &mut m.tx_derivations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroGetTxKeyAck>(
                "MoneroGetTxKeyAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroGetTxKeyAck {
        static instance: ::protobuf::rt::LazyV2<MoneroGetTxKeyAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroGetTxKeyAck::new)
    }
}

impl ::protobuf::Clear for MoneroGetTxKeyAck {
    fn clear(&mut self) {
        self.salt.clear();
        self.tx_keys.clear();
        self.tx_derivations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetTxKeyAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetTxKeyAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshStartRequest {
    // message fields
    pub address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStartRequest {
    fn default() -> &'a MoneroLiveRefreshStartRequest {
        <MoneroLiveRefreshStartRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStartRequest {
    pub fn new() -> MoneroLiveRefreshStartRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 2;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStartRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshStartRequest {
        MoneroLiveRefreshStartRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address_n",
                |m: &MoneroLiveRefreshStartRequest| { &m.address_n },
                |m: &mut MoneroLiveRefreshStartRequest| { &mut m.address_n },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "network_type",
                |m: &MoneroLiveRefreshStartRequest| { &m.network_type },
                |m: &mut MoneroLiveRefreshStartRequest| { &mut m.network_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshStartRequest>(
                "MoneroLiveRefreshStartRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshStartRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshStartRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshStartRequest::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshStartRequest {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshStartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStartRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshStartAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStartAck {
    fn default() -> &'a MoneroLiveRefreshStartAck {
        <MoneroLiveRefreshStartAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStartAck {
    pub fn new() -> MoneroLiveRefreshStartAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStartAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshStartAck {
        MoneroLiveRefreshStartAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshStartAck>(
                "MoneroLiveRefreshStartAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshStartAck {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshStartAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshStartAck::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshStartAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshStartAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStartAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshStepRequest {
    // message fields
    out_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    recv_deriv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    real_out_idx: ::std::option::Option<u64>,
    sub_addr_major: ::std::option::Option<u32>,
    sub_addr_minor: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStepRequest {
    fn default() -> &'a MoneroLiveRefreshStepRequest {
        <MoneroLiveRefreshStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStepRequest {
    pub fn new() -> MoneroLiveRefreshStepRequest {
        ::std::default::Default::default()
    }

    // optional bytes out_key = 1;


    pub fn get_out_key(&self) -> &[u8] {
        match self.out_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_out_key(&mut self) {
        self.out_key.clear();
    }

    pub fn has_out_key(&self) -> bool {
        self.out_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_key.is_none() {
            self.out_key.set_default();
        }
        self.out_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
        self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes recv_deriv = 2;


    pub fn get_recv_deriv(&self) -> &[u8] {
        match self.recv_deriv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_recv_deriv(&mut self) {
        self.recv_deriv.clear();
    }

    pub fn has_recv_deriv(&self) -> bool {
        self.recv_deriv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recv_deriv(&mut self, v: ::std::vec::Vec<u8>) {
        self.recv_deriv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recv_deriv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recv_deriv.is_none() {
            self.recv_deriv.set_default();
        }
        self.recv_deriv.as_mut().unwrap()
    }

    // Take field
    pub fn take_recv_deriv(&mut self) -> ::std::vec::Vec<u8> {
        self.recv_deriv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 real_out_idx = 3;


    pub fn get_real_out_idx(&self) -> u64 {
        self.real_out_idx.unwrap_or(0)
    }
    pub fn clear_real_out_idx(&mut self) {
        self.real_out_idx = ::std::option::Option::None;
    }

    pub fn has_real_out_idx(&self) -> bool {
        self.real_out_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_idx(&mut self, v: u64) {
        self.real_out_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 sub_addr_major = 4;


    pub fn get_sub_addr_major(&self) -> u32 {
        self.sub_addr_major.unwrap_or(0)
    }
    pub fn clear_sub_addr_major(&mut self) {
        self.sub_addr_major = ::std::option::Option::None;
    }

    pub fn has_sub_addr_major(&self) -> bool {
        self.sub_addr_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_major(&mut self, v: u32) {
        self.sub_addr_major = ::std::option::Option::Some(v);
    }

    // optional uint32 sub_addr_minor = 5;


    pub fn get_sub_addr_minor(&self) -> u32 {
        self.sub_addr_minor.unwrap_or(0)
    }
    pub fn clear_sub_addr_minor(&mut self) {
        self.sub_addr_minor = ::std::option::Option::None;
    }

    pub fn has_sub_addr_minor(&self) -> bool {
        self.sub_addr_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sub_addr_minor(&mut self, v: u32) {
        self.sub_addr_minor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStepRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.out_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.recv_deriv)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.real_out_idx = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_addr_major = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sub_addr_minor = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.out_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.recv_deriv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.real_out_idx {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sub_addr_major {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sub_addr_minor {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.out_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.recv_deriv.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.real_out_idx {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.sub_addr_major {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sub_addr_minor {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshStepRequest {
        MoneroLiveRefreshStepRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "out_key",
                |m: &MoneroLiveRefreshStepRequest| { &m.out_key },
                |m: &mut MoneroLiveRefreshStepRequest| { &mut m.out_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "recv_deriv",
                |m: &MoneroLiveRefreshStepRequest| { &m.recv_deriv },
                |m: &mut MoneroLiveRefreshStepRequest| { &mut m.recv_deriv },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "real_out_idx",
                |m: &MoneroLiveRefreshStepRequest| { &m.real_out_idx },
                |m: &mut MoneroLiveRefreshStepRequest| { &mut m.real_out_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sub_addr_major",
                |m: &MoneroLiveRefreshStepRequest| { &m.sub_addr_major },
                |m: &mut MoneroLiveRefreshStepRequest| { &mut m.sub_addr_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sub_addr_minor",
                |m: &MoneroLiveRefreshStepRequest| { &m.sub_addr_minor },
                |m: &mut MoneroLiveRefreshStepRequest| { &mut m.sub_addr_minor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshStepRequest>(
                "MoneroLiveRefreshStepRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshStepRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshStepRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshStepRequest::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshStepRequest {
    fn clear(&mut self) {
        self.out_key.clear();
        self.recv_deriv.clear();
        self.real_out_idx = ::std::option::Option::None;
        self.sub_addr_major = ::std::option::Option::None;
        self.sub_addr_minor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStepRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshStepAck {
    // message fields
    salt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    key_image: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshStepAck {
    fn default() -> &'a MoneroLiveRefreshStepAck {
        <MoneroLiveRefreshStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshStepAck {
    pub fn new() -> MoneroLiveRefreshStepAck {
        ::std::default::Default::default()
    }

    // optional bytes salt = 1;


    pub fn get_salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt.set_default();
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes key_image = 2;


    pub fn get_key_image(&self) -> &[u8] {
        match self.key_image.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key_image(&mut self) {
        self.key_image.clear();
    }

    pub fn has_key_image(&self) -> bool {
        self.key_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_image(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_image(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_image.is_none() {
            self.key_image.set_default();
        }
        self.key_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_image(&mut self) -> ::std::vec::Vec<u8> {
        self.key_image.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroLiveRefreshStepAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key_image)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.key_image.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.salt.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.key_image.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshStepAck {
        MoneroLiveRefreshStepAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "salt",
                |m: &MoneroLiveRefreshStepAck| { &m.salt },
                |m: &mut MoneroLiveRefreshStepAck| { &mut m.salt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key_image",
                |m: &MoneroLiveRefreshStepAck| { &m.key_image },
                |m: &mut MoneroLiveRefreshStepAck| { &mut m.key_image },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshStepAck>(
                "MoneroLiveRefreshStepAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshStepAck {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshStepAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshStepAck::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshStepAck {
    fn clear(&mut self) {
        self.salt.clear();
        self.key_image.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshStepAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshFinalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshFinalRequest {
    fn default() -> &'a MoneroLiveRefreshFinalRequest {
        <MoneroLiveRefreshFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshFinalRequest {
    pub fn new() -> MoneroLiveRefreshFinalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroLiveRefreshFinalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshFinalRequest {
        MoneroLiveRefreshFinalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshFinalRequest>(
                "MoneroLiveRefreshFinalRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshFinalRequest {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshFinalRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshFinalRequest::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshFinalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshFinalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroLiveRefreshFinalAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroLiveRefreshFinalAck {
    fn default() -> &'a MoneroLiveRefreshFinalAck {
        <MoneroLiveRefreshFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroLiveRefreshFinalAck {
    pub fn new() -> MoneroLiveRefreshFinalAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroLiveRefreshFinalAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroLiveRefreshFinalAck {
        MoneroLiveRefreshFinalAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MoneroLiveRefreshFinalAck>(
                "MoneroLiveRefreshFinalAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MoneroLiveRefreshFinalAck {
        static instance: ::protobuf::rt::LazyV2<MoneroLiveRefreshFinalAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MoneroLiveRefreshFinalAck::new)
    }
}

impl ::protobuf::Clear for MoneroLiveRefreshFinalAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroLiveRefreshFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroLiveRefreshFinalAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugMoneroDiagRequest {
    // message fields
    ins: ::std::option::Option<u64>,
    p1: ::std::option::Option<u64>,
    p2: ::std::option::Option<u64>,
    pub pd: ::std::vec::Vec<u64>,
    data1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data2: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagRequest {
    fn default() -> &'a DebugMoneroDiagRequest {
        <DebugMoneroDiagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagRequest {
    pub fn new() -> DebugMoneroDiagRequest {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;


    pub fn get_ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }
    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;


    pub fn get_p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }
    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;


    pub fn get_p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }
    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // repeated uint64 pd = 4;


    pub fn get_pd(&self) -> &[u64] {
        &self.pd
    }
    pub fn clear_pd(&mut self) {
        self.pd.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd(&mut self, v: ::std::vec::Vec<u64>) {
        self.pd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.pd
    }

    // Take field
    pub fn take_pd(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.pd, ::std::vec::Vec::new())
    }

    // optional bytes data1 = 5;


    pub fn get_data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data1(&mut self) {
        self.data1.clear();
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1.set_default();
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;


    pub fn get_data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data2(&mut self) {
        self.data2.clear();
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2.set_default();
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugMoneroDiagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.pd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(ref v) = self.data1.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.data2.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugMoneroDiagRequest {
        DebugMoneroDiagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ins",
                |m: &DebugMoneroDiagRequest| { &m.ins },
                |m: &mut DebugMoneroDiagRequest| { &mut m.ins },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "p1",
                |m: &DebugMoneroDiagRequest| { &m.p1 },
                |m: &mut DebugMoneroDiagRequest| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "p2",
                |m: &DebugMoneroDiagRequest| { &m.p2 },
                |m: &mut DebugMoneroDiagRequest| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pd",
                |m: &DebugMoneroDiagRequest| { &m.pd },
                |m: &mut DebugMoneroDiagRequest| { &mut m.pd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data1",
                |m: &DebugMoneroDiagRequest| { &m.data1 },
                |m: &mut DebugMoneroDiagRequest| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data2",
                |m: &DebugMoneroDiagRequest| { &m.data2 },
                |m: &mut DebugMoneroDiagRequest| { &mut m.data2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugMoneroDiagRequest>(
                "DebugMoneroDiagRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugMoneroDiagRequest {
        static instance: ::protobuf::rt::LazyV2<DebugMoneroDiagRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugMoneroDiagRequest::new)
    }
}

impl ::protobuf::Clear for DebugMoneroDiagRequest {
    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1.clear();
        self.data2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugMoneroDiagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugMoneroDiagAck {
    // message fields
    ins: ::std::option::Option<u64>,
    p1: ::std::option::Option<u64>,
    p2: ::std::option::Option<u64>,
    pub pd: ::std::vec::Vec<u64>,
    data1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data2: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagAck {
    fn default() -> &'a DebugMoneroDiagAck {
        <DebugMoneroDiagAck as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagAck {
    pub fn new() -> DebugMoneroDiagAck {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;


    pub fn get_ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }
    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;


    pub fn get_p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }
    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;


    pub fn get_p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }
    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // repeated uint64 pd = 4;


    pub fn get_pd(&self) -> &[u64] {
        &self.pd
    }
    pub fn clear_pd(&mut self) {
        self.pd.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd(&mut self, v: ::std::vec::Vec<u64>) {
        self.pd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.pd
    }

    // Take field
    pub fn take_pd(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.pd, ::std::vec::Vec::new())
    }

    // optional bytes data1 = 5;


    pub fn get_data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data1(&mut self) {
        self.data1.clear();
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1.set_default();
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;


    pub fn get_data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data2(&mut self) {
        self.data2.clear();
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2.set_default();
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugMoneroDiagAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.pd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(ref v) = self.data1.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.data2.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugMoneroDiagAck {
        DebugMoneroDiagAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ins",
                |m: &DebugMoneroDiagAck| { &m.ins },
                |m: &mut DebugMoneroDiagAck| { &mut m.ins },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "p1",
                |m: &DebugMoneroDiagAck| { &m.p1 },
                |m: &mut DebugMoneroDiagAck| { &mut m.p1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "p2",
                |m: &DebugMoneroDiagAck| { &m.p2 },
                |m: &mut DebugMoneroDiagAck| { &mut m.p2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "pd",
                |m: &DebugMoneroDiagAck| { &m.pd },
                |m: &mut DebugMoneroDiagAck| { &mut m.pd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data1",
                |m: &DebugMoneroDiagAck| { &m.data1 },
                |m: &mut DebugMoneroDiagAck| { &mut m.data1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data2",
                |m: &DebugMoneroDiagAck| { &m.data2 },
                |m: &mut DebugMoneroDiagAck| { &mut m.data2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugMoneroDiagAck>(
                "DebugMoneroDiagAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugMoneroDiagAck {
        static instance: ::protobuf::rt::LazyV2<DebugMoneroDiagAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugMoneroDiagAck::new)
    }
}

impl ::protobuf::Clear for DebugMoneroDiagAck {
    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1.clear();
        self.data2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugMoneroDiagAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-monero.proto\x12\x19hw.trezor.messages.monero\"\xc9\x06\n\
    \x1cMoneroTransactionSourceEntry\x12c\n\x07outputs\x18\x01\x20\x03(\x0b2\
    I.hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEnt\
    ryR\x07outputs\x12\x1f\n\x0breal_output\x18\x02\x20\x01(\x04R\nrealOutpu\
    t\x12%\n\x0freal_out_tx_key\x18\x03\x20\x01(\x0cR\x0crealOutTxKey\x12<\n\
    \x1breal_out_additional_tx_keys\x18\x04\x20\x03(\x0cR\x17realOutAddition\
    alTxKeys\x124\n\x17real_output_in_tx_index\x18\x05\x20\x01(\x04R\x13real\
    OutputInTxIndex\x12\x16\n\x06amount\x18\x06\x20\x01(\x04R\x06amount\x12\
    \x10\n\x03rct\x18\x07\x20\x01(\x08R\x03rct\x12\x12\n\x04mask\x18\x08\x20\
    \x01(\x0cR\x04mask\x12r\n\x0emultisig_kLRki\x18\t\x20\x01(\x0b2K.hw.trez\
    or.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRkiR\rmu\
    ltisigKLRki\x12#\n\rsubaddr_minor\x18\n\x20\x01(\rR\x0csubaddrMinor\x1a\
    \xdf\x01\n\x11MoneroOutputEntry\x12\x10\n\x03idx\x18\x01\x20\x01(\x04R\
    \x03idx\x12n\n\x03key\x18\x02\x20\x01(\x0b2\\.hw.trezor.messages.monero.\
    MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKeyPublicR\x03ke\
    y\x1aH\n\x12MoneroRctKeyPublic\x12\x12\n\x04dest\x18\x01\x20\x01(\x0cR\
    \x04dest\x12\x1e\n\ncommitment\x18\x02\x20\x01(\x0cR\ncommitment\x1aO\n\
    \x13MoneroMultisigKLRki\x12\x0c\n\x01K\x18\x01\x20\x01(\x0cR\x01K\x12\
    \x0c\n\x01L\x18\x02\x20\x01(\x0cR\x01L\x12\x0c\n\x01R\x18\x03\x20\x01(\
    \x0cR\x01R\x12\x0e\n\x02ki\x18\x04\x20\x01(\x0cR\x02ki\"\xfe\x02\n!Moner\
    oTransactionDestinationEntry\x12\x16\n\x06amount\x18\x01\x20\x01(\x04R\
    \x06amount\x12k\n\x04addr\x18\x02\x20\x01(\x0b2W.hw.trezor.messages.mone\
    ro.MoneroTransactionDestinationEntry.MoneroAccountPublicAddressR\x04addr\
    \x12#\n\ris_subaddress\x18\x03\x20\x01(\x08R\x0cisSubaddress\x12\x1a\n\
    \x08original\x18\x04\x20\x01(\x0cR\x08original\x12#\n\ris_integrated\x18\
    \x05\x20\x01(\x08R\x0cisIntegrated\x1an\n\x1aMoneroAccountPublicAddress\
    \x12(\n\x10spend_public_key\x18\x01\x20\x01(\x0cR\x0espendPublicKey\x12&\
    \n\x0fview_public_key\x18\x02\x20\x01(\x0cR\rviewPublicKey\"\xdd\x01\n\
    \x19MoneroTransactionRsigData\x12\x1b\n\trsig_type\x18\x01\x20\x01(\rR\
    \x08rsigType\x12!\n\x0coffload_type\x18\x02\x20\x01(\rR\x0boffloadType\
    \x12\x1a\n\x08grouping\x18\x03\x20\x03(\x04R\x08grouping\x12\x12\n\x04ma\
    sk\x18\x04\x20\x01(\x0cR\x04mask\x12\x12\n\x04rsig\x18\x05\x20\x01(\x0cR\
    \x04rsig\x12\x1d\n\nrsig_parts\x18\x06\x20\x03(\x0cR\trsigParts\x12\x1d\
    \n\nbp_version\x18\x07\x20\x01(\rR\tbpVersion\"\xc4\x01\n\x10MoneroGetAd\
    dress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0csho\
    w_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\x12!\n\x0cnetwork_type\
    \x18\x03\x20\x01(\rR\x0bnetworkType\x12\x18\n\x07account\x18\x04\x20\x01\
    (\rR\x07account\x12\x14\n\x05minor\x18\x05\x20\x01(\rR\x05minor\x12\x1d\
    \n\npayment_id\x18\x06\x20\x01(\x0cR\tpaymentId\")\n\rMoneroAddress\x12\
    \x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\"S\n\x11MoneroGetWatc\
    hKey\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0cnetw\
    ork_type\x18\x02\x20\x01(\rR\x0bnetworkType\"G\n\x0eMoneroWatchKey\x12\
    \x1b\n\twatch_key\x18\x01\x20\x01(\x0cR\x08watchKey\x12\x18\n\x07address\
    \x18\x02\x20\x01(\x0cR\x07address\"\xfe\x06\n\x1cMoneroTransactionInitRe\
    quest\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1b\n\tadd\
    ress_n\x18\x02\x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x03\
    \x20\x01(\rR\x0bnetworkType\x12h\n\x08tsx_data\x18\x04\x20\x01(\x0b2M.hw\
    .trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionDa\
    taR\x07tsxData\x1a\x99\x05\n\x15MoneroTransactionData\x12\x18\n\x07versi\
    on\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\npayment_id\x18\x02\x20\x01(\
    \x0cR\tpaymentId\x12\x1f\n\x0bunlock_time\x18\x03\x20\x01(\x04R\nunlockT\
    ime\x12V\n\x07outputs\x18\x04\x20\x03(\x0b2<.hw.trezor.messages.monero.M\
    oneroTransactionDestinationEntryR\x07outputs\x12[\n\nchange_dts\x18\x05\
    \x20\x01(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDestinationEn\
    tryR\tchangeDts\x12\x1d\n\nnum_inputs\x18\x06\x20\x01(\rR\tnumInputs\x12\
    \x14\n\x05mixin\x18\x07\x20\x01(\rR\x05mixin\x12\x10\n\x03fee\x18\x08\
    \x20\x01(\x04R\x03fee\x12\x18\n\x07account\x18\t\x20\x01(\rR\x07account\
    \x12#\n\rminor_indices\x18\n\x20\x03(\rR\x0cminorIndices\x12Q\n\trsig_da\
    ta\x18\x0b\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsi\
    gDataR\x08rsigData\x12-\n\x12integrated_indices\x18\x0c\x20\x03(\rR\x11i\
    ntegratedIndices\x12%\n\x0eclient_version\x18\r\x20\x01(\rR\rclientVersi\
    on\x12\x1b\n\thard_fork\x18\x0e\x20\x01(\rR\x08hardFork\x12%\n\x0emonero\
    _version\x18\x0f\x20\x01(\x0cR\rmoneroVersion\"\x83\x01\n\x18MoneroTrans\
    actionInitAck\x12\x14\n\x05hmacs\x18\x01\x20\x03(\x0cR\x05hmacs\x12Q\n\t\
    rsig_data\x18\x02\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransac\
    tionRsigDataR\x08rsigData\"v\n\x20MoneroTransactionSetInputRequest\x12R\
    \n\x08src_entr\x18\x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTr\
    ansactionSourceEntryR\x07srcEntr\"\xdd\x01\n\x1cMoneroTransactionSetInpu\
    tAck\x12\x12\n\x04vini\x18\x01\x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hma\
    c\x18\x02\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\x03\x20\
    \x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x04\x20\x01(\x0cR\rp\
    seudoOutHmac\x12(\n\x10pseudo_out_alpha\x18\x05\x20\x01(\x0cR\x0epseudoO\
    utAlpha\x12\x1b\n\tspend_key\x18\x06\x20\x01(\x0cR\x08spendKey\"?\n)Mone\
    roTransactionInputsPermutationRequest\x12\x12\n\x04perm\x18\x01\x20\x03(\
    \rR\x04perm\"'\n%MoneroTransactionInputsPermutationAck\"\x8a\x02\n!Moner\
    oTransactionInputViniRequest\x12R\n\x08src_entr\x18\x01\x20\x01(\x0b27.h\
    w.trezor.messages.monero.MoneroTransactionSourceEntryR\x07srcEntr\x12\
    \x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hmac\x18\
    \x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\x04\x20\x01(\
    \x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\x20\x01(\x0cR\rpseudo\
    OutHmac\x12\x19\n\x08orig_idx\x18\x06\x20\x01(\rR\x07origIdx\"\x1f\n\x1d\
    MoneroTransactionInputViniAck\"&\n$MoneroTransactionAllInputsSetRequest\
    \"u\n\x20MoneroTransactionAllInputsSetAck\x12Q\n\trsig_data\x18\x01\x20\
    \x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08rsig\
    Data\"\x9b\x02\n!MoneroTransactionSetOutputRequest\x12W\n\x08dst_entr\
    \x18\x01\x20\x01(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDesti\
    nationEntryR\x07dstEntr\x12\"\n\rdst_entr_hmac\x18\x02\x20\x01(\x0cR\x0b\
    dstEntrHmac\x12Q\n\trsig_data\x18\x03\x20\x01(\x0b24.hw.trezor.messages.\
    monero.MoneroTransactionRsigDataR\x08rsigData\x12&\n\x0fis_offloaded_bp\
    \x18\x04\x20\x01(\x08R\risOffloadedBp\"\xdc\x01\n\x1dMoneroTransactionSe\
    tOutputAck\x12\x15\n\x06tx_out\x18\x01\x20\x01(\x0cR\x05txOut\x12\x1d\n\
    \nvouti_hmac\x18\x02\x20\x01(\x0cR\tvoutiHmac\x12Q\n\trsig_data\x18\x03\
    \x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08\
    rsigData\x12\x15\n\x06out_pk\x18\x04\x20\x01(\x0cR\x05outPk\x12\x1b\n\te\
    cdh_info\x18\x05\x20\x01(\x0cR\x08ecdhInfo\"v\n!MoneroTransactionAllOutS\
    etRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\x0b24.hw.trezor.messages.mo\
    nero.MoneroTransactionRsigDataR\x08rsigData\"\xc0\x02\n\x1dMoneroTransac\
    tionAllOutSetAck\x12\x14\n\x05extra\x18\x01\x20\x01(\x0cR\x05extra\x12$\
    \n\x0etx_prefix_hash\x18\x02\x20\x01(\x0cR\x0ctxPrefixHash\x12X\n\x02rv\
    \x18\x04\x20\x01(\x0b2H.hw.trezor.messages.monero.MoneroTransactionAllOu\
    tSetAck.MoneroRingCtSigR\x02rv\x12*\n\x11full_message_hash\x18\x05\x20\
    \x01(\x0cR\x0ffullMessageHash\x1a]\n\x0fMoneroRingCtSig\x12\x17\n\x07txn\
    _fee\x18\x01\x20\x01(\x04R\x06txnFee\x12\x18\n\x07message\x18\x02\x20\
    \x01(\x0cR\x07message\x12\x17\n\x07rv_type\x18\x03\x20\x01(\rR\x06rvType\
    \"\xd1\x02\n!MoneroTransactionSignInputRequest\x12R\n\x08src_entr\x18\
    \x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTransactionSourceEnt\
    ryR\x07srcEntr\x12\x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\x12\x1b\n\
    \tvini_hmac\x18\x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\
    \x04\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\x20\x01(\
    \x0cR\rpseudoOutHmac\x12(\n\x10pseudo_out_alpha\x18\x06\x20\x01(\x0cR\
    \x0epseudoOutAlpha\x12\x1b\n\tspend_key\x18\x07\x20\x01(\x0cR\x08spendKe\
    y\x12\x19\n\x08orig_idx\x18\x08\x20\x01(\rR\x07origIdx\"\\\n\x1dMoneroTr\
    ansactionSignInputAck\x12\x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignat\
    ure\x12\x1d\n\npseudo_out\x18\x02\x20\x01(\x0cR\tpseudoOut\"\x1f\n\x1dMo\
    neroTransactionFinalRequest\"\xa8\x01\n\x19MoneroTransactionFinalAck\x12\
    \x19\n\x08cout_key\x18\x01\x20\x01(\x0cR\x07coutKey\x12\x12\n\x04salt\
    \x18\x02\x20\x01(\x0cR\x04salt\x12\x1b\n\trand_mult\x18\x03\x20\x01(\x0c\
    R\x08randMult\x12\x1e\n\x0btx_enc_keys\x18\x04\x20\x01(\x0cR\ttxEncKeys\
    \x12\x1f\n\x0bopening_key\x18\x05\x20\x01(\x0cR\nopeningKey\"\xd1\x02\n\
    \x1fMoneroKeyImageExportInitRequest\x12\x10\n\x03num\x18\x01\x20\x01(\
    \x04R\x03num\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1b\n\t\
    address_n\x18\x03\x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x04\
    \x20\x01(\rR\x0bnetworkType\x12j\n\x04subs\x18\x05\x20\x03(\x0b2V.hw.tre\
    zor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndi\
    cesListR\x04subs\x1a\\\n\x1bMoneroSubAddressIndicesList\x12\x18\n\x07acc\
    ount\x18\x01\x20\x01(\rR\x07account\x12#\n\rminor_indices\x18\x02\x20\
    \x03(\rR\x0cminorIndices\"\x1d\n\x1bMoneroKeyImageExportInitAck\"\x89\
    \x03\n\x1dMoneroKeyImageSyncStepRequest\x12b\n\x04tdis\x18\x01\x20\x03(\
    \x0b2N.hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTra\
    nsferDetailsR\x04tdis\x1a\x83\x02\n\x15MoneroTransferDetails\x12\x17\n\
    \x07out_key\x18\x01\x20\x01(\x0cR\x06outKey\x12\x1c\n\ntx_pub_key\x18\
    \x02\x20\x01(\x0cR\x08txPubKey\x123\n\x16additional_tx_pub_keys\x18\x03\
    \x20\x03(\x0cR\x13additionalTxPubKeys\x122\n\x15internal_output_index\
    \x18\x04\x20\x01(\x04R\x13internalOutputIndex\x12$\n\x0esub_addr_major\
    \x18\x05\x20\x01(\rR\x0csubAddrMajor\x12$\n\x0esub_addr_minor\x18\x06\
    \x20\x01(\rR\x0csubAddrMinor\"\xb8\x01\n\x19MoneroKeyImageSyncStepAck\
    \x12]\n\x03kis\x18\x01\x20\x03(\x0b2K.hw.trezor.messages.monero.MoneroKe\
    yImageSyncStepAck.MoneroExportedKeyImageR\x03kis\x1a<\n\x16MoneroExporte\
    dKeyImage\x12\x0e\n\x02iv\x18\x01\x20\x01(\x0cR\x02iv\x12\x12\n\x04blob\
    \x18\x03\x20\x01(\x0cR\x04blob\"\x20\n\x1eMoneroKeyImageSyncFinalRequest\
    \"5\n\x1aMoneroKeyImageSyncFinalAck\x12\x17\n\x07enc_key\x18\x01\x20\x01\
    (\x0cR\x06encKey\"\x89\x02\n\x15MoneroGetTxKeyRequest\x12\x1b\n\taddress\
    _n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x02\x20\
    \x01(\rR\x0bnetworkType\x12\x14\n\x05salt1\x18\x03\x20\x01(\x0cR\x05salt\
    1\x12\x14\n\x05salt2\x18\x04\x20\x01(\x0cR\x05salt2\x12\x1e\n\x0btx_enc_\
    keys\x18\x05\x20\x01(\x0cR\ttxEncKeys\x12$\n\x0etx_prefix_hash\x18\x06\
    \x20\x01(\x0cR\x0ctxPrefixHash\x12\x16\n\x06reason\x18\x07\x20\x01(\rR\
    \x06reason\x12&\n\x0fview_public_key\x18\x08\x20\x01(\x0cR\rviewPublicKe\
    y\"g\n\x11MoneroGetTxKeyAck\x12\x12\n\x04salt\x18\x01\x20\x01(\x0cR\x04s\
    alt\x12\x17\n\x07tx_keys\x18\x02\x20\x01(\x0cR\x06txKeys\x12%\n\x0etx_de\
    rivations\x18\x03\x20\x01(\x0cR\rtxDerivations\"_\n\x1dMoneroLiveRefresh\
    StartRequest\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\
    \x0cnetwork_type\x18\x02\x20\x01(\rR\x0bnetworkType\"\x1b\n\x19MoneroLiv\
    eRefreshStartAck\"\xc4\x01\n\x1cMoneroLiveRefreshStepRequest\x12\x17\n\
    \x07out_key\x18\x01\x20\x01(\x0cR\x06outKey\x12\x1d\n\nrecv_deriv\x18\
    \x02\x20\x01(\x0cR\trecvDeriv\x12\x20\n\x0creal_out_idx\x18\x03\x20\x01(\
    \x04R\nrealOutIdx\x12$\n\x0esub_addr_major\x18\x04\x20\x01(\rR\x0csubAdd\
    rMajor\x12$\n\x0esub_addr_minor\x18\x05\x20\x01(\rR\x0csubAddrMinor\"K\n\
    \x18MoneroLiveRefreshStepAck\x12\x12\n\x04salt\x18\x01\x20\x01(\x0cR\x04\
    salt\x12\x1b\n\tkey_image\x18\x02\x20\x01(\x0cR\x08keyImage\"\x1f\n\x1dM\
    oneroLiveRefreshFinalRequest\"\x1b\n\x19MoneroLiveRefreshFinalAck\"\x86\
    \x01\n\x16DebugMoneroDiagRequest\x12\x10\n\x03ins\x18\x01\x20\x01(\x04R\
    \x03ins\x12\x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02p1\x12\x0e\n\x02p2\x18\
    \x03\x20\x01(\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\x20\x03(\x04R\x02pd\x12\
    \x14\n\x05data1\x18\x05\x20\x01(\x0cR\x05data1\x12\x14\n\x05data2\x18\
    \x06\x20\x01(\x0cR\x05data2\"\x82\x01\n\x12DebugMoneroDiagAck\x12\x10\n\
    \x03ins\x18\x01\x20\x01(\x04R\x03ins\x12\x0e\n\x02p1\x18\x02\x20\x01(\
    \x04R\x02p1\x12\x0e\n\x02p2\x18\x03\x20\x01(\x04R\x02p2\x12\x0e\n\x02pd\
    \x18\x04\x20\x03(\x04R\x02pd\x12\x14\n\x05data1\x18\x05\x20\x01(\x0cR\
    \x05data1\x12\x14\n\x05data2\x18\x06\x20\x01(\x0cR\x05data2B:\n#com.sato\
    shilabs.trezor.lib.protobufB\x13TrezorMessageMoneroJ\xe0\x9e\x01\n\x07\
    \x12\x05\0\0\xfd\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x01\x08!\n\x08\n\x01\x08\x12\x03\x04\0<\n.\n\x02\x08\x01\x12\
    \x03\x04\0<\x1a#\x20Sugar\x20for\x20easier\x20handling\x20in\x20Java\n\n\
    \x08\n\x01\x08\x12\x03\x05\04\n\t\n\x02\x08\x08\x12\x03\x05\04\nT\n\x02\
    \x04\0\x12\x04\x0b\0$\x01\x1aH*\n\x20Structure\x20representing\x20Monero\
    \x20transaction\x20source\x20entry,\x20UTXO\n\x20@embed\n\n\n\n\x03\x04\
    \0\x01\x12\x03\x0b\x08$\n<\n\x04\x04\0\x02\0\x12\x03\x0c\x04+\"/\x20all\
    \x20outputs\x20including\x20decoys\x20(forms\x20the\x20ring)\n\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03\x0c\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x06\x12\
    \x03\x0c\r\x1e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\x1f&\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x0c)*\nV\n\x04\x04\0\x02\x01\x12\x03\r\x04$\"I\
    \x20index\x20denoting\x20which\x20item\x20in\x20`outputs`\x20is\x20our\
    \x20real\x20output\x20(not\x20a\x20decoy)\n\n\x0c\n\x05\x04\0\x02\x01\
    \x04\x12\x03\r\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\r\r\x13\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03\r\x14\x1f\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03\r\"#\n5\n\x04\x04\0\x02\x02\x12\x03\x0e\x04'\"(\x20tx\x20ke\
    y\x20located\x20in\x20the\x20real\x20output's\x20tx\n\n\x0c\n\x05\x04\0\
    \x02\x02\x04\x12\x03\x0e\x04\x0c\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\
    \x0e\r\x12\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0e\x13\"\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03\x0e%&\n/\n\x04\x04\0\x02\x03\x12\x03\x0f\x043\
    \"\"\x20additional\x20tx\x20keys\x20if\x20applicable\n\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x03\x0f\x04\x0c\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\
    \x0f\r\x12\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x0f\x13.\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x0f12\n^\n\x04\x04\0\x02\x04\x12\x03\x10\x040\
    \"Q\x20index\x20of\x20our\x20real\x20output\x20in\x20the\x20tx\x20(aka\
    \x20which\x20output\x20was\x20it\x20in\x20the\x20transaction)\n\n\x0c\n\
    \x05\x04\0\x02\x04\x04\x12\x03\x10\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x05\
    \x12\x03\x10\r\x13\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x10\x14+\n\x0c\
    \n\x05\x04\0\x02\x04\x03\x12\x03\x10./\n\x0b\n\x04\x04\0\x02\x05\x12\x03\
    \x11\x04\x1f\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x11\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x05\x05\x12\x03\x11\r\x13\n\x0c\n\x05\x04\0\x02\x05\x01\
    \x12\x03\x11\x14\x1a\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x11\x1d\x1e\n\
    4\n\x04\x04\0\x02\x06\x12\x03\x12\x04\x1a\"'\x20is\x20RingCT\x20used\x20\
    (true\x20for\x20newer\x20UTXOs)\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\
    \x12\x04\x0c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x12\r\x11\n\x0c\n\x05\
    \x04\0\x02\x06\x01\x12\x03\x12\x12\x15\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03\x12\x18\x19\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x13\x04\x1c\n\x0c\n\
    \x05\x04\0\x02\x07\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\x07\x05\
    \x12\x03\x13\r\x12\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x13\x13\x17\n\
    \x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x13\x1a\x1b\n\x0b\n\x04\x04\0\x02\
    \x08\x12\x03\x14\x044\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x03\x14\x04\x0c\
    \n\x0c\n\x05\x04\0\x02\x08\x06\x12\x03\x14\r\x20\n\x0c\n\x05\x04\0\x02\
    \x08\x01\x12\x03\x14!/\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1423\n3\n\
    \x04\x04\0\x02\t\x12\x03\x15\x04'\"&\x20minor\x20subaddr\x20index\x20UTX\
    O\x20was\x20sent\x20to\n\n\x0c\n\x05\x04\0\x02\t\x04\x12\x03\x15\x04\x0c\
    \n\x0c\n\x05\x04\0\x02\t\x05\x12\x03\x15\r\x13\n\x0c\n\x05\x04\0\x02\t\
    \x01\x12\x03\x15\x14!\n\x0c\n\x05\x04\0\x02\t\x03\x12\x03\x15$&\n\x0c\n\
    \x04\x04\0\x03\0\x12\x04\x16\x04\x1d\x05\n\x0c\n\x05\x04\0\x03\0\x01\x12\
    \x03\x16\x0c\x1d\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\x17\x08\x20\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x04\x12\x03\x17\x08\x10\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x05\x12\x03\x17\x11\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\
    \x17\x18\x1b\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x17\x1e\x1f\n\r\n\
    \x06\x04\0\x03\0\x02\x01\x12\x03\x18\x08,\n\x0e\n\x07\x04\0\x03\0\x02\
    \x01\x04\x12\x03\x18\x08\x10\n\x0e\n\x07\x04\0\x03\0\x02\x01\x06\x12\x03\
    \x18\x11#\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x18$'\n\x0e\n\x07\
    \x04\0\x03\0\x02\x01\x03\x12\x03\x18*+\n\x0e\n\x06\x04\0\x03\0\x03\0\x12\
    \x04\x19\x08\x1c\t\n\x0e\n\x07\x04\0\x03\0\x03\0\x01\x12\x03\x19\x10\"\n\
    \x0f\n\x08\x04\0\x03\0\x03\0\x02\0\x12\x03\x1a\x0c$\n\x10\n\t\x04\0\x03\
    \0\x03\0\x02\0\x04\x12\x03\x1a\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\
    \x05\x12\x03\x1a\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x01\x12\x03\
    \x1a\x1b\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x03\x12\x03\x1a\"#\n\x0f\
    \n\x08\x04\0\x03\0\x03\0\x02\x01\x12\x03\x1b\x0c*\n\x10\n\t\x04\0\x03\0\
    \x03\0\x02\x01\x04\x12\x03\x1b\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\x02\
    \x01\x05\x12\x03\x1b\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x01\x12\
    \x03\x1b\x1b%\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x03\x12\x03\x1b()\n\
    \x0c\n\x04\x04\0\x03\x01\x12\x04\x1e\x04#\x05\n\x0c\n\x05\x04\0\x03\x01\
    \x01\x12\x03\x1e\x0c\x1f\n\r\n\x06\x04\0\x03\x01\x02\0\x12\x03\x1f\x08\
    \x1d\n\x0e\n\x07\x04\0\x03\x01\x02\0\x04\x12\x03\x1f\x08\x10\n\x0e\n\x07\
    \x04\0\x03\x01\x02\0\x05\x12\x03\x1f\x11\x16\n\x0e\n\x07\x04\0\x03\x01\
    \x02\0\x01\x12\x03\x1f\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\0\x03\x12\
    \x03\x1f\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x03\x20\x08\x1d\n\
    \x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x03\x20\x08\x10\n\x0e\n\x07\x04\
    \0\x03\x01\x02\x01\x05\x12\x03\x20\x11\x16\n\x0e\n\x07\x04\0\x03\x01\x02\
    \x01\x01\x12\x03\x20\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x03\x12\
    \x03\x20\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x02\x12\x03!\x08\x1d\n\x0e\
    \n\x07\x04\0\x03\x01\x02\x02\x04\x12\x03!\x08\x10\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x02\x05\x12\x03!\x11\x16\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x01\
    \x12\x03!\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x03!\x1b\x1c\
    \n\r\n\x06\x04\0\x03\x01\x02\x03\x12\x03\"\x08\x1e\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x03\x04\x12\x03\"\x08\x10\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x05\
    \x12\x03\"\x11\x16\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x01\x12\x03\"\x17\
    \x19\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x03\x12\x03\"\x1c\x1d\nS\n\x02\
    \x04\x01\x12\x04*\07\x01\x1aG*\n\x20Structure\x20representing\x20Monero\
    \x20transaction\x20destination\x20entry\n\x20@embed\n\n\n\n\x03\x04\x01\
    \x01\x12\x03*\x08)\n\x0b\n\x04\x04\x01\x02\0\x12\x03+\x04\x1f\n\x0c\n\
    \x05\x04\x01\x02\0\x04\x12\x03+\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03+\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03+\x14\x1a\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03+\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x01\x12\
    \x03,\x041\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03,\x04\x0c\n\x0c\n\x05\
    \x04\x01\x02\x01\x06\x12\x03,\r'\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\
    ,(,\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03,/0\n\x0b\n\x04\x04\x01\x02\
    \x02\x12\x03-\x04$\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03-\x04\x0c\n\
    \x0c\n\x05\x04\x01\x02\x02\x05\x12\x03-\r\x11\n\x0c\n\x05\x04\x01\x02\
    \x02\x01\x12\x03-\x12\x1f\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03-\"#\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x03.\x04\x20\n\x0c\n\x05\x04\x01\x02\x03\
    \x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03.\r\x12\n\
    \x0c\n\x05\x04\x01\x02\x03\x01\x12\x03.\x13\x1b\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03.\x1e\x1f\n\x0b\n\x04\x04\x01\x02\x04\x12\x03/\x04$\n\
    \x0c\n\x05\x04\x01\x02\x04\x04\x12\x03/\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x04\x05\x12\x03/\r\x11\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03/\x12\x1f\
    \n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03/\"#\n>\n\x04\x04\x01\x03\0\x12\
    \x043\x046\x05\x1a0*\n\x20Structure\x20representing\x20Monero\x20public\
    \x20address\n\n\x0c\n\x05\x04\x01\x03\0\x01\x12\x033\x0c&\n\r\n\x06\x04\
    \x01\x03\0\x02\0\x12\x034\x08,\n\x0e\n\x07\x04\x01\x03\0\x02\0\x04\x12\
    \x034\x08\x10\n\x0e\n\x07\x04\x01\x03\0\x02\0\x05\x12\x034\x11\x16\n\x0e\
    \n\x07\x04\x01\x03\0\x02\0\x01\x12\x034\x17'\n\x0e\n\x07\x04\x01\x03\0\
    \x02\0\x03\x12\x034*+\n\r\n\x06\x04\x01\x03\0\x02\x01\x12\x035\x08+\n\
    \x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x035\x08\x10\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x05\x12\x035\x11\x16\n\x0e\n\x07\x04\x01\x03\0\x02\
    \x01\x01\x12\x035\x17&\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x035)*\
    \n4\n\x02\x04\x02\x12\x04=\0F\x01\x1a(*\n\x20Range\x20sig\x20parameters\
    \x20/\x20data.\n\x20@embed\n\n\n\n\x03\x04\x02\x01\x12\x03=\x08!\n/\n\
    \x04\x04\x02\x02\0\x12\x03>\x04\"\"\"\x20range\x20signature\x20(aka\x20p\
    roof)\x20type\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03>\x04\x0c\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03>\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03>\x14\x1d\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03>\x20!\n\x0b\n\x04\
    \x04\x02\x02\x01\x12\x03?\x04%\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03?\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03?\r\x13\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03?\x14\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03?#$\n(\n\x04\x04\x02\x02\x02\x12\x03@\x04!\"\x1b\x20aggregation\x20s\
    cheme\x20for\x20BP\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03@\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x03@\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03@\x14\x1c\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03@\x1f\
    \x20\n\x1a\n\x04\x04\x02\x02\x03\x12\x03B\x04\x1c\"\r\x20mask\x20vector\
    \n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03B\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x03\x05\x12\x03B\r\x12\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03B\x13\
    \x17\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03B\x1a\x1b\nI\n\x04\x04\x02\
    \x02\x04\x12\x03C\x04\x1c\"<\x20range\x20sig\x20data,\x20all\x20of\x20it\
    \x20or\x20partial\x20(based\x20on\x20rsig_parts)\n\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03C\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03C\r\
    \x12\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03C\x13\x17\n\x0c\n\x05\x04\
    \x02\x02\x04\x03\x12\x03C\x1a\x1b\n\x0b\n\x04\x04\x02\x02\x05\x12\x03D\
    \x04\"\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03D\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x05\x05\x12\x03D\r\x12\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03D\
    \x13\x1d\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03D\x20!\n\"\n\x04\x04\x02\
    \x02\x06\x12\x03E\x04#\"\x15\x20Bulletproof\x20version\n\n\x0c\n\x05\x04\
    \x02\x02\x06\x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\
    \x03E\r\x13\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03E\x14\x1e\n\x0c\n\x05\
    \x04\x02\x02\x06\x03\x12\x03E!\"\n\x82\x01\n\x02\x04\x03\x12\x04N\0U\x01\
    \x1av*\n\x20Request:\x20Ask\x20device\x20for\x20public\x20address\x20der\
    ived\x20from\x20seed\x20and\x20address_n\n\x20@start\n\x20@next\x20Moner\
    oAddress\n\x20@next\x20Failure\n\n\n\n\x03\x04\x03\x01\x12\x03N\x08\x18\
    \n=\n\x04\x04\x03\x02\0\x12\x03O\x04\"\"0\x20BIP-32\x20path\x20to\x20der\
    ive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x03O\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03O\r\x13\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03O\x14\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03O\x20!\nC\n\x04\x04\x03\x02\x01\x12\x03P\x04#\"6\x20Optionally\
    \x20show\x20on\x20display\x20before\x20sending\x20the\x20result\n\n\x0c\
    \n\x05\x04\x03\x02\x01\x04\x12\x03P\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x03P\r\x11\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03P\x12\x1e\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03P!\"\n,\n\x04\x04\x03\x02\x02\x12\
    \x03Q\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stagenet\n\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03Q\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03Q\x14\x20\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03Q#$\n\"\n\x04\x04\x03\x02\x03\x12\
    \x03R\x04\x20\"\x15\x20Major\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\
    \x02\x03\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03R\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03R\x14\x1b\n\x0c\n\x05\x04\
    \x03\x02\x03\x03\x12\x03R\x1e\x1f\n\"\n\x04\x04\x03\x02\x04\x12\x03S\x04\
    \x1e\"\x15\x20Minor\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\x02\x04\
    \x04\x12\x03S\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03S\r\x13\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x03S\x14\x19\n\x0c\n\x05\x04\x03\x02\
    \x04\x03\x12\x03S\x1c\x1d\n0\n\x04\x04\x03\x02\x05\x12\x03T\x04\"\"#\x20\
    Payment\x20ID\x20for\x20integrated\x20address\n\n\x0c\n\x05\x04\x03\x02\
    \x05\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03T\r\x12\
    \n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03T\x13\x1d\n\x0c\n\x05\x04\x03\
    \x02\x05\x03\x12\x03T\x20!\ng\n\x02\x04\x04\x12\x04[\0]\x01\x1a[*\n\x20R\
    esponse:\x20Contains\x20Monero\x20watch-only\x20credentials\x20derived\
    \x20from\x20device\x20private\x20seed\n\x20@end\n\n\n\n\x03\x04\x04\x01\
    \x12\x03[\x08\x15\n\x0b\n\x04\x04\x04\x02\0\x12\x03\\\x04\x1f\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03\\\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03\\\r\x12\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\\\x13\x1a\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03\\\x1d\x1e\nk\n\x02\x04\x05\x12\x04e\0h\
    \x01\x1a_*\n\x20Request:\x20Ask\x20device\x20for\x20watch\x20only\x20cre\
    dentials\n\x20@start\n\x20@next\x20MoneroWatchKey\n\x20@next\x20Failure\
    \n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\x19\n=\n\x04\x04\x05\x02\0\x12\x03\
    f\x04\"\"0\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20ma\
    ster\x20node\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03f\x04\x0c\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03f\r\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03f\x14\x1d\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03f\x20!\n,\n\x04\x04\
    \x05\x02\x01\x12\x03g\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20sta\
    genet\n\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03g\r\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03g\
    \x14\x20\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03g#$\ng\n\x02\x04\x06\x12\
    \x04n\0q\x01\x1a[*\n\x20Response:\x20Contains\x20Monero\x20watch-only\
    \x20credentials\x20derived\x20from\x20device\x20private\x20seed\n\x20@en\
    d\n\n\n\n\x03\x04\x06\x01\x12\x03n\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03o\x04!\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03o\x04\x0c\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03o\r\x12\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03o\
    \x13\x1c\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03o\x1f\x20\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03p\x04\x1f\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03p\
    \x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03p\r\x12\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03p\x13\x1a\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03p\x1d\x1e\n\x88\x01\n\x02\x04\x07\x12\x05x\0\x91\x01\x01\x1a{*\n\x20\
    Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Initialize\
    s\x20transaction\x20signing.\n\x20@start\n\x20@next\x20MoneroTransaction\
    InitAck\n\n\n\n\x03\x04\x07\x01\x12\x03x\x08$\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03y\x04\x20\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03y\x04\x0c\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03y\r\x13\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03y\x14\x1b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03y\x1e\x1f\n\x0b\n\x04\
    \x04\x07\x02\x01\x12\x03z\x04\"\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03z\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03z\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03z\x14\x1d\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\
    \x03z\x20!\n,\n\x04\x04\x07\x02\x02\x12\x03{\x04%\"\x1f\x20Main-net\x20/\
    \x20testnet\x20/\x20stagenet\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03{\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03{\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03{\x14\x20\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03{#$\n\x0b\n\x04\x04\x07\x02\x03\x12\x03|\x040\n\x0c\n\x05\x04\x07\
    \x02\x03\x04\x12\x03|\x04\x0c\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03|\r\
    \"\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03|#+\n\x0c\n\x05\x04\x07\x02\
    \x03\x03\x12\x03|./\nQ\n\x04\x04\x07\x03\0\x12\x06\x80\x01\x04\x90\x01\
    \x05\x1aA*\n\x20Structure\x20representing\x20Monero\x20initial\x20transa\
    ction\x20information\n\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x80\x01\x0c!\
    \n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x81\x01\x08$\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x04\x12\x04\x81\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\
    \x02\0\x05\x12\x04\x81\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\
    \x12\x04\x81\x01\x18\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\x81\
    \x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\x82\x01\x08&\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x04\x12\x04\x82\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x05\x12\x04\x82\x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x01\x12\x04\x82\x01\x17!\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x03\
    \x12\x04\x82\x01$%\n\x0e\n\x06\x04\x07\x03\0\x02\x02\x12\x04\x83\x01\x08\
    (\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\x12\x04\x83\x01\x08\x10\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x02\x05\x12\x04\x83\x01\x11\x17\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x02\x01\x12\x04\x83\x01\x18#\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x02\x03\x12\x04\x83\x01&'\n\x0e\n\x06\x04\x07\x03\0\x02\x03\x12\x04\
    \x84\x01\x08?\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x04\x12\x04\x84\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x06\x12\x04\x84\x01\x112\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x03\x01\x12\x04\x84\x013:\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x03\x03\x12\x04\x84\x01=>\n\x0e\n\x06\x04\x07\x03\0\x02\x04\x12\
    \x04\x85\x01\x08B\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x04\x12\x04\x85\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x06\x12\x04\x85\x01\x112\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x04\x01\x12\x04\x85\x013=\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x04\x03\x12\x04\x85\x01@A\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x05\x12\x04\x86\x01\x08'\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x04\x12\x04\
    \x86\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x05\x12\x04\x86\x01\
    \x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x01\x12\x04\x86\x01\x18\"\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x05\x03\x12\x04\x86\x01%&\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x06\x12\x04\x87\x01\x08\"\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x06\x04\x12\x04\x87\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x05\
    \x12\x04\x87\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x01\x12\x04\
    \x87\x01\x18\x1d\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x03\x12\x04\x87\x01\
    \x20!\n\x0e\n\x06\x04\x07\x03\0\x02\x07\x12\x04\x88\x01\x08\x20\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x07\x04\x12\x04\x88\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x07\x05\x12\x04\x88\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x07\x01\x12\x04\x88\x01\x18\x1b\n\x0f\n\x07\x04\x07\x03\0\x02\x07\
    \x03\x12\x04\x88\x01\x1e\x1f\n\x0e\n\x06\x04\x07\x03\0\x02\x08\x12\x04\
    \x89\x01\x08$\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x04\x12\x04\x89\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x05\x12\x04\x89\x01\x11\x17\n\x0f\
    \n\x07\x04\x07\x03\0\x02\x08\x01\x12\x04\x89\x01\x18\x1f\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x08\x03\x12\x04\x89\x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\
    \t\x12\x04\x8a\x01\x08+\n\x0f\n\x07\x04\x07\x03\0\x02\t\x04\x12\x04\x8a\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\t\x05\x12\x04\x8a\x01\x11\x17\
    \n\x0f\n\x07\x04\x07\x03\0\x02\t\x01\x12\x04\x8a\x01\x18%\n\x0f\n\x07\
    \x04\x07\x03\0\x02\t\x03\x12\x04\x8a\x01(*\n\x0e\n\x06\x04\x07\x03\0\x02\
    \n\x12\x04\x8b\x01\x08:\n\x0f\n\x07\x04\x07\x03\0\x02\n\x04\x12\x04\x8b\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\n\x06\x12\x04\x8b\x01\x11*\n\
    \x0f\n\x07\x04\x07\x03\0\x02\n\x01\x12\x04\x8b\x01+4\n\x0f\n\x07\x04\x07\
    \x03\0\x02\n\x03\x12\x04\x8b\x0179\n\x0e\n\x06\x04\x07\x03\0\x02\x0b\x12\
    \x04\x8c\x01\x080\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x04\x12\x04\x8c\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x05\x12\x04\x8c\x01\x11\x17\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x0b\x01\x12\x04\x8c\x01\x18*\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x0b\x03\x12\x04\x8c\x01-/\n*\n\x06\x04\x07\x03\0\x02\
    \x0c\x12\x04\x8d\x01\x08,\"\x1a\x20connected\x20client\x20version\n\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x0c\x04\x12\x04\x8d\x01\x08\x10\n\x0f\n\x07\
    \x04\x07\x03\0\x02\x0c\x05\x12\x04\x8d\x01\x11\x17\n\x0f\n\x07\x04\x07\
    \x03\0\x02\x0c\x01\x12\x04\x8d\x01\x18&\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x0c\x03\x12\x04\x8d\x01)+\n.\n\x06\x04\x07\x03\0\x02\r\x12\x04\x8e\x01\
    \x08'\"\x1e\x20transaction\x20hard\x20fork\x20number\n\n\x0f\n\x07\x04\
    \x07\x03\0\x02\r\x04\x12\x04\x8e\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\
    \x02\r\x05\x12\x04\x8e\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\r\x01\
    \x12\x04\x8e\x01\x18!\n\x0f\n\x07\x04\x07\x03\0\x02\r\x03\x12\x04\x8e\
    \x01$&\n)\n\x06\x04\x07\x03\0\x02\x0e\x12\x04\x8f\x01\x08+\"\x19\x20mone\
    ro\x20software\x20version\n\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x04\x12\
    \x04\x8f\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x05\x12\x04\x8f\
    \x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x01\x12\x04\x8f\x01\x17%\
    \n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x03\x12\x04\x8f\x01(*\ns\n\x02\x04\
    \x08\x12\x06\x97\x01\0\x9a\x01\x01\x1ae*\n\x20Response:\x20Response\x20t\
    o\x20transaction\x20signing\x20initialization.\n\x20@next\x20MoneroTrans\
    actionSetInputRequest\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x97\x01\x08\x20\
    \n\x0c\n\x04\x04\x08\x02\0\x12\x04\x98\x01\x04\x1d\n\r\n\x05\x04\x08\x02\
    \0\x04\x12\x04\x98\x01\x04\x0c\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x98\
    \x01\r\x12\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x98\x01\x13\x18\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\x98\x01\x1b\x1c\n\x0c\n\x04\x04\x08\x02\x01\
    \x12\x04\x99\x01\x045\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\x99\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\x99\x01\r&\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\x99\x01'0\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x99\
    \x0134\n}\n\x02\x04\t\x12\x06\xa0\x01\0\xa2\x01\x01\x1ao*\n\x20Request:\
    \x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Sends\x20one\x20UT\
    XO\x20to\x20device\n\x20@next\x20MoneroTransactionSetInputAck\n\n\x0b\n\
    \x03\x04\t\x01\x12\x04\xa0\x01\x08(\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa1\
    \x01\x047\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa1\x01\x04\x0c\n\r\n\x05\
    \x04\t\x02\0\x06\x12\x04\xa1\x01\r)\n\r\n\x05\x04\t\x02\0\x01\x12\x04\
    \xa1\x01*2\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa1\x0156\n\xd3\x01\n\x02\
    \x04\n\x12\x06\xa9\x01\0\xb0\x01\x01\x1a\xc4\x01*\n\x20Response:\x20Resp\
    onse\x20to\x20setting\x20UTXO\x20for\x20signature.\x20Contains\x20sealed\
    \x20values\x20needed\x20for\x20further\x20protocol\x20steps.\n\x20@next\
    \x20MoneroTransactionSetInputAck\n\x20@next\x20MoneroTransactionInputsPe\
    rmutationRequest\n\n\x0b\n\x03\x04\n\x01\x12\x04\xa9\x01\x08$\n\"\n\x04\
    \x04\n\x02\0\x12\x04\xaa\x01\x04\x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\xaa\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xaa\x01\r\x12\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xaa\x01\x13\x17\
    \n\r\n\x05\x04\n\x02\0\x03\x12\x04\xaa\x01\x1a\x1b\n\x0c\n\x04\x04\n\x02\
    \x01\x12\x04\xab\x01\x04!\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xab\x01\
    \x04\x0c\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\xab\x01\r\x12\n\r\n\x05\x04\
    \n\x02\x01\x01\x12\x04\xab\x01\x13\x1c\n\r\n\x05\x04\n\x02\x01\x03\x12\
    \x04\xab\x01\x1f\x20\n\x0c\n\x04\x04\n\x02\x02\x12\x04\xac\x01\x04\"\n\r\
    \n\x05\x04\n\x02\x02\x04\x12\x04\xac\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\
    \x05\x12\x04\xac\x01\r\x12\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xac\x01\
    \x13\x1d\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xac\x01\x20!\n\x0c\n\x04\
    \x04\n\x02\x03\x12\x04\xad\x01\x04'\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\
    \xad\x01\x04\x0c\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xad\x01\r\x12\n\r\n\
    \x05\x04\n\x02\x03\x01\x12\x04\xad\x01\x13\"\n\r\n\x05\x04\n\x02\x03\x03\
    \x12\x04\xad\x01%&\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xae\x01\x04(\n\r\n\
    \x05\x04\n\x02\x04\x04\x12\x04\xae\x01\x04\x0c\n\r\n\x05\x04\n\x02\x04\
    \x05\x12\x04\xae\x01\r\x12\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xae\x01\
    \x13#\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xae\x01&'\n\x0c\n\x04\x04\n\
    \x02\x05\x12\x04\xaf\x01\x04!\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xaf\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\x05\x05\x12\x04\xaf\x01\r\x12\n\r\n\x05\
    \x04\n\x02\x05\x01\x12\x04\xaf\x01\x13\x1c\n\r\n\x05\x04\n\x02\x05\x03\
    \x12\x04\xaf\x01\x1f\x20\n\x88\x01\n\x02\x04\x0b\x12\x06\xb6\x01\0\xb8\
    \x01\x01\x1az*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTransactio\
    nSign.\x20Permutation\x20on\x20key\x20images.\n\x20@next\x20MoneroTransa\
    ctionInputsPermutationAck\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb6\x01\x081\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xb7\x01\x04\x1d\n\r\n\x05\x04\x0b\x02\
    \0\x04\x12\x04\xb7\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xb7\
    \x01\r\x13\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xb7\x01\x14\x18\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xb7\x01\x1b\x1c\nr\n\x02\x04\x0c\x12\x06\xbe\
    \x01\0\xbf\x01\x01\x1ad*\n\x20Response:\x20Response\x20to\x20setting\x20\
    permutation\x20on\x20key\x20images\n\x20@next\x20MoneroTransactionInputV\
    iniRequest\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xbe\x01\x08-\n\x9c\x01\n\
    \x02\x04\r\x12\x06\xc5\x01\0\xcc\x01\x01\x1a\x8d\x01*\n\x20Request:\x20S\
    ub\x20request\x20of\x20MoneroTransactionSign.\x20Sends\x20one\x20UTXO\
    \x20to\x20device\x20together\x20with\x20sealed\x20values.\n\x20@next\x20\
    MoneroTransactionInputViniAck\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc5\x01\
    \x08)\n\x0c\n\x04\x04\r\x02\0\x12\x04\xc6\x01\x047\n\r\n\x05\x04\r\x02\0\
    \x04\x12\x04\xc6\x01\x04\x0c\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc6\x01\r\
    )\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xc6\x01*2\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xc6\x0156\n\"\n\x04\x04\r\x02\x01\x12\x04\xc7\x01\x04\x1c\"\x14\
    \x20xmrtypes.TxinToKey\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xc7\x01\x04\
    \x0c\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xc7\x01\r\x12\n\r\n\x05\x04\r\
    \x02\x01\x01\x12\x04\xc7\x01\x13\x17\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\
    \xc7\x01\x1a\x1b\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xc8\x01\x04!\n\r\n\
    \x05\x04\r\x02\x02\x04\x12\x04\xc8\x01\x04\x0c\n\r\n\x05\x04\r\x02\x02\
    \x05\x12\x04\xc8\x01\r\x12\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xc8\x01\
    \x13\x1c\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xc8\x01\x1f\x20\n\x0c\n\x04\
    \x04\r\x02\x03\x12\x04\xc9\x01\x04\"\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\
    \xc9\x01\x04\x0c\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xc9\x01\r\x12\n\r\n\
    \x05\x04\r\x02\x03\x01\x12\x04\xc9\x01\x13\x1d\n\r\n\x05\x04\r\x02\x03\
    \x03\x12\x04\xc9\x01\x20!\n\x0c\n\x04\x04\r\x02\x04\x12\x04\xca\x01\x04'\
    \n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xca\x01\x04\x0c\n\r\n\x05\x04\r\x02\
    \x04\x05\x12\x04\xca\x01\r\x12\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xca\
    \x01\x13\"\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xca\x01%&\nA\n\x04\x04\r\
    \x02\x05\x12\x04\xcb\x01\x04!\"3\x20original\x20sort\x20index,\x20before\
    \x20sorting\x20by\x20key-images\n\n\r\n\x05\x04\r\x02\x05\x04\x12\x04\
    \xcb\x01\x04\x0c\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xcb\x01\r\x13\n\r\n\
    \x05\x04\r\x02\x05\x01\x12\x04\xcb\x01\x14\x1c\n\r\n\x05\x04\r\x02\x05\
    \x03\x12\x04\xcb\x01\x1f\x20\n\x98\x01\n\x02\x04\x0e\x12\x06\xd3\x01\0\
    \xd4\x01\x01\x1a\x89\x01*\n\x20Response:\x20Response\x20to\x20setting\
    \x20UTXO\x20to\x20the\x20device\n\x20@next\x20MoneroTransactionInputVini\
    Request\n\x20@next\x20MoneroTransactionAllInputsSetRequest\n\n\x0b\n\x03\
    \x04\x0e\x01\x12\x04\xd3\x01\x08%\n\xaf\x01\n\x02\x04\x0f\x12\x06\xda\
    \x01\0\xdb\x01\x01\x1a\xa0\x01*\n\x20Request:\x20Sub\x20request\x20of\
    \x20MoneroTransactionSign.\x20Sent\x20after\x20all\x20inputs\x20have\x20\
    been\x20sent.\x20Useful\x20for\x20rangeisg\x20offloading.\n\x20@next\x20\
    MoneroTransactionAllInputsSetAck\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xda\
    \x01\x08,\np\n\x02\x04\x10\x12\x06\xe1\x01\0\xe3\x01\x01\x1ab*\n\x20Resp\
    onse:\x20Response\x20to\x20after\x20all\x20inputs\x20have\x20been\x20set\
    .\n\x20@next\x20MoneroTransactionSetOutputRequest\n\n\x0b\n\x03\x04\x10\
    \x01\x12\x04\xe1\x01\x08(\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xe2\x01\x045\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe2\x01\x04\x0c\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xe2\x01\r&\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xe2\
    \x01'0\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe2\x0134\n\x9b\x01\n\x02\x04\
    \x11\x12\x06\xe9\x01\0\xee\x01\x01\x1a\x8c\x01*\n\x20Request:\x20Sub\x20\
    request\x20of\x20MoneroTransactionSign.\x20Sends\x20one\x20transaction\
    \x20destination\x20to\x20device\x20(HMACed)\n\x20@next\x20MoneroTransact\
    ionSetOutputAck\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xe9\x01\x08)\n\x0c\n\
    \x04\x04\x11\x02\0\x12\x04\xea\x01\x04<\n\r\n\x05\x04\x11\x02\0\x04\x12\
    \x04\xea\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xea\x01\r.\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\xea\x01/7\n\r\n\x05\x04\x11\x02\0\x03\
    \x12\x04\xea\x01:;\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xeb\x01\x04%\n\r\
    \n\x05\x04\x11\x02\x01\x04\x12\x04\xeb\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x01\x05\x12\x04\xeb\x01\r\x12\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xeb\
    \x01\x13\x20\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xeb\x01#$\n\x0c\n\x04\
    \x04\x11\x02\x02\x12\x04\xec\x01\x045\n\r\n\x05\x04\x11\x02\x02\x04\x12\
    \x04\xec\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xec\x01\r&\n\
    \r\n\x05\x04\x11\x02\x02\x01\x12\x04\xec\x01'0\n\r\n\x05\x04\x11\x02\x02\
    \x03\x12\x04\xec\x0134\n1\n\x04\x04\x11\x02\x03\x12\x04\xed\x01\x04&\"#\
    \x20Extra\x20message,\x20with\x20offloaded\x20BP.\n\n\r\n\x05\x04\x11\
    \x02\x03\x04\x12\x04\xed\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x03\x05\x12\
    \x04\xed\x01\r\x11\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xed\x01\x12!\n\
    \r\n\x05\x04\x11\x02\x03\x03\x12\x04\xed\x01$%\n\xd5\x01\n\x02\x04\x12\
    \x12\x06\xf5\x01\0\xfb\x01\x01\x1a\xc6\x01*\n\x20Response:\x20Response\
    \x20to\x20setting\x20transaction\x20destination.\x20Contains\x20sealed\
    \x20values\x20needed\x20for\x20further\x20protocol\x20steps.\n\x20@next\
    \x20MoneroTransactionSetOutputRequest\n\x20@next\x20MoneroTransactionAll\
    OutSetRequest\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xf5\x01\x08%\n\x1e\n\x04\
    \x04\x12\x02\0\x12\x04\xf6\x01\x04\x1e\"\x10\x20xmrtypes.TxOut\n\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04\xf6\x01\x04\x0c\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xf6\x01\r\x12\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xf6\x01\
    \x13\x19\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xf6\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xf7\x01\x04\"\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xf7\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xf7\x01\r\x12\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xf7\x01\x13\x1d\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xf7\x01\x20!\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\
    \xf8\x01\x045\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xf8\x01\x04\x0c\n\r\
    \n\x05\x04\x12\x02\x02\x06\x12\x04\xf8\x01\r&\n\r\n\x05\x04\x12\x02\x02\
    \x01\x12\x04\xf8\x01'0\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xf8\x0134\n\
    \x0c\n\x04\x04\x12\x02\x03\x12\x04\xf9\x01\x04\x1e\n\r\n\x05\x04\x12\x02\
    \x03\x04\x12\x04\xf9\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\
    \xf9\x01\r\x12\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xf9\x01\x13\x19\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\xf9\x01\x1c\x1d\n\x0c\n\x04\x04\x12\
    \x02\x04\x12\x04\xfa\x01\x04!\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xfa\
    \x01\x04\x0c\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xfa\x01\r\x12\n\r\n\
    \x05\x04\x12\x02\x04\x01\x12\x04\xfa\x01\x13\x1c\n\r\n\x05\x04\x12\x02\
    \x04\x03\x12\x04\xfa\x01\x1f\x20\n\x86\x01\n\x02\x04\x13\x12\x06\x81\x02\
    \0\x83\x02\x01\x1ax*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTran\
    sactionSign.\x20Sent\x20after\x20all\x20outputs\x20are\x20sent.\n\x20@ne\
    xt\x20MoneroTransactionAllOutSetAck\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \x81\x02\x08)\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x82\x02\x045\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\x82\x02\x04\x0c\n\r\n\x05\x04\x13\x02\0\x06\
    \x12\x04\x82\x02\r&\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x82\x02'0\n\r\n\
    \x05\x04\x13\x02\0\x03\x12\x04\x82\x0234\n\x8a\x01\n\x02\x04\x14\x12\x06\
    \x89\x02\0\x97\x02\x01\x1a|*\n\x20Response:\x20After\x20all\x20outputs\
    \x20are\x20sent\x20the\x20initial\x20RCT\x20signature\x20fields\x20are\
    \x20sent.\n\x20@next\x20MoneroTransactionSignInputRequest\n\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\x89\x02\x08%\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x8a\
    \x02\x04\x1d\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x8a\x02\x04\x0c\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\x8a\x02\r\x12\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\x8a\x02\x13\x18\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x8a\x02\x1b\
    \x1c\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x8b\x02\x04&\n\r\n\x05\x04\x14\
    \x02\x01\x04\x12\x04\x8b\x02\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\x8b\x02\r\x12\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x8b\x02\x13!\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\x8b\x02$%\n\x1f\n\x04\x04\x14\x02\
    \x02\x12\x04\x8c\x02\x04$\"\x11\x20xmrtypes.RctSig\n\n\r\n\x05\x04\x14\
    \x02\x02\x04\x12\x04\x8c\x02\x04\x0c\n\r\n\x05\x04\x14\x02\x02\x06\x12\
    \x04\x8c\x02\r\x1c\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\x8c\x02\x1d\x1f\
    \n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x8c\x02\"#\n\x0c\n\x04\x04\x14\
    \x02\x03\x12\x04\x8d\x02\x04)\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\x8d\
    \x02\x04\x0c\n\r\n\x05\x04\x14\x02\x03\x05\x12\x04\x8d\x02\r\x12\n\r\n\
    \x05\x04\x14\x02\x03\x01\x12\x04\x8d\x02\x13$\n\r\n\x05\x04\x14\x02\x03\
    \x03\x12\x04\x8d\x02'(\nR\n\x04\x04\x14\x03\0\x12\x06\x92\x02\x04\x96\
    \x02\x05\x1aB\n\x20Structure\x20represents\x20initial\x20fields\x20of\
    \x20the\x20Monero\x20RCT\x20signature\n\n\r\n\x05\x04\x14\x03\0\x01\x12\
    \x04\x92\x02\x0c\x1b\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\x93\x02\x08\
    $\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\x93\x02\x08\x10\n\x0f\n\
    \x07\x04\x14\x03\0\x02\0\x05\x12\x04\x93\x02\x11\x17\n\x0f\n\x07\x04\x14\
    \x03\0\x02\0\x01\x12\x04\x93\x02\x18\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\0\
    \x03\x12\x04\x93\x02\"#\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x94\
    \x02\x08#\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x04\x12\x04\x94\x02\x08\x10\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x01\x05\x12\x04\x94\x02\x11\x16\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x01\x01\x12\x04\x94\x02\x17\x1e\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x01\x03\x12\x04\x94\x02!\"\n\x0e\n\x06\x04\x14\x03\0\x02\
    \x02\x12\x04\x95\x02\x08$\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\
    \x95\x02\x08\x10\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\x95\x02\
    \x11\x17\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x01\x12\x04\x95\x02\x18\x1f\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x02\x03\x12\x04\x95\x02\"#\n\x81\x01\n\x02\
    \x04\x15\x12\x06\x9d\x02\0\xa6\x02\x01\x1as*\n\x20Request:\x20Sub\x20req\
    uest\x20of\x20MoneroTransactionSign.\x20Sends\x20UTXO\x20for\x20the\x20s\
    igning.\n\x20@next\x20MoneroTransactionSignInputAck\n\n\x0b\n\x03\x04\
    \x15\x01\x12\x04\x9d\x02\x08)\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x9e\x02\
    \x047\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\x9e\x02\x04\x0c\n\r\n\x05\x04\
    \x15\x02\0\x06\x12\x04\x9e\x02\r)\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \x9e\x02*2\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x9e\x0256\n\"\n\x04\x04\
    \x15\x02\x01\x12\x04\x9f\x02\x04\x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\n\
    \x05\x04\x15\x02\x01\x04\x12\x04\x9f\x02\x04\x0c\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\x9f\x02\r\x12\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x9f\
    \x02\x13\x17\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x9f\x02\x1a\x1b\n\x0c\
    \n\x04\x04\x15\x02\x02\x12\x04\xa0\x02\x04!\n\r\n\x05\x04\x15\x02\x02\
    \x04\x12\x04\xa0\x02\x04\x0c\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xa0\
    \x02\r\x12\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xa0\x02\x13\x1c\n\r\n\
    \x05\x04\x15\x02\x02\x03\x12\x04\xa0\x02\x1f\x20\n\x0c\n\x04\x04\x15\x02\
    \x03\x12\x04\xa1\x02\x04\"\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xa1\x02\
    \x04\x0c\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xa1\x02\r\x12\n\r\n\x05\
    \x04\x15\x02\x03\x01\x12\x04\xa1\x02\x13\x1d\n\r\n\x05\x04\x15\x02\x03\
    \x03\x12\x04\xa1\x02\x20!\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xa2\x02\
    \x04'\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\xa2\x02\x04\x0c\n\r\n\x05\
    \x04\x15\x02\x04\x05\x12\x04\xa2\x02\r\x12\n\r\n\x05\x04\x15\x02\x04\x01\
    \x12\x04\xa2\x02\x13\"\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xa2\x02%&\n\
    \x0c\n\x04\x04\x15\x02\x05\x12\x04\xa3\x02\x04(\n\r\n\x05\x04\x15\x02\
    \x05\x04\x12\x04\xa3\x02\x04\x0c\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\
    \xa3\x02\r\x12\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xa3\x02\x13#\n\r\n\
    \x05\x04\x15\x02\x05\x03\x12\x04\xa3\x02&'\n\x0c\n\x04\x04\x15\x02\x06\
    \x12\x04\xa4\x02\x04!\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xa4\x02\x04\
    \x0c\n\r\n\x05\x04\x15\x02\x06\x05\x12\x04\xa4\x02\r\x12\n\r\n\x05\x04\
    \x15\x02\x06\x01\x12\x04\xa4\x02\x13\x1c\n\r\n\x05\x04\x15\x02\x06\x03\
    \x12\x04\xa4\x02\x1f\x20\nA\n\x04\x04\x15\x02\x07\x12\x04\xa5\x02\x04!\"\
    3\x20original\x20sort\x20index,\x20before\x20sorting\x20by\x20key-images\
    \n\n\r\n\x05\x04\x15\x02\x07\x04\x12\x04\xa5\x02\x04\x0c\n\r\n\x05\x04\
    \x15\x02\x07\x05\x12\x04\xa5\x02\r\x13\n\r\n\x05\x04\x15\x02\x07\x01\x12\
    \x04\xa5\x02\x14\x1c\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\xa5\x02\x1f\
    \x20\n\xb0\x01\n\x02\x04\x16\x12\x06\xad\x02\0\xb0\x02\x01\x1a\xa1\x01*\
    \n\x20Response:\x20Contains\x20full\x20MG\x20signature\x20of\x20the\x20U\
    TXO\x20+\x20multisig\x20data\x20if\x20applicable.\n\x20@next\x20MoneroTr\
    ansactionSignInputRequest\n\x20@next\x20MoneroTransactionFinalRequest\n\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\xad\x02\x08%\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\xae\x02\x04!\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xae\x02\x04\
    \x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xae\x02\r\x12\n\r\n\x05\x04\x16\
    \x02\0\x01\x12\x04\xae\x02\x13\x1c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \xae\x02\x1f\x20\n8\n\x04\x04\x16\x02\x01\x12\x04\xaf\x02\x04\"\"*\x20up\
    dated\x20pseudo-out\x20after\x20mask\x20correction\n\n\r\n\x05\x04\x16\
    \x02\x01\x04\x12\x04\xaf\x02\x04\x0c\n\r\n\x05\x04\x16\x02\x01\x05\x12\
    \x04\xaf\x02\r\x12\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xaf\x02\x13\x1d\
    \n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xaf\x02\x20!\n\x99\x01\n\x02\x04\
    \x17\x12\x06\xb6\x02\0\xb7\x02\x01\x1a\x8a\x01*\n\x20Request:\x20Sub\x20\
    request\x20of\x20MoneroTransactionSign.\x20Final\x20message\x20of\x20the\
    \x20procol\x20after\x20all\x20UTXOs\x20are\x20signed\n\x20@next\x20Moner\
    oTransactionFinalAck\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xb6\x02\x08%\n\
    \x9b\x01\n\x02\x04\x18\x12\x06\xbd\x02\0\xc3\x02\x01\x1a\x8c\x01*\n\x20R\
    esponse:\x20Contains\x20transaction\x20metadata\x20and\x20encryption\x20\
    keys\x20needed\x20for\x20further\x20transaction\x20operations\x20(e.g.\
    \x20multisig,\x20send\x20proof).\n\x20@end\n\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xbd\x02\x08!\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xbe\x02\x04\x20\n\r\
    \n\x05\x04\x18\x02\0\x04\x12\x04\xbe\x02\x04\x0c\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xbe\x02\r\x12\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xbe\x02\
    \x13\x1b\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xbe\x02\x1e\x1f\n\x0c\n\x04\
    \x04\x18\x02\x01\x12\x04\xbf\x02\x04\x1c\n\r\n\x05\x04\x18\x02\x01\x04\
    \x12\x04\xbf\x02\x04\x0c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xbf\x02\r\
    \x12\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xbf\x02\x13\x17\n\r\n\x05\x04\
    \x18\x02\x01\x03\x12\x04\xbf\x02\x1a\x1b\n\x0c\n\x04\x04\x18\x02\x02\x12\
    \x04\xc0\x02\x04!\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xc0\x02\x04\x0c\
    \n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xc0\x02\r\x12\n\r\n\x05\x04\x18\
    \x02\x02\x01\x12\x04\xc0\x02\x13\x1c\n\r\n\x05\x04\x18\x02\x02\x03\x12\
    \x04\xc0\x02\x1f\x20\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xc1\x02\x04#\n\
    \r\n\x05\x04\x18\x02\x03\x04\x12\x04\xc1\x02\x04\x0c\n\r\n\x05\x04\x18\
    \x02\x03\x05\x12\x04\xc1\x02\r\x12\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\
    \xc1\x02\x13\x1e\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xc1\x02!\"\nR\n\
    \x04\x04\x18\x02\x04\x12\x04\xc2\x02\x04#\"D\x20enc\x20master\x20key\x20\
    to\x20decrypt\x20MLSAGs\x20after\x20protocol\x20finishes\x20correctly\n\
    \n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\xc2\x02\x04\x0c\n\r\n\x05\x04\x18\
    \x02\x04\x05\x12\x04\xc2\x02\r\x12\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\
    \xc2\x02\x13\x1e\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xc2\x02!\"\n\x85\
    \x01\n\x02\x04\x19\x12\x06\xca\x02\0\xd7\x02\x01\x1aw*\n\x20Request:\x20\
    Sub\x20request\x20of\x20MoneroKeyImageSync.\x20Initializing\x20key\x20im\
    age\x20sync.\n\x20@start\n\x20@next\x20MoneroKeyImageExportInitAck\n\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xca\x02\x08'\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\xcb\x02\x04\x1c\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xcb\x02\x04\
    \x0c\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xcb\x02\r\x13\n\r\n\x05\x04\x19\
    \x02\0\x01\x12\x04\xcb\x02\x14\x17\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xcb\x02\x1a\x1b\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xcc\x02\x04\x1c\n\r\
    \n\x05\x04\x19\x02\x01\x04\x12\x04\xcc\x02\x04\x0c\n\r\n\x05\x04\x19\x02\
    \x01\x05\x12\x04\xcc\x02\r\x12\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xcc\
    \x02\x13\x17\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xcc\x02\x1a\x1b\n>\n\
    \x04\x04\x19\x02\x02\x12\x04\xcd\x02\x04\"\"0\x20BIP-32\x20path\x20to\
    \x20derive\x20the\x20key\x20from\x20master\x20node\n\n\r\n\x05\x04\x19\
    \x02\x02\x04\x12\x04\xcd\x02\x04\x0c\n\r\n\x05\x04\x19\x02\x02\x05\x12\
    \x04\xcd\x02\r\x13\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xcd\x02\x14\x1d\
    \n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xcd\x02\x20!\n-\n\x04\x04\x19\x02\
    \x03\x12\x04\xce\x02\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stag\
    enet\n\n\r\n\x05\x04\x19\x02\x03\x04\x12\x04\xce\x02\x04\x0c\n\r\n\x05\
    \x04\x19\x02\x03\x05\x12\x04\xce\x02\r\x13\n\r\n\x05\x04\x19\x02\x03\x01\
    \x12\x04\xce\x02\x14\x20\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xce\x02#$\
    \n\x0c\n\x04\x04\x19\x02\x04\x12\x04\xcf\x02\x042\n\r\n\x05\x04\x19\x02\
    \x04\x04\x12\x04\xcf\x02\x04\x0c\n\r\n\x05\x04\x19\x02\x04\x06\x12\x04\
    \xcf\x02\r(\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\xcf\x02)-\n\r\n\x05\
    \x04\x19\x02\x04\x03\x12\x04\xcf\x0201\nG\n\x04\x04\x19\x03\0\x12\x06\
    \xd3\x02\x04\xd6\x02\x05\x1a7*\n\x20Structure\x20representing\x20Monero\
    \x20list\x20of\x20sub-addresses\n\n\r\n\x05\x04\x19\x03\0\x01\x12\x04\
    \xd3\x02\x0c'\n\x0e\n\x06\x04\x19\x03\0\x02\0\x12\x04\xd4\x02\x08$\n\x0f\
    \n\x07\x04\x19\x03\0\x02\0\x04\x12\x04\xd4\x02\x08\x10\n\x0f\n\x07\x04\
    \x19\x03\0\x02\0\x05\x12\x04\xd4\x02\x11\x17\n\x0f\n\x07\x04\x19\x03\0\
    \x02\0\x01\x12\x04\xd4\x02\x18\x1f\n\x0f\n\x07\x04\x19\x03\0\x02\0\x03\
    \x12\x04\xd4\x02\"#\n\x0e\n\x06\x04\x19\x03\0\x02\x01\x12\x04\xd5\x02\
    \x08*\n\x0f\n\x07\x04\x19\x03\0\x02\x01\x04\x12\x04\xd5\x02\x08\x10\n\
    \x0f\n\x07\x04\x19\x03\0\x02\x01\x05\x12\x04\xd5\x02\x11\x17\n\x0f\n\x07\
    \x04\x19\x03\0\x02\x01\x01\x12\x04\xd5\x02\x18%\n\x0f\n\x07\x04\x19\x03\
    \0\x02\x01\x03\x12\x04\xd5\x02()\nk\n\x02\x04\x1a\x12\x06\xdd\x02\0\xde\
    \x02\x01\x1a]*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\
    \x20initialization.\n\x20@next\x20MoneroKeyImageSyncStepRequest\n\n\x0b\
    \n\x03\x04\x1a\x01\x12\x04\xdd\x02\x08#\n\x93\x01\n\x02\x04\x1b\x12\x06\
    \xe4\x02\0\xf1\x02\x01\x1a\x84\x01*\n\x20Request:\x20Sub\x20request\x20o\
    f\x20MoneroKeyImageSync.\x20Contains\x20batch\x20of\x20the\x20UTXO\x20to\
    \x20export\x20key\x20image\x20for.\n\x20@next\x20MoneroKeyImageSyncStepA\
    ck\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe4\x02\x08%\n\x0c\n\x04\x04\x1b\
    \x02\0\x12\x04\xe5\x02\x04,\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe5\x02\
    \x04\x0c\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe5\x02\r\"\n\r\n\x05\x04\
    \x1b\x02\0\x01\x12\x04\xe5\x02#'\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe5\
    \x02*+\nI\n\x04\x04\x1b\x03\0\x12\x06\xe9\x02\x04\xf0\x02\x05\x1a9*\n\
    \x20Structure\x20representing\x20Monero\x20UTXO\x20for\x20key\x20image\
    \x20sync\n\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\xe9\x02\x0c!\n\x0e\n\x06\
    \x04\x1b\x03\0\x02\0\x12\x04\xea\x02\x08#\n\x0f\n\x07\x04\x1b\x03\0\x02\
    \0\x04\x12\x04\xea\x02\x08\x10\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x05\x12\
    \x04\xea\x02\x11\x16\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x01\x12\x04\xea\x02\
    \x17\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\x12\x04\xea\x02!\"\n\x0e\n\
    \x06\x04\x1b\x03\0\x02\x01\x12\x04\xeb\x02\x08&\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x01\x04\x12\x04\xeb\x02\x08\x10\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\
    \x05\x12\x04\xeb\x02\x11\x16\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x01\x12\
    \x04\xeb\x02\x17!\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x03\x12\x04\xeb\x02$\
    %\n\x0e\n\x06\x04\x1b\x03\0\x02\x02\x12\x04\xec\x02\x082\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x02\x04\x12\x04\xec\x02\x08\x10\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x02\x05\x12\x04\xec\x02\x11\x16\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\
    \x01\x12\x04\xec\x02\x17-\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x03\x12\x04\
    \xec\x0201\n\x0e\n\x06\x04\x1b\x03\0\x02\x03\x12\x04\xed\x02\x082\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x03\x04\x12\x04\xed\x02\x08\x10\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x03\x05\x12\x04\xed\x02\x11\x17\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x03\x01\x12\x04\xed\x02\x18-\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\
    \x12\x04\xed\x0201\n\x0e\n\x06\x04\x1b\x03\0\x02\x04\x12\x04\xee\x02\x08\
    +\n\x0f\n\x07\x04\x1b\x03\0\x02\x04\x04\x12\x04\xee\x02\x08\x10\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x04\x05\x12\x04\xee\x02\x11\x17\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x04\x01\x12\x04\xee\x02\x18&\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x04\x03\x12\x04\xee\x02)*\n\x0e\n\x06\x04\x1b\x03\0\x02\x05\x12\x04\
    \xef\x02\x08+\n\x0f\n\x07\x04\x1b\x03\0\x02\x05\x04\x12\x04\xef\x02\x08\
    \x10\n\x0f\n\x07\x04\x1b\x03\0\x02\x05\x05\x12\x04\xef\x02\x11\x17\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x05\x01\x12\x04\xef\x02\x18&\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x05\x03\x12\x04\xef\x02)*\n\xaf\x01\n\x02\x04\x1c\x12\x06\
    \xf8\x02\0\x81\x03\x01\x1a\xa0\x01*\n\x20Response:\x20Response\x20to\x20\
    key\x20image\x20sync\x20step.\x20Contains\x20encrypted\x20exported\x20ke\
    y\x20image.\n\x20@next\x20MoneroKeyImageSyncStepRequest\n\x20@next\x20Mo\
    neroKeyImageSyncFinalRequest\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf8\x02\
    \x08!\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xf9\x02\x04,\n\r\n\x05\x04\x1c\
    \x02\0\x04\x12\x04\xf9\x02\x04\x0c\n\r\n\x05\x04\x1c\x02\0\x06\x12\x04\
    \xf9\x02\r#\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf9\x02$'\n\r\n\x05\x04\
    \x1c\x02\0\x03\x12\x04\xf9\x02*+\nN\n\x04\x04\x1c\x03\0\x12\x06\xfd\x02\
    \x04\x80\x03\x05\x1a>*\n\x20Structure\x20representing\x20Monero\x20encry\
    pted\x20exported\x20key\x20image\n\n\r\n\x05\x04\x1c\x03\0\x01\x12\x04\
    \xfd\x02\x0c\"\n\x0e\n\x06\x04\x1c\x03\0\x02\0\x12\x04\xfe\x02\x08\x1e\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\xfe\x02\x08\x10\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\0\x05\x12\x04\xfe\x02\x11\x16\n\x0f\n\x07\x04\x1c\x03\
    \0\x02\0\x01\x12\x04\xfe\x02\x17\x19\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x03\
    \x12\x04\xfe\x02\x1c\x1d\n\x0e\n\x06\x04\x1c\x03\0\x02\x01\x12\x04\xff\
    \x02\x08\x20\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\xff\x02\x08\
    \x10\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x05\x12\x04\xff\x02\x11\x16\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\x01\x01\x12\x04\xff\x02\x17\x1b\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x01\x03\x12\x04\xff\x02\x1e\x1f\n\x83\x01\n\x02\x04\x1d\
    \x12\x06\x87\x03\0\x88\x03\x01\x1au*\n\x20Request:\x20Sub\x20request\x20\
    of\x20MoneroKeyImageSync.\x20Final\x20message\x20of\x20the\x20sync\x20pr\
    otocol.\n\x20@next\x20MoneroKeyImageSyncFinalAck\n\n\x0b\n\x03\x04\x1d\
    \x01\x12\x04\x87\x03\x08&\nt\n\x02\x04\x1e\x12\x06\x8e\x03\0\x90\x03\x01\
    \x1af*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\x20step.\
    \x20Contains\x20encryption\x20keys\x20for\x20exported\x20key\x20images.\
    \n\x20@end\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x8e\x03\x08\"\n\x0c\n\x04\
    \x04\x1e\x02\0\x12\x04\x8f\x03\x04\x1f\n\r\n\x05\x04\x1e\x02\0\x04\x12\
    \x04\x8f\x03\x04\x0c\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\x8f\x03\r\x12\n\
    \r\n\x05\x04\x1e\x02\0\x01\x12\x04\x8f\x03\x13\x1a\n\r\n\x05\x04\x1e\x02\
    \0\x03\x12\x04\x8f\x03\x1d\x1e\nP\n\x02\x04\x1f\x12\x06\x96\x03\0\xa0\
    \x03\x01\x1aB*\n\x20Request:\x20Decrypt\x20tx\x20private\x20keys\x20blob\
    \n\x20@next\x20MoneroGetTxKeyAck\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\x96\
    \x03\x08\x1d\n>\n\x04\x04\x1f\x02\0\x12\x04\x97\x03\x04\"\"0\x20BIP-32\
    \x20path\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\n\n\r\n\
    \x05\x04\x1f\x02\0\x04\x12\x04\x97\x03\x04\x0c\n\r\n\x05\x04\x1f\x02\0\
    \x05\x12\x04\x97\x03\r\x13\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x97\x03\
    \x14\x1d\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x97\x03\x20!\n-\n\x04\x04\
    \x1f\x02\x01\x12\x04\x98\x03\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\
    \x20stagenet\n\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\x98\x03\x04\x0c\n\r\
    \n\x05\x04\x1f\x02\x01\x05\x12\x04\x98\x03\r\x13\n\r\n\x05\x04\x1f\x02\
    \x01\x01\x12\x04\x98\x03\x14\x20\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\
    \x98\x03#$\n\x0c\n\x04\x04\x1f\x02\x02\x12\x04\x9a\x03\x04\x1d\n\r\n\x05\
    \x04\x1f\x02\x02\x04\x12\x04\x9a\x03\x04\x0c\n\r\n\x05\x04\x1f\x02\x02\
    \x05\x12\x04\x9a\x03\r\x12\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x9a\x03\
    \x13\x18\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\x9a\x03\x1b\x1c\n\x0c\n\
    \x04\x04\x1f\x02\x03\x12\x04\x9b\x03\x04\x1d\n\r\n\x05\x04\x1f\x02\x03\
    \x04\x12\x04\x9b\x03\x04\x0c\n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\x9b\
    \x03\r\x12\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\x9b\x03\x13\x18\n\r\n\
    \x05\x04\x1f\x02\x03\x03\x12\x04\x9b\x03\x1b\x1c\n\x0c\n\x04\x04\x1f\x02\
    \x04\x12\x04\x9c\x03\x04#\n\r\n\x05\x04\x1f\x02\x04\x04\x12\x04\x9c\x03\
    \x04\x0c\n\r\n\x05\x04\x1f\x02\x04\x05\x12\x04\x9c\x03\r\x12\n\r\n\x05\
    \x04\x1f\x02\x04\x01\x12\x04\x9c\x03\x13\x1e\n\r\n\x05\x04\x1f\x02\x04\
    \x03\x12\x04\x9c\x03!\"\n\x0c\n\x04\x04\x1f\x02\x05\x12\x04\x9d\x03\x04&\
    \n\r\n\x05\x04\x1f\x02\x05\x04\x12\x04\x9d\x03\x04\x0c\n\r\n\x05\x04\x1f\
    \x02\x05\x05\x12\x04\x9d\x03\r\x12\n\r\n\x05\x04\x1f\x02\x05\x01\x12\x04\
    \x9d\x03\x13!\n\r\n\x05\x04\x1f\x02\x05\x03\x12\x04\x9d\x03$%\n:\n\x04\
    \x04\x1f\x02\x06\x12\x04\x9e\x03\x04\x1f\",\x20reason\x20to\x20display\
    \x20for\x20user.\x20e.g.,\x20tx_proof\n\n\r\n\x05\x04\x1f\x02\x06\x04\
    \x12\x04\x9e\x03\x04\x0c\n\r\n\x05\x04\x1f\x02\x06\x05\x12\x04\x9e\x03\r\
    \x13\n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\x9e\x03\x14\x1a\n\r\n\x05\x04\
    \x1f\x02\x06\x03\x12\x04\x9e\x03\x1d\x1e\n#\n\x04\x04\x1f\x02\x07\x12\
    \x04\x9f\x03\x04'\"\x15\x20addr\x20for\x20derivation\n\n\r\n\x05\x04\x1f\
    \x02\x07\x04\x12\x04\x9f\x03\x04\x0c\n\r\n\x05\x04\x1f\x02\x07\x05\x12\
    \x04\x9f\x03\r\x12\n\r\n\x05\x04\x1f\x02\x07\x01\x12\x04\x9f\x03\x13\"\n\
    \r\n\x05\x04\x1f\x02\x07\x03\x12\x04\x9f\x03%&\nq\n\x02\x04\x20\x12\x06\
    \xa6\x03\0\xaa\x03\x01\x1ac*\n\x20Response:\x20Response\x20with\x20the\
    \x20re-encrypted\x20private\x20keys\x20and\x20derivations\x20blob\x20und\
    er\x20view\x20key\n\x20@end\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xa6\x03\
    \x08\x19\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xa7\x03\x04\x1c\n\r\n\x05\x04\
    \x20\x02\0\x04\x12\x04\xa7\x03\x04\x0c\n\r\n\x05\x04\x20\x02\0\x05\x12\
    \x04\xa7\x03\r\x12\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xa7\x03\x13\x17\n\
    \r\n\x05\x04\x20\x02\0\x03\x12\x04\xa7\x03\x1a\x1b\n\x0c\n\x04\x04\x20\
    \x02\x01\x12\x04\xa8\x03\x04\x1f\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\
    \xa8\x03\x04\x0c\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xa8\x03\r\x12\n\r\
    \n\x05\x04\x20\x02\x01\x01\x12\x04\xa8\x03\x13\x1a\n\r\n\x05\x04\x20\x02\
    \x01\x03\x12\x04\xa8\x03\x1d\x1e\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xa9\
    \x03\x04&\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\xa9\x03\x04\x0c\n\r\n\
    \x05\x04\x20\x02\x02\x05\x12\x04\xa9\x03\r\x12\n\r\n\x05\x04\x20\x02\x02\
    \x01\x12\x04\xa9\x03\x13!\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xa9\x03$\
    %\nz\n\x02\x04!\x12\x06\xb0\x03\0\xb3\x03\x01\x1al*\n\x20Request:\x20Sta\
    rts\x20live\x20refresh\x20flow.\x20Asks\x20user\x20permission,\x20switch\
    es\x20state\n\x20@next\x20MoneroLiveRefreshStartAck\n\n\x0b\n\x03\x04!\
    \x01\x12\x04\xb0\x03\x08%\n>\n\x04\x04!\x02\0\x12\x04\xb1\x03\x04\"\"0\
    \x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20master\x20no\
    de\n\n\r\n\x05\x04!\x02\0\x04\x12\x04\xb1\x03\x04\x0c\n\r\n\x05\x04!\x02\
    \0\x05\x12\x04\xb1\x03\r\x13\n\r\n\x05\x04!\x02\0\x01\x12\x04\xb1\x03\
    \x14\x1d\n\r\n\x05\x04!\x02\0\x03\x12\x04\xb1\x03\x20!\n-\n\x04\x04!\x02\
    \x01\x12\x04\xb2\x03\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stag\
    enet\n\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xb2\x03\x04\x0c\n\r\n\x05\x04!\
    \x02\x01\x05\x12\x04\xb2\x03\r\x13\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \xb2\x03\x14\x20\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xb2\x03#$\n~\n\x02\
    \x04\"\x12\x06\xba\x03\0\xbc\x03\x01\x1ap*\n\x20Response\x20after\x20use\
    r\x20gave\x20permission\n\x20@next\x20MoneroLiveRefreshStepRequest\n\x20\
    @next\x20MoneroLiveRefreshFinalRequest\n\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xba\x03\x08!\nq\n\x02\x04#\x12\x06\xc2\x03\0\xc8\x03\x01\x1ac*\n\x20Req\
    uest:\x20Request\x20to\x20compute\x20a\x20single\x20key\x20image\x20duri\
    ng\x20live\x20sync\n\x20@next\x20MoneroLiveRefreshStepAck\n\n\x0b\n\x03\
    \x04#\x01\x12\x04\xc2\x03\x08$\n\x0c\n\x04\x04#\x02\0\x12\x04\xc3\x03\
    \x04\x1f\n\r\n\x05\x04#\x02\0\x04\x12\x04\xc3\x03\x04\x0c\n\r\n\x05\x04#\
    \x02\0\x05\x12\x04\xc3\x03\r\x12\n\r\n\x05\x04#\x02\0\x01\x12\x04\xc3\
    \x03\x13\x1a\n\r\n\x05\x04#\x02\0\x03\x12\x04\xc3\x03\x1d\x1e\n\x0c\n\
    \x04\x04#\x02\x01\x12\x04\xc4\x03\x04\"\n\r\n\x05\x04#\x02\x01\x04\x12\
    \x04\xc4\x03\x04\x0c\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xc4\x03\r\x12\n\
    \r\n\x05\x04#\x02\x01\x01\x12\x04\xc4\x03\x13\x1d\n\r\n\x05\x04#\x02\x01\
    \x03\x12\x04\xc4\x03\x20!\n\x0c\n\x04\x04#\x02\x02\x12\x04\xc5\x03\x04%\
    \n\r\n\x05\x04#\x02\x02\x04\x12\x04\xc5\x03\x04\x0c\n\r\n\x05\x04#\x02\
    \x02\x05\x12\x04\xc5\x03\r\x13\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xc5\
    \x03\x14\x20\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xc5\x03#$\n\x0c\n\x04\
    \x04#\x02\x03\x12\x04\xc6\x03\x04'\n\r\n\x05\x04#\x02\x03\x04\x12\x04\
    \xc6\x03\x04\x0c\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xc6\x03\r\x13\n\r\n\
    \x05\x04#\x02\x03\x01\x12\x04\xc6\x03\x14\"\n\r\n\x05\x04#\x02\x03\x03\
    \x12\x04\xc6\x03%&\n\x0c\n\x04\x04#\x02\x04\x12\x04\xc7\x03\x04'\n\r\n\
    \x05\x04#\x02\x04\x04\x12\x04\xc7\x03\x04\x0c\n\r\n\x05\x04#\x02\x04\x05\
    \x12\x04\xc7\x03\r\x13\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xc7\x03\x14\"\
    \n\r\n\x05\x04#\x02\x04\x03\x12\x04\xc7\x03%&\n\x9a\x01\n\x02\x04$\x12\
    \x06\xcf\x03\0\xd2\x03\x01\x1a\x8b\x01*\n\x20Response:\x20Response\x20wi\
    th\x20the\x20encrypted\x20key\x20image\x20+\x20signature\n\x20@next\x20M\
    oneroLiveRefreshStepRequest\n\x20@next\x20MoneroLiveRefreshFinishedReque\
    st\n\n\x0b\n\x03\x04$\x01\x12\x04\xcf\x03\x08\x20\n\x0c\n\x04\x04$\x02\0\
    \x12\x04\xd0\x03\x04\x1c\n\r\n\x05\x04$\x02\0\x04\x12\x04\xd0\x03\x04\
    \x0c\n\r\n\x05\x04$\x02\0\x05\x12\x04\xd0\x03\r\x12\n\r\n\x05\x04$\x02\0\
    \x01\x12\x04\xd0\x03\x13\x17\n\r\n\x05\x04$\x02\0\x03\x12\x04\xd0\x03\
    \x1a\x1b\n\x0c\n\x04\x04$\x02\x01\x12\x04\xd1\x03\x04!\n\r\n\x05\x04$\
    \x02\x01\x04\x12\x04\xd1\x03\x04\x0c\n\r\n\x05\x04$\x02\x01\x05\x12\x04\
    \xd1\x03\r\x12\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xd1\x03\x13\x1c\n\r\n\
    \x05\x04$\x02\x01\x03\x12\x04\xd1\x03\x1f\x20\ne\n\x02\x04%\x12\x06\xd8\
    \x03\0\xda\x03\x01\x1aW*\n\x20Request:\x20Request\x20terminating\x20live\
    \x20refresh\x20mode.\n\x20@next\x20MoneroLiveRefreshFinishedAck\n\n\x0b\
    \n\x03\x04%\x01\x12\x04\xd8\x03\x08%\nO\n\x02\x04&\x12\x06\xe0\x03\0\xe2\
    \x03\x01\x1aA*\n\x20Response:\x20Response\x20on\x20termination\x20of\x20\
    live\x20refresh\x20mode.\n\x20@end\n\n\x0b\n\x03\x04&\x01\x12\x04\xe0\
    \x03\x08!\nx\n\x02\x04'\x12\x06\xe9\x03\0\xf0\x03\x01\x1aj*\n\x20Request\
    :\x20Universal\x20Monero\x20protocol\x20implementation\x20diagnosis\x20r\
    equest.\n\x20@start\n\x20@next\x20DebugMoneroDiagAck\n\n\x0b\n\x03\x04'\
    \x01\x12\x04\xe9\x03\x08\x1e\n\x0c\n\x04\x04'\x02\0\x12\x04\xea\x03\x04\
    \x1c\n\r\n\x05\x04'\x02\0\x04\x12\x04\xea\x03\x04\x0c\n\r\n\x05\x04'\x02\
    \0\x05\x12\x04\xea\x03\r\x13\n\r\n\x05\x04'\x02\0\x01\x12\x04\xea\x03\
    \x14\x17\n\r\n\x05\x04'\x02\0\x03\x12\x04\xea\x03\x1a\x1b\n\x0c\n\x04\
    \x04'\x02\x01\x12\x04\xeb\x03\x04\x1b\n\r\n\x05\x04'\x02\x01\x04\x12\x04\
    \xeb\x03\x04\x0c\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xeb\x03\r\x13\n\r\n\
    \x05\x04'\x02\x01\x01\x12\x04\xeb\x03\x14\x16\n\r\n\x05\x04'\x02\x01\x03\
    \x12\x04\xeb\x03\x19\x1a\n\x0c\n\x04\x04'\x02\x02\x12\x04\xec\x03\x04\
    \x1b\n\r\n\x05\x04'\x02\x02\x04\x12\x04\xec\x03\x04\x0c\n\r\n\x05\x04'\
    \x02\x02\x05\x12\x04\xec\x03\r\x13\n\r\n\x05\x04'\x02\x02\x01\x12\x04\
    \xec\x03\x14\x16\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xec\x03\x19\x1a\n\
    \x0c\n\x04\x04'\x02\x03\x12\x04\xed\x03\x04\x1b\n\r\n\x05\x04'\x02\x03\
    \x04\x12\x04\xed\x03\x04\x0c\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xed\x03\
    \r\x13\n\r\n\x05\x04'\x02\x03\x01\x12\x04\xed\x03\x14\x16\n\r\n\x05\x04'\
    \x02\x03\x03\x12\x04\xed\x03\x19\x1a\n\x0c\n\x04\x04'\x02\x04\x12\x04\
    \xee\x03\x04\x1d\n\r\n\x05\x04'\x02\x04\x04\x12\x04\xee\x03\x04\x0c\n\r\
    \n\x05\x04'\x02\x04\x05\x12\x04\xee\x03\r\x12\n\r\n\x05\x04'\x02\x04\x01\
    \x12\x04\xee\x03\x13\x18\n\r\n\x05\x04'\x02\x04\x03\x12\x04\xee\x03\x1b\
    \x1c\n\x0c\n\x04\x04'\x02\x05\x12\x04\xef\x03\x04\x1d\n\r\n\x05\x04'\x02\
    \x05\x04\x12\x04\xef\x03\x04\x0c\n\r\n\x05\x04'\x02\x05\x05\x12\x04\xef\
    \x03\r\x12\n\r\n\x05\x04'\x02\x05\x01\x12\x04\xef\x03\x13\x18\n\r\n\x05\
    \x04'\x02\x05\x03\x12\x04\xef\x03\x1b\x1c\nH\n\x02\x04(\x12\x06\xf6\x03\
    \0\xfd\x03\x01\x1a:*\n\x20Response:\x20Response\x20to\x20Monero\x20diagn\
    osis\x20protocol.\n\x20@end\n\n\x0b\n\x03\x04(\x01\x12\x04\xf6\x03\x08\
    \x1a\n\x0c\n\x04\x04(\x02\0\x12\x04\xf7\x03\x04\x1c\n\r\n\x05\x04(\x02\0\
    \x04\x12\x04\xf7\x03\x04\x0c\n\r\n\x05\x04(\x02\0\x05\x12\x04\xf7\x03\r\
    \x13\n\r\n\x05\x04(\x02\0\x01\x12\x04\xf7\x03\x14\x17\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\xf7\x03\x1a\x1b\n\x0c\n\x04\x04(\x02\x01\x12\x04\xf8\x03\
    \x04\x1b\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xf8\x03\x04\x0c\n\r\n\x05\
    \x04(\x02\x01\x05\x12\x04\xf8\x03\r\x13\n\r\n\x05\x04(\x02\x01\x01\x12\
    \x04\xf8\x03\x14\x16\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xf8\x03\x19\x1a\
    \n\x0c\n\x04\x04(\x02\x02\x12\x04\xf9\x03\x04\x1b\n\r\n\x05\x04(\x02\x02\
    \x04\x12\x04\xf9\x03\x04\x0c\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xf9\x03\
    \r\x13\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xf9\x03\x14\x16\n\r\n\x05\x04(\
    \x02\x02\x03\x12\x04\xf9\x03\x19\x1a\n\x0c\n\x04\x04(\x02\x03\x12\x04\
    \xfa\x03\x04\x1b\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xfa\x03\x04\x0c\n\r\
    \n\x05\x04(\x02\x03\x05\x12\x04\xfa\x03\r\x13\n\r\n\x05\x04(\x02\x03\x01\
    \x12\x04\xfa\x03\x14\x16\n\r\n\x05\x04(\x02\x03\x03\x12\x04\xfa\x03\x19\
    \x1a\n\x0c\n\x04\x04(\x02\x04\x12\x04\xfb\x03\x04\x1d\n\r\n\x05\x04(\x02\
    \x04\x04\x12\x04\xfb\x03\x04\x0c\n\r\n\x05\x04(\x02\x04\x05\x12\x04\xfb\
    \x03\r\x12\n\r\n\x05\x04(\x02\x04\x01\x12\x04\xfb\x03\x13\x18\n\r\n\x05\
    \x04(\x02\x04\x03\x12\x04\xfb\x03\x1b\x1c\n\x0c\n\x04\x04(\x02\x05\x12\
    \x04\xfc\x03\x04\x1d\n\r\n\x05\x04(\x02\x05\x04\x12\x04\xfc\x03\x04\x0c\
    \n\r\n\x05\x04(\x02\x05\x05\x12\x04\xfc\x03\r\x12\n\r\n\x05\x04(\x02\x05\
    \x01\x12\x04\xfc\x03\x13\x18\n\r\n\x05\x04(\x02\x05\x03\x12\x04\xfc\x03\
    \x1b\x1c\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
